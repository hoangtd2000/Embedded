/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include "stm32f10x_conf.h"

//*********************************************Define**********************************************//
//#define RTOS
#define RTOS2
//*********************************************Variables**********************************************//
extern volatile uint32_t g_SysTick;
//*********************************************Struct*************************************************//
GPIO_InitTypeDef GPIO_InitStructure;
USART_InitTypeDef UART_InitStructure;
//*********************************************Functions**********************************************//
void Gpio_int();
void Uart_init();
void update_g_systick();

int __io_putchar(int ch){
	while (USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);
	USART_SendData(USART1,(uint8_t) ch);
	return 0;
}
void Gpio_int(){
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
	GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_2;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
	GPIO_Init(GPIOB, &GPIO_InitStructure);
}
void Uart_init(){
	//config GPIO for UART1_TX,UART1_RX default
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOA, &GPIO_InitStructure);

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
	GPIO_Init(GPIOA, &GPIO_InitStructure);

	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
	UART_InitStructure.USART_BaudRate = 115200;
	UART_InitStructure.USART_WordLength = USART_WordLength_8b;
	UART_InitStructure.USART_StopBits = USART_StopBits_1;
	UART_InitStructure.USART_Parity = USART_Parity_No;
	UART_InitStructure.USART_Mode	=  USART_Mode_Tx | USART_Mode_Rx;
	UART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
	USART_Init(USART1, &UART_InitStructure);
	USART_Cmd(USART1, ENABLE);

}

void delay(uint32_t timedelay) {
    uint32_t L_Current_tick = g_SysTick;
    while ((g_SysTick - L_Current_tick) < timedelay);
}
//void update_g_systick(){
//	g_SysTick++;
//}
#ifdef RTOS0
int main() {
    Gpio_int();
    Uart_init();
    SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK);
    SysTick_Config(72000);
    __asm volatile("SVC #1"); // Gọi SVC
    while (1) {
//    	USART_SendData(USART1,'a');
//    	printf("Hello Im Hoang  \n");
    	GPIOB->ODR ^= (1<<2);
    	delay(1000);
    }
    return 0;

}
#endif

#ifdef RTOS2

void enable_processor_fault(){
	SCB->SHCSR |= (1<<16);
	SCB->SHCSR |= (1<<17);
	SCB->SHCSR |= (1<<18);
}
int main(void)
{
    // 1. Gán MSP lên vùng stack riêng (cao nhất SRAM)
    scheduler_init(SRAM_END);

    // 2. Enable fault handler để dễ debug
    enable_processor_fault();

    // 3. Khởi tạo UART (hoặc các ngoại vi nếu cần debug)
    Uart_init();

    // 4. Init task stack và thông tin PSP cho từng task
    create_task(idle_task,   SIZE_IDLE_STACK);
    create_task(task1_handler, SIZE_TASK_STACK);
    create_task(task2_handler, SIZE_TASK_STACK);
    create_task(task3_handler, SIZE_TASK_STACK);
    create_task(task4_handler, SIZE_TASK_STACK);

    // 5. Chuyển sang PSP (thread mode dùng PSP để chạy task)
    switch_msp_to_psp();

    // 6. Init SysTick (cho round-robin / delay)
    SysTick_Config(SystemCoreClock / TICK_HZ);

    // 7. Gọi task đầu tiên (task 1)
    task1_handler(); // hoặc yield về scheduler
    while(1);
}

#endif
