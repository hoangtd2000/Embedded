C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE APPLICATION
OBJECT MODULE PLACED IN Application.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.exe Application.c DB OE BR INCDIR(C:\SiLabs\MCU\Inc,../App,../Os,../MCAL,../
                    -Service) SB CD LC OR NOAREGS LARGE OT(0,SPEED)

line level    source

   1          #include "Application.h"
   1      =1  /*
   2      =1   *  Created on: Apr 21, 2025
   3      =1   *      Author: Hoangtd2000
   4      =1   */
   5      =1  #ifndef _APPLICATION_H_
   6      =1  #define _APPLICATION_H_
   7      =1  
   8      =1  #include "Os_scheduler.h"
   1      =2  /*
   2      =2   *  Created on: Apr 21, 2025
   3      =2   *      Author: Hoangtd2000
   4      =2   */
   5      =2  #ifndef _OS_SCHEDULER_H_
   6      =2  #define _OS_SCHEDULER_H_
   7      =2  
   8      =2  #include "Service.h"
   1      =3  /*
   2      =3   *  Created on: Apr 21, 2025
   3      =3   *      Author: Hoangtd2000
   4      =3   */
   5      =3  #ifndef _SERVICE_H_
   6      =3  #define _SERVICE_H_
   7      =3  #include "Dio.h"
   1      =4  /*
   2      =4   *  Created on: Apr 21, 2025
   3      =4   *      Author: Hoangtd2000
   4      =4   */
   5      =4  #ifndef _DIO_H_
   6      =4  #define _DIO_H_
   7      =4  #include <compiler_defs.h>
   1      =5  //-----------------------------------------------------------------------------
   2      =5  // compiler_defs.h
   3      =5  //-----------------------------------------------------------------------------
   4      =5  // Portions of this file are copyright Maarten Brock
   5      =5  // http://sdcc.sourceforge.net
   6      =5  // Portions of this file are copyright 2010, Silicon Laboratories, Inc.
   7      =5  // http://www.silabs.com
   8      =5  //
   9      =5  // GNU LGPL boilerplate:
  10      =5  /** This library is free software; you can redistribute it and/or
  11      =5    * modify it under the terms of the GNU Lesser General Public
  12      =5    * License as published by the Free Software Foundation; either
  13      =5    * version 2.1 of the License, or (at your option) any later version.
  14      =5    *
  15      =5    * This library is distributed in the hope that it will be useful,
  16      =5    * but WITHOUT ANY WARRANTY; without even the implied warranty of
  17      =5    * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  18      =5    * Lesser General Public License for more details.
  19      =5    *
  20      =5    * You should have received a copy of the GNU Lesser General Public
  21      =5    * License along with this library; if not, write to the Free Software
  22      =5    * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  23      =5    *
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 2   

  24      =5    * In other words, you are welcome to use, share and improve this program.
  25      =5    * You are forbidden to forbid anyone else to use, share and improve
  26      =5    * what you give them. Help stamp out software-hoarding!
  27      =5  **/
  28      =5  // Program Description:
  29      =5  //
  30      =5  // **Important Note**: This header file should be included before including
  31      =5  // a device-specific header file such as C8051F300_defs.h.
  32      =5  //
  33      =5  // Macro definitions to accomodate 8051 compiler differences in specifying
  34      =5  // special function registers and other 8051-specific features such as NOP
  35      =5  // generation, and locating variables in memory-specific segments.  The
  36      =5  // compilers are identified by their unique predefined macros. See also:
  37      =5  // http://predef.sourceforge.net/precomp.html
  38      =5  //
  39      =5  // SBIT and SFR define special bit and special function registers at the given
  40      =5  // address. SFR16 and SFR32 define sfr combinations at adjacent addresses in
  41      =5  // little-endian format. SFR16E and SFR32E define sfr combinations without
  42      =5  // prerequisite byte order or adjacency. None of these multi-byte sfr
  43      =5  // combinations will guarantee the order in which they are accessed when read
  44      =5  // or written.
  45      =5  //
  46      =5  // SFR16X and SFR32X for 16 bit and 32 bit xdata registers are not defined
  47      =5  // to avoid portability issues because of compiler endianness.
  48      =5  //
  49      =5  // Example:
  50      =5  // // my_mcu.c: main 'c' file for my mcu
  51      =5  // #include <compiler_defs.h>  // this file
  52      =5  // #include <C8051xxxx_defs.h> // SFR definitions for specific MCU target
  53      =5  //
  54      =5  // SBIT  (P0_1, 0x80, 1);      // Port 0 pin 1
  55      =5  // SFR   (P0, 0x80);           // Port 0
  56      =5  // SFRX  (CPUCS, 0xE600);      // Cypress FX2 Control and Status register in
  57      =5  //                             // xdata memory at 0xE600
  58      =5  // SFR16 (TMR2, 0xCC);         // Timer 2, lsb at 0xCC, msb at 0xCD
  59      =5  // SFR16E(TMR0, 0x8C8A);       // Timer 0, lsb at 0x8A, msb at 0x8C
  60      =5  // SFR32 (MAC0ACC, 0x93);      // SiLabs C8051F120 32 bits MAC0 Accumulator,
  61      =5  //                             // lsb at 0x93, msb at 0x96
  62      =5  // SFR32E(SUMR, 0xE5E4E3E2);   // TI MSC1210 SUMR 32 bits Summation register,
  63      =5  //                             // lsb at 0xE2, msb at 0xE5
  64      =5  //
  65      =5  // Target:         C8051xxxx
  66      =5  // Tool chain:     Generic
  67      =5  // Command Line:   None
  68      =5  // 
  69      =5  // Release 2.6 - 14 DEC 2012 (GO)
  70      =5  //        -Added define for deprecated SDCC keyword 'at'
  71      =5  // Release 2.5 - 12 SEP 2012 (TP)
  72      =5  //    -Added defines for deprecated SDCC keywords bit and code
  73      =5  // Release 2.4 - 27 AUG 2012 (TP)
  74      =5  //    -Added defines for deprecated SDCC keywords interrupt, _asm, and _endasm
  75      =5  // Release 2.3 - 27 MAY 2010 (DM)
  76      =5  //    -Removed 'LOCATED_VARIABLE' pragma from Keil because it is not supported
  77      =5  // Release 2.2 - 06 APR 2010 (ES)
  78      =5  //    -Removed 'PATHINCLUDE' pragma from Raisonance section
  79      =5  // Release 2.1 - 16 JUL 2009 (ES)
  80      =5  //    -Added SEGMENT_POINTER macro definitions for SDCC, Keil, and Raisonance
  81      =5  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for Raisonance
  82      =5  // Release 2.0 - 19 MAY 2009 (ES)
  83      =5  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for SDCC and Keil
  84      =5  // Release 1.9 - 23 OCT 2008 (ES)
  85      =5  //    -Updated Hi-Tech INTERRUPT and INTERRUPT_USING macro definitions
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 3   

  86      =5  //    -Added SFR16 macro defintion for Hi-Tech
  87      =5  // Release 1.8 - 31 JUL 2008 (ES)
  88      =5  //    -Added INTERRUPT_USING and FUNCTION_USING macro's
  89      =5  //    -Added macro's for IAR
  90      =5  //    -Corrected Union definitions for Hi-Tech and added SFR16 macro defintion
  91      =5  // Release 1.7 - 11 SEP 2007 (BW)
  92      =5  //    -Added support for Raisonance EVAL 03.03.42 and Tasking Eval 7.2r1
  93      =5  // Release 1.6 - 27 AUG 2007 (BW)
  94      =5  //    -Updated copyright notice per agreement with Maartin Brock
  95      =5  //    -Added SDCC 2.7.0 "compiler.h" bug fixes
  96      =5  //    -Added memory segment defines (SEG_XDATA, for example)
  97      =5  // Release 1.5 - 24 AUG 2007 (BW)
  98      =5  //    -Added support for NOP () macro
  99      =5  //    -Added support for Hi-Tech ver 9.01
 100      =5  // Release 1.4 - 07 AUG 2007 (PKC)
 101      =5  //    -Removed FID and fixed formatting.
 102      =5  // Release 1.3 - 30 SEP 2007 (TP)
 103      =5  //    -Added INTERRUPT_PROTO_USING to properly support ISR context switching
 104      =5  //     under SDCC.
 105      =5  // Release 1.2 - (BW)
 106      =5  //    -Added support for U8,U16,U32,S8,S16,S32,UU16,UU32 data types
 107      =5  // Release 1.1 - (BW)
 108      =5  //    -Added support for INTERRUPT, INTERRUPT_USING, INTERRUPT_PROTO,
 109      =5  //     SEGMENT_VARIABLE, VARIABLE_SEGMENT_POINTER,
 110      =5  //     SEGMENT_VARIABLE_SEGMENT_POINTER, and LOCATED_VARIABLE
 111      =5  // Release 1.0 - 29 SEP 2006 (PKC)
 112      =5  //    -Initial revision
 113      =5  
 114      =5  //-----------------------------------------------------------------------------
 115      =5  // Header File Preprocessor Directive
 116      =5  //-----------------------------------------------------------------------------
 117      =5  
 118      =5  #ifndef COMPILER_DEFS_H
 119      =5  #define COMPILER_DEFS_H
 120      =5  
 121      =5  //-----------------------------------------------------------------------------
 122      =5  // Macro definitions
 123      =5  //-----------------------------------------------------------------------------
 124      =5  
 125      =5  // SDCC - Small Device C Compiler
 126      =5  // http://sdcc.sourceforge.net
 127      =5  
 128      =5  #if defined SDCC
           =5 
           =5 #if (SDCC >= 300)
           =5 
           =5 #define interrupt __interrupt
           =5 #define _asm __asm
           =5 #define _endasm __endasm
           =5 #define bit __bit
           =5 #define code __code
           =5 #define at __at
           =5 
           =5 #endif
           =5 
           =5 # define SEG_GENERIC
           =5 # define SEG_FAR   __xdata
           =5 # define SEG_DATA  __data
           =5 # define SEG_NEAR  __data
           =5 # define SEG_IDATA __idata
           =5 # define SEG_XDATA __xdata
           =5 # define SEG_PDATA __pdata
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 4   

           =5 # define SEG_CODE  __code
           =5 # define SEG_BDATA __bdata
           =5 
           =5 # define SBIT(name, addr, bit)  __sbit  __at(addr+bit)                  name
           =5 # define SFR(name, addr)        __sfr   __at(addr)                      name
           =5 # define SFRX(name, addr)       xdata volatile unsigned char __at(addr) name
           =5 # define SFR16(name, addr)      __sfr16 __at(((addr+1U)<<8) | addr)     name
           =5 # define SFR16E(name, fulladdr) __sfr16 __at(fulladdr)                  name
           =5 # define SFR32(name, addr)      __sfr32 __at(((addr+3UL)<<24) | ((addr+2UL)<<16) | ((addr+1UL)<<8) | addr)
             - name
           =5 # define SFR32E(name, fulladdr) __sfr32 __at(fulladdr)                  name
           =5 
           =5 # define INTERRUPT(name, vector) void name (void) interrupt (vector)
           =5 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =5 # define INTERRUPT_PROTO(name, vector) void name (void) interrupt (vector)
           =5 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =5 
           =5 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using (regnum
             -)
           =5 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter) using (
             -regnum)
           =5 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =5 
           =5 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =5 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =5 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =5 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =5 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment at (addr) vartype name = init
           =5 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) locsegment at (addr) vartype name
           =5 
           =5 // used with UU16
           =5 # define LSB 0
           =5 # define MSB 1
           =5 
           =5 // used with UU32 (b0 is least-significant byte)
           =5 # define b0 0
           =5 # define b1 1
           =5 # define b2 2
           =5 # define b3 3
           =5 
           =5 typedef unsigned char U8;
           =5 typedef unsigned int U16;
           =5 typedef unsigned long U32;
           =5 
           =5 typedef signed char S8;
           =5 typedef signed int S16;
           =5 typedef signed long S32;
           =5 
           =5 typedef union UU16
           =5 {
           =5    U16 U16;
           =5    S16 S16;
           =5    U8 U8[2];
           =5    S8 S8[2];
           =5 } UU16;
           =5 
           =5 typedef union UU32
           =5 {
           =5    U32 U32;
           =5    S32 S32;
           =5    UU16 UU16[2];
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 5   

           =5    U16 U16[2];
           =5    S16 S16[2];
           =5    U8 U8[4];
           =5    S8 S8[4];
           =5 } UU32;
           =5 
           =5 // NOP () macro support
           =5 #define NOP() _asm NOP _endasm
           =5 
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 // Raisonance (must be placed before Keil C51)
           =5 // http://www.raisonance.com
           =5 
           =5 #elif defined __RC51__
           =5 
           =5 //#error Raisonance C51 detected.
           =5 
           =5 # define SEG_GENERIC generic     //SEG_GENERIC only applies to pointers in Raisonance, not variables.
           =5 # define SEG_FAR   xdata
           =5 # define SEG_DATA  data
           =5 # define SEG_NEAR  data
           =5 # define SEG_IDATA idata
           =5 # define SEG_XDATA xdata
           =5 # define SEG_PDATA pdata
           =5 # define SEG_CODE  code
           =5 # define SEG_BDATA bdata
           =5 
           =5 # define SBIT(name, addr, bit)  at (addr+bit) sbit         name
           =5 # define SFR(name, addr)        sfr at addr                name
           =5 # define SFR16(name, addr)      sfr16 at addr              name
           =5 # define SFR16E(name, fulladdr) /* not supported */
           =5 # define SFR32(name, fulladdr)  /* not supported */
           =5 # define SFR32E(name, fulladdr) /* not supported */
           =5 
           =5 # define INTERRUPT(name, vector) void name (void) interrupt vector
           =5 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =5 # define INTERRUPT_PROTO(name, vector) void name (void)
           =5 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =5 
           =5 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
           =5 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =5 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =5 
           =5 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =5 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =5 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =5 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =5 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) at addr locsegment vartype name
           =5 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) at addr locsegment vartype name
           =5 
           =5 
           =5 // used with UU16
           =5 # define LSB 1
           =5 # define MSB 0
           =5 
           =5 // used with UU32 (b0 is least-significant byte)
           =5 # define b0 3
           =5 # define b1 2
           =5 # define b2 1
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 6   

           =5 # define b3 0
           =5 
           =5 typedef unsigned char U8;
           =5 typedef unsigned int U16;
           =5 typedef unsigned long U32;
           =5 
           =5 typedef signed char S8;
           =5 typedef signed int S16;
           =5 typedef signed long S32;
           =5 
           =5 typedef union UU16
           =5 {
           =5    U16 U16;
           =5    S16 S16;
           =5    U8 U8[2];
           =5    S8 S8[2];
           =5 } UU16;
           =5 
           =5 typedef union UU32
           =5 {
           =5    U32 U32;
           =5    S32 S32;
           =5    UU16 UU16[2];
           =5    U16 U16[2];
           =5    S16 S16[2];
           =5    U8 U8[4];
           =5    S8 S8[4];
           =5 } UU32;
           =5 
           =5 // NOP () macro support -- NOP is opcode 0x00
           =5 #define NOP() asm { 0x00 }
           =5 
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 
           =5 // Keil C51
           =5 // http://www.keil.com
           =5 
           =5 #elif defined __C51__
 307      =5  
 308      =5  //#error Keil C51 detected.
 309      =5  
 310      =5  # define SEG_GENERIC
 311      =5  # define SEG_FAR   xdata
 312      =5  # define SEG_DATA  data
 313      =5  # define SEG_NEAR  data
 314      =5  # define SEG_IDATA idata
 315      =5  # define SEG_XDATA xdata
 316      =5  # define SEG_PDATA pdata
 317      =5  # define SEG_CODE  code
 318      =5  # define SEG_BDATA bdata
 319      =5  
 320      =5  # define SBIT(name, addr, bit)  sbit  name = addr^bit
 321      =5  # define SFR(name, addr)        sfr   name = addr
 322      =5  # define SFR16(name, addr)      sfr16 name = addr
 323      =5  # define SFR16E(name, fulladdr) /* not supported */
 324      =5  # define SFR32(name, fulladdr)  /* not supported */
 325      =5  # define SFR32E(name, fulladdr) /* not supported */
 326      =5  
 327      =5  # define INTERRUPT(name, vector) void name (void) interrupt vector
 328      =5  # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 7   

 329      =5  # define INTERRUPT_PROTO(name, vector) void name (void)
 330      =5  # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
 331      =5  
 332      =5  # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
 333      =5  # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
 334      =5  // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
 335      =5  
 336      =5  # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
 337      =5  # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
 338      =5  # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
 339      =5  # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
 340      =5  # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) vartype locsegment name _at_ addr
 341      =5  
 342      =5  // used with UU16
 343      =5  # define LSB 1
 344      =5  # define MSB 0
 345      =5  
 346      =5  // used with UU32 (b0 is least-significant byte)
 347      =5  # define b0 3
 348      =5  # define b1 2
 349      =5  # define b2 1
 350      =5  # define b3 0
 351      =5  
 352      =5  typedef unsigned char U8;
 353      =5  typedef unsigned int U16;
 354      =5  typedef unsigned long U32;
 355      =5  
 356      =5  typedef signed char S8;
 357      =5  typedef signed int S16;
 358      =5  typedef signed long S32;
 359      =5  
 360      =5  typedef union UU16
 361      =5  {
 362      =5     U16 U16;
 363      =5     S16 S16;
 364      =5     U8 U8[2];
 365      =5     S8 S8[2];
 366      =5  } UU16;
 367      =5  
 368      =5  typedef union UU32
 369      =5  {
 370      =5     U32 U32;
 371      =5     S32 S32;
 372      =5     UU16 UU16[2];
 373      =5     U16 U16[2];
 374      =5     S16 S16[2];
 375      =5     U8 U8[4];
 376      =5     S8 S8[4];
 377      =5  } UU32;
 378      =5  
 379      =5  // NOP () macro support
 380      =5  extern void _nop_ (void);
 381      =5  #define NOP() _nop_()
 382      =5  
 383      =5  //-----------------------------------------------------------------------------
 384      =5  
 385      =5  // Hi-Tech 8051
 386      =5  // http://www.htsoft.com
 387      =5  
 388      =5  #elif defined HI_TECH_C
           =5 
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 8   

           =5 # define SEG_GENERIC
           =5 # define SEG_FAR   far
           =5 # define SEG_DATA  data
           =5 # define SEG_NEAR  near
           =5 # define SEG_IDATA idata
           =5 # define SEG_XDATA xdata
           =5 # define SEG_PDATA pdata
           =5 # define SEG_CODE  code
           =5 # define SEG_BDATA bdata
           =5 
           =5 
           =5 # define SBIT(name, addr, thebit) static volatile bit name @ (addr + thebit)
           =5 # define SFR(name, addr)          static volatile unsigned char name @ addr
           =5 # define SFR16(name, addr)        static volatile unsigned int name @ addr
           =5 # define SFR16E(name, fulladdr) /* not supported */
           =5 # define SFR32(name, fulladdr)  /* not supported */
           =5 # define SFR32E(name, fulladdr) /* not supported */
           =5 
           =5 # define INTERRUPT(name, vector)       void name (void) interrupt vector
           =5 # define INTERRUPT_PROTO(name, vector)
           =5 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =5 # define INTERRUPT_PROTO_USING(name, vector, regnum)
           =5 
           =5 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =5 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =5 // Note: Hi-Tech does not support functions using different register banks. Register
           =5 //       banks can only be specified in interrupts. If a function is called from
           =5 //       inside an interrupt, it will use the same register bank as the interrupt.
           =5 
           =5 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =5 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =5 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =5 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment vartype name @ addr
           =5 
           =5 // used with UU16
           =5 # define LSB 0
           =5 # define MSB 1
           =5 
           =5 // used with UU32 (b0 is least-significant byte)
           =5 # define b0 0
           =5 # define b1 1
           =5 # define b2 2
           =5 # define b3 3
           =5 
           =5 typedef unsigned char U8;
           =5 typedef unsigned int U16;
           =5 typedef unsigned long U32;
           =5 
           =5 typedef signed char S8;
           =5 typedef signed int S16;
           =5 typedef signed long S32;
           =5 
           =5 typedef union UU16
           =5 {
           =5    U16 U16;
           =5    S16 S16;
           =5    U8 U8[2];
           =5    S8 S8[2];
           =5 } UU16;
           =5 
           =5 typedef union UU32
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 9   

           =5 {
           =5    U32 U32;
           =5    S32 S32;
           =5    UU16 UU16[2];
           =5    U16 U16[2];
           =5    S16 S16[2];
           =5    U8 U8[4];
           =5    S8 S8[4];
           =5 } UU32;
           =5 
           =5 // NOP () macro support
           =5 #define NOP() asm(" nop ")
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 // Tasking / Altium
           =5 // http://www.altium.com/tasking
           =5 
           =5 
           =5 #elif defined _CC51
           =5 
           =5 # define SEG_GENERIC
           =5 # define SEG_FAR   _xdat
           =5 # define SEG_DATA  _data
           =5 # define SEG_NEAR  _data
           =5 # define SEG_IDATA _idat
           =5 # define SEG_XDATA _xdat
           =5 # define SEG_PDATA _pdat
           =5 # define SEG_CODE  _rom
           =5 # define SEG_BDATA _bdat
           =5 
           =5 # define SBIT(name, addr, bit)  _sfrbit  name _at(addr+bit)
           =5 # define SFR(name, addr)        _sfrbyte name _at(addr)
           =5 # define SFRX(name, addr)       _xdat volatile unsigned char name _at(addr)
           =5 #if _CC51 > 71
           =5 # define SFR16(name, addr)      _sfrword _little name _at(addr)
           =5 #else
           =5 # define SFR16(name, addr)      /* not supported */
           =5 #endif
           =5 # define SFR16E(name, fulladdr) /* not supported */
           =5 # define SFR32(name, fulladdr)  /* not supported */
           =5 # define SFR32E(name, fulladdr) /* not supported */
           =5 
           =5 # define INTERRUPT(name, vector) _interrupt (vector) void name (void)
           =5 # define INTERRUPT_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =5 # define INTERRUPT_PROTO(name, vector) _interrupt (vector) void name (void)
           =5 # define INTERRUPT_PROTO_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =5 
           =5 // When calling FUNCTION_USING in Tasking, the function must be called from an interrupt or Main which
           =5 // is also using the same register bank. If not, the compiler will generate an error.
           =5 # define FUNCTION_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (parameter
             -)
           =5 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (par
             -ameter)
           =5 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =5 
           =5 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =5 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =5 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =5 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) vartype locsegment name _at( addr )
           =5 
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 10  

           =5 // used with UU16
           =5 # define LSB 1
           =5 # define MSB 0
           =5 
           =5 // used with UU32 (b0 is least-significant byte)
           =5 # define b0 3
           =5 # define b1 2
           =5 # define b2 1
           =5 # define b3 0
           =5 
           =5 typedef unsigned char U8;
           =5 typedef unsigned int U16;
           =5 typedef unsigned long U32;
           =5 
           =5 typedef signed char S8;
           =5 typedef signed int S16;
           =5 typedef signed long S32;
           =5 
           =5 typedef union UU16
           =5 {
           =5    U16 U16;
           =5    S16 S16;
           =5    U8 U8[2];
           =5    S8 S8[2];
           =5 } UU16;
           =5 
           =5 typedef union UU32
           =5 {
           =5    U32 U32;
           =5    S32 S32;
           =5    UU16 UU16[2];
           =5    U16 U16[2];
           =5    S16 S16[2];
           =5    U8 U8[4];
           =5    S8 S8[4];
           =5 } UU32;
           =5 
           =5 // NOP () macro support
           =5 extern void _nop (void);
           =5 #define NOP() _nop()
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 
           =5 // IAR 8051
           =5 // http://www.iar.com
           =5 
           =5 #elif defined __ICC8051__
           =5 
           =5 #include <stdbool.h>
           =5 #include <intrinsics.h>
           =5 
           =5 # define SBIT(name, addr, bit)  __bit __no_init volatile bool name @ (addr+bit)
           =5 # define SFR(name, addr)        __sfr __no_init volatile unsigned char name @ addr
           =5 # define SFRX(name, addr)       __xdata __no_init volatile unsigned char name @ addr
           =5 # define SFR16(name, addr)      __sfr __no_init volatile unsigned int  name @ addr
           =5 # define SFR16E(name, fulladdr) /* not supported */
           =5 # define SFR32(name, fulladdr) /* not supported */
           =5 # define SFR32E(name, fulladdr) /* not supported */
           =5 
           =5 # define SEG_GENERIC __generic
           =5 # define SEG_FAR  __xdata
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 11  

           =5 # define SEG_DATA __data
           =5 # define SEG_NEAR __data
           =5 # define SEG_IDATA __idata
           =5 # define SEG_XDATA __xdata
           =5 # define SEG_PDATA __pdata
           =5 # define SEG_CODE  __code
           =5 # define SEG_BDATA __bdata
           =5 
           =5 #define bit bool
           =5 
           =5 # define _PPTOSTR_(x) #x
           =5 # define _PPARAM_(address) _PPTOSTR_(vector=address * 8 + 3)
           =5 # define _PPARAM2_(regbank) _PPTOSTR_(register_bank=regbank)
           =5 # define INTERRUPT(name, vector) _Pragma(_PPARAM_(vector)) __interrupt void name(void)
           =5 # define INTERRUPT_PROTO(name, vector)  __interrupt void name(void)
           =5 # define INTERRUPT_USING(name, vector, regnum) _Pragma(_PPARAM2_(regnum)) _Pragma(_PPARAM_(vector)) __inte
             -rrupt void name(void)
           =5 # define INTERRUPT_PROTO_USING(name, vector, regnum) __interrupt void name(void)
           =5 
           =5 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =5 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =5 // Note: IAR does not support functions using different register banks. Register
           =5 //       banks can only be specified in interrupts. If a function is called from
           =5 //       inside an interrupt, it will use the same register bank as the interrupt.
           =5 
           =5 # define SEGMENT_VARIABLE(name, vartype, locsegment)  locsegment vartype name
           =5 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment  * name
           =5 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =5 
           =5 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment __no_init vartype name @ addr
           =5 
           =5 // used with UU16
           =5 # define LSB 0
           =5 # define MSB 1
           =5 
           =5 // used with UU32 (b0 is least-significant byte)
           =5 # define b0 0
           =5 # define b1 1
           =5 # define b2 2
           =5 # define b3 3
           =5 
           =5 typedef unsigned char U8;
           =5 typedef unsigned int U16;
           =5 typedef unsigned long U32;
           =5 
           =5 typedef signed char S8;
           =5 typedef signed int S16;
           =5 typedef signed long S32;
           =5 
           =5 typedef union UU16
           =5 {
           =5    U16 U16;
           =5    S16 S16;
           =5    U8 U8[2];
           =5    S8 S8[2];
           =5 } UU16;
           =5 
           =5 typedef union UU32
           =5 {
           =5    U32 U32;
           =5    S32 S32;
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 12  

           =5    UU16 UU16[2];
           =5    U16 U16[2];
           =5    S16 S16[2];
           =5    U8 U8[4];
           =5    S8 S8[4];
           =5 } UU32;
           =5 
           =5 
           =5 #define NOP() __no_operation();
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 // Crossware
           =5 // http://www.crossware.com
           =5 
           =5 #elif defined _XC51_VER
           =5 # define SBIT(name, addr, bit)  _sfrbit  name = (addr+bit)
           =5 # define SFR(name, addr)        _sfr     name = addr
           =5 # define SFR16(name, addr)      _sfrword name = addr
           =5 # define SFR16E(name, fulladdr) /* not supported */
           =5 # define SFR32(name, fulladdr)  /* not supported */
           =5 # define SFR32E(name, fulladdr) /* not supported */
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 // Wickenhäuser
           =5 // http://www.wickenhaeuser.de
           =5 
           =5 #elif defined __UC__
           =5 # define SBIT(name, addr, bit)  unsigned char bit  name @ (addr+bit)
           =5 # define SFR(name, addr)        near unsigned char name @ addr
           =5 # define SFR16(name, addr)      /* not supported */
           =5 # define SFR16E(name, fulladdr) /* not supported */
           =5 # define SFR32(name, fulladdr)  /* not supported */
           =5 # define SFR32E(name, fulladdr) /* not supported */
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 // Default
           =5 // Unknown compiler
           =5 
           =5 #else
           =5 # warning unrecognized compiler
           =5 # define SBIT(name, addr, bit)  volatile bool           name
           =5 # define SFR(name, addr)        volatile unsigned char  name
           =5 # define SFRX(name, addr)       volatile unsigned char  name
           =5 # define SFR16(name, addr)      volatile unsigned short name
           =5 # define SFR16E(name, fulladdr) volatile unsigned short name
           =5 # define SFR32(name, fulladdr)  volatile unsigned long  name
           =5 # define SFR32E(name, fulladdr) volatile unsigned long  name
           =5 
           =5 #endif
 683      =5  
 684      =5  //-----------------------------------------------------------------------------
 685      =5  // Header File PreProcessor Directive
 686      =5  //-----------------------------------------------------------------------------
 687      =5  
 688      =5  #endif                                 // #define COMPILER_DEFS_H
 689      =5  
 690      =5  //-----------------------------------------------------------------------------
 691      =5  // End Of File
 692      =5  //-----------------------------------------------------------------------------
   8      =4  #include <C8051F580_defs.h> // SFR declarations
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 13  

   1      =5  //-----------------------------------------------------------------------------
   2      =5  // C8051F580_defs.h
   3      =5  //-----------------------------------------------------------------------------
   4      =5  // Copyright 2008, Silicon Laboratories, Inc.
   5      =5  // http://www.silabs.com
   6      =5  //
   7      =5  // Program Description:
   8      =5  //
   9      =5  // Register/bit definitions for the C8051F58x family.
  10      =5  // **Important Note**: The compiler_defs.h header file should be included
  11      =5  // before including this header file.
  12      =5  //
  13      =5  // Target:         C8051F580/1/2/3/4/5/6/7,8/9-F590/1
  14      =5  // Tool chain:     Generic
  15      =5  // Command Line:   None
  16      =5  //
  17      =5  // Release 0.6 - 20 AUG 2012 (TP)
  18      =5  //    -Added #define for _XPAGE to provide support for SDCC memory paging
  19      =5  //     (pdata)
  20      =5  //
  21      =5  // Release 0.5 - 10 SEP 2011 (GP)
  22      =5  //    - Fixed SFR16 definition for CAN0IF2MC
  23      =5  //
  24      =5  // Release 0.4 - 08 OCT 2010 (TP)
  25      =5  //    - Fixed bit definitions for SCON0
  26      =5  //
  27      =5  // Release 0.3 - 01 APR 2009 (GP)
  28      =5  //    - Added SN0-SN3
  29      =5  //
  30      =5  // Release 0.2 - 29 JUL 2008 (ADT)
  31      =5  //    - Added Timer 4 bit definitions
  32      =5  //
  33      =5  // Release 0.1 - 09 JUL 2008 (GP)
  34      =5  //    - Initial Revision
  35      =5  //
  36      =5  //-----------------------------------------------------------------------------
  37      =5  // Header File Preprocessor Directive
  38      =5  //-----------------------------------------------------------------------------
  39      =5  
  40      =5  #ifndef C8051F580_DEFS_H
  41      =5  #define C8051F580_DEFS_H
  42      =5  
  43      =5  //-----------------------------------------------------------------------------
  44      =5  // Page 0, Page 1 and Page F Registers
  45      =5  //-----------------------------------------------------------------------------
  46      =5  
  47      =5  SFR (P0, 0x80);                        // Port 0 Latch
  48      =5  SFR (SP, 0x81);                        // Stack Pointer
  49      =5  SFR (DPL, 0x82);                       // Data Pointer Low
  50      =5  SFR (DPH, 0x83);                       // Data Pointer High
  51      =5  SFR (SFR0CN, 0x84);                    // SFR Page Control
  52      =5  SFR (SFRNEXT, 0x85);                   // SFR stack next page
  53      =5  SFR (SFRLAST, 0x86);                   // SFR stack last page
  54      =5  SFR (PCON, 0x87);                      // Power Control
  55      =5  SFR (TCON, 0x88);                      // Timer/Counter Control
  56      =5  SFR (TMOD, 0x89);                      // Timer/Counter Mode
  57      =5  SFR (TL0, 0x8A);                       // Timer/Counter 0 Low
  58      =5  SFR (TL1, 0x8B);                       // Timer/Counter 1 Low
  59      =5  SFR (TH0, 0x8C);                       // Timer/Counter 0 High
  60      =5  SFR (TH1, 0x8D);                       // Timer/Counter 1 High
  61      =5  SFR (CKCON, 0x8E);                     // Clock Control
  62      =5  SFR (PSCTL, 0x8F);                     // Program Store R/W Control
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 14  

  63      =5  SFR (CLKSEL, 0x8F);                    // System clock select
  64      =5  SFR (P1, 0x90);                        // Port 1 Latch
  65      =5  SFR (TMR3CN, 0x91);                    // Timer/Counter 3 Control
  66      =5  SFR (TMR5CN, 0x91);                    // Timer/Counter 5 Control
  67      =5  SFR (TMR3RLL, 0x92);                   // Timer/Counter 3 Reload Low
  68      =5  SFR (TMR5CAPL, 0x92);                  // Timer/Counter 5 Capture Low
  69      =5  SFR (TMR3RLH, 0x93);                   // Timer/Counter 3 Reload High
  70      =5  SFR (TMR5CAPH, 0x93);                  // Timer/Counter 5 Capture High
  71      =5  SFR (TMR3L, 0x94);                     // Timer/Counter 3 Low
  72      =5  SFR (TMR5L, 0x94);                     // Timer/Counter 5 Low
  73      =5  SFR (TMR3H, 0x95);                     // Timer/Counter 3 High
  74      =5  SFR (TMR5H, 0x95);                     // Timer/Counter 5 High
  75      =5  SFR (TMR5CF, 0x96);                    // Timer/Counter 5 Configuration
  76      =5  SFR (CLKMUL, 0x97);                    // Clock Multiplier
  77      =5  SFR (SCON0, 0x98);                     // UART0 Control
  78      =5  SFR (SCON1, 0x98);                     // UART1 Control
  79      =5  SFR (SBUF0, 0x99);                     // UART0 Data Buffer
  80      =5  SFR (SBUF1, 0x99);                     // UART1 Data Buffer
  81      =5  SFR (CPT0CN, 0x9A);                    // Comparator 0 Control
  82      =5  SFR (CPT2CN, 0x9A);                    // Comparator 2 Control
  83      =5  SFR (CPT0MD, 0x9B);                    // Comparator 0 Mode
  84      =5  SFR (CPT2MD, 0x9B);                    // Comparator 2 Mode
  85      =5  SFR (CPT0MX, 0x9C);                    // Comparator 0 Mux
  86      =5  SFR (CPT2MX, 0x9C);                    // Comparator 2 Mux
  87      =5  SFR (CPT1CN, 0x9D);                    // Comparator 1 Control
  88      =5  SFR (CPT1MD, 0x9E);                    // Comparator 0 Mode
  89      =5  SFR (OSCIFIN, 0x9E);                   // Internal Oscillator Fine Control
  90      =5  SFR (CPT1MX, 0x9F);                    // Comparator 1 Mux
  91      =5  SFR (OSCXCN, 0x9F);                    // External Oscillator Control
  92      =5  SFR (P2, 0xA0);                        // Port 2 Latch
  93      =5  SFR (SPI0CFG, 0xA1);                   // SPI0 Configuration
  94      =5  SFR (OSCICN, 0xA1);                    // Internal Oscillator Control
  95      =5  SFR (SPI0CKR, 0xA2);                   // SPI0 Clock rate control
  96      =5  SFR (OSCICRS, 0xA2);                   // Internal Oscillator Coarse Control
  97      =5  SFR (SPI0DAT, 0xA3);                   // SPI0 Data Buffer
  98      =5  SFR (P0MDOUT, 0xA4);                   // Port 0 Output Mode
  99      =5  SFR (P1MDOUT, 0xA5);                   // Port 1 Output Mode
 100      =5  SFR (P2MDOUT, 0xA6);                   // Port 2 Output Mode
 101      =5  SFR (SFRPAGE, 0xA7);                   // SFR Page Select
 102      =5  SFR (IE, 0xA8);                        // Interrupt Enable
 103      =5  SFR (SMOD0, 0xA9);                     // Serial Port 0 Control
 104      =5  SFR (EMI0CN, 0xAA);                    // EMIF Control
 105      =5  SFR (EMI0TC, 0xAA);                    // EMIF Timing control
 106      =5  SFR (SBCON0, 0xAB);                    // UART0 Baud Rate Generator Control
 107      =5  SFR (SBRLL0, 0xAC);                    // UART0 Baud Rate Generator Low
 108      =5  SFR (SBRLH0, 0xAD);                    // UART0 Baud Rate Generator High
 109      =5  SFR (P3MAT, 0xAE);                     // Port 3 Match
 110      =5  SFR (P3MDOUT, 0xAE);                   // Port 3 Mode
 111      =5  SFR (P3MASK, 0xAF);                    // Port 3 Mask
 112      =5  SFR (P4MDOUT, 0xAF);                   // Port 4 Mode
 113      =5  SFR (P3, 0xB0);                        // Port 3 Latch
 114      =5  SFR (P2MAT, 0xB1);                     // Port 2 Match
 115      =5  SFR (P2MASK, 0xB2);                    // Port 2 Mask
 116      =5  SFR (EMI0CF, 0xB2);                    // EMIF Configuration
 117      =5  SFR (P4, 0xB5);                        // Port 4 Latch
 118      =5  SFR (FLSCL, 0xB6);                     // Flash Scale
 119      =5  SFR (FLKEY, 0xB7);                     // Flash access limit
 120      =5  SFR (IP, 0xB8);                        // Interrupt Priority
 121      =5  SFR (SMB0ADR, 0xB9);                   // SMBus0 Slave address
 122      =5  SFR (ADC0TK, 0xBA);                    // ADC0 Tracking Mode Select
 123      =5  SFR (SMB0ADM, 0xBA);                   // SMBus0 Address Mask
 124      =5  SFR (ADC0MX, 0xBB);                    // AMUX0 Channel select
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 15  

 125      =5  SFR (ADC0CF, 0xBC);                    // AMUX0 Channel configuration
 126      =5  SFR (ADC0L, 0xBD);                     // ADC0 Data Low
 127      =5  SFR (ADC0H, 0xBE);                     // ADC0 Data High
 128      =5  SFR (SMB0CN, 0xC0);                    // SMBus0 Control
 129      =5  SFR (SMB0CF, 0xC1);                    // SMBus0 Configuration
 130      =5  SFR (SMB0DAT, 0xC2);                   // SMBus0 Data
 131      =5  SFR (ADC0GTL, 0xC3);                   // ADC0 Greater-Than Compare Low
 132      =5  SFR (ADC0GTH, 0xC4);                   // ADC0 Greater-Than Compare High
 133      =5  SFR (ADC0LTL, 0xC5);                   // ADC0 Less-Than Compare Word Low
 134      =5  SFR (ADC0LTH, 0xC6);                   // ADC0 Less-Than Compare Word High
 135      =5  SFR (XBR3, 0xC6);                      // Port I/O Crossbar Control 3
 136      =5  SFR (XBR2, 0xC7);                      // Port I/O Crossbar Control 2
 137      =5  SFR (TMR2CN, 0xC8);                    // Timer/Counter 2 Control
 138      =5  SFR (TMR4CN, 0xC8);                    // Timer/Counter 4 Control
 139      =5  SFR (REG0CN, 0xC9);                    // Regulator Control
 140      =5  SFR (LIN0CF, 0xC9);                    // LIN 0 Configuration
 141      =5  SFR (TMR4CF, 0xC9);                    // Timer/Counter 4 Configuration
 142      =5  SFR (TMR2RLL, 0xCA);                   // Timer/Counter 2 Reload Low
 143      =5  SFR (TMR4CAPL, 0xCA);                  // Timer/Counter 4 Capture Low
 144      =5  SFR (TMR2RLH, 0xCB);                   // Timer/Counter 2 Reload High
 145      =5  SFR (TMR4CAPH, 0xCB);                  // Timer/Counter 4 Capture High
 146      =5  SFR (TMR2L, 0xCC);                     // Timer/Counter 2 Low
 147      =5  SFR (TMR4L, 0xCC);                     // Timer/Counter 4 Low
 148      =5  SFR (TMR2H, 0xCD);                     // Timer/Counter 2 High
 149      =5  SFR (TMR4H, 0xCD);                     // Timer/Counter 4 High
 150      =5  SFR (PCA0CPL5, 0xCE);                  // PCA0 Capture 5 Low
 151      =5  SFR (PCA1CPL11, 0xCE);                 // PCA1 Capture 11 Low
 152      =5  SFR (PCA0CPH5, 0xCF);                  // PCA0 Capture 5 High
 153      =5  SFR (PCA1CPH11, 0xCF);                 // PCA1 Capture 11 High
 154      =5  SFR (PSW, 0xD0);                       // Program Status Word
 155      =5  SFR (REF0CN, 0xD1);                    // Voltage Reference Control
 156      =5  SFR (LIN0DAT, 0xD2);                   // LIN0 Data
 157      =5  SFR (LIN0ADR, 0xD3);                   // LIN0 Address
 158      =5  SFR (P0SKIP, 0xD4);                    // Port 0 Skip
 159      =5  SFR (P1SKIP, 0xD5);                    // Port 1 Skip
 160      =5  SFR (P2SKIP, 0xD6);                    // Port 2 Skip
 161      =5  SFR (P3SKIP, 0xD7);                    // Port 3 Skip
 162      =5  SFR (PCA0CN, 0xD8);                    // PCA0 Control
 163      =5  SFR (PCA1CN, 0xD8);                    // PCA1 Control
 164      =5  SFR (PCA0MD, 0xD9);                    // PCA0 Mode
 165      =5  SFR (PCA1MD, 0xD9);                    // PCA1 Mode
 166      =5  SFR (PCA0PWM, 0xD9);                   // PCA0 PWM Control
 167      =5  SFR (PCA0CPM0, 0xDA);                  // PCA0 Module 0 Mode
 168      =5  SFR (PCA1CPM6, 0xDA);                  // PCA1 Module 6 Mode
 169      =5  SFR (PCA1PWM, 0xDA);                   // PCA1 PWM Control
 170      =5  SFR (PCA0CPM1, 0xDB);                  // PCA0 Module 1  Mode
 171      =5  SFR (PCA1CPM7, 0xDB);                  // PCA1 Module 7  Mode
 172      =5  SFR (PCA0CPM2, 0xDC);                  // PCA0 Module 2  Mode
 173      =5  SFR (PCA1CPM8, 0xDC);                  // PCA1 Module 8  Mode
 174      =5  SFR (PCA0CPM3, 0xDD);                  // PCA0 Module 3  Mode
 175      =5  SFR (PCA1CPM9, 0xDD);                  // PCA1 Module 9  Mode
 176      =5  SFR (PCA0CPM4, 0xDE);                  // PCA0 Module 4  Mode
 177      =5  SFR (PCA1CPM10, 0xDE);                  // PCA1 Module 10 Mode
 178      =5  SFR (PCA0CPM5, 0xDF);                  // PCA0 Module 5  Mode
 179      =5  SFR (PCA1CPM11, 0xDF);                  // PCA1 Module 11 Mode
 180      =5  SFR (ACC, 0xE0);                       // Accumulator
 181      =5  SFR (XBR0, 0xE1);                      // Port I/O Crossbar Control 0
 182      =5  SFR (XBR1, 0xE2);                      // Port I/O Crossbar Control 1
 183      =5  SFR (CCH0CN, 0xE3);                    // Cache control
 184      =5  SFR (IT01CF, 0xE4);                    // INT0/INT1 Configuration
 185      =5  SFR (EIE1, 0xE6);                      // Extended Interrupt Enable 2
 186      =5  SFR (EIE2, 0xE7);                      // Extended Interrupt Enable 2
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 16  

 187      =5  SFR (ADC0CN, 0xE8);                    // ADC0 Control
 188      =5  SFR (PCA0CPL1, 0xE9);                  // PCA0 Capture 1 Low
 189      =5  SFR (PCA1CPL1, 0xE9);                  // PCA1 Capture 7 Low
 190      =5  SFR (PCA0CPH1, 0xEA);                  // PCA0 Capture 1 High
 191      =5  SFR (PCA1CPH1, 0xEA);                  // PCA1 Capture 7 High
 192      =5  SFR (PCA0CPL2, 0xEB);                  // PCA0 Capture 2 Low
 193      =5  SFR (PCA1CPL2, 0xEB);                  // PCA1 Capture 8 Low
 194      =5  SFR (PCA0CPH2, 0xEC);                  // PCA0 Capture 2 High
 195      =5  SFR (PCA1CPH2, 0xEC);                  // PCA1 Capture 8 High
 196      =5  SFR (PCA0CPL3, 0xED);                  // PCA0 Capture 3 Low
 197      =5  SFR (PCA1CPL3, 0xED);                  // PCA1 Capture 9 Low
 198      =5  SFR (PCA0CPH3, 0xEE);                  // PCA0 Capture 3 High
 199      =5  SFR (PCA1CPH3, 0xEE);                  // PCA1 Capture 9 High
 200      =5  SFR (RSTSRC, 0xEF);                    // Reset Source Configuration/Status
 201      =5  SFR (B, 0xF0);                         // B Register
 202      =5  SFR (P0MAT, 0xF1);                     // Port 0 Match
 203      =5  SFR (P0MDIN, 0xF1);                    // Port 0 Input Mode
 204      =5  SFR (P0MASK, 0xF2);                    // Port 0 Mask
 205      =5  SFR (P1MDIN, 0xF2);                    // Port 1 Input Mode
 206      =5  SFR (P1MAT, 0xF3);                     // Port 1 Match
 207      =5  SFR (P2MDIN, 0xF3);                    // Port 2 Input Mode
 208      =5  SFR (P1MASK, 0xF4);                    // Port 1 Mask
 209      =5  SFR (P3MDIN, 0xF4);                    // Port 3 Input Mode
 210      =5  SFR (PSBANK, 0xF5);                    // Program Space Bank Select
 211      =5  SFR (EIP1, 0xF6);                      // External Interrupt Priority 1
 212      =5  SFR (EIP2, 0xF7);                      // External Interrupt Priority 2
 213      =5  SFR (SPI0CN, 0xF8);                    // SPI0 Control
 214      =5  SFR (PCA0L, 0xF9);                     // PCA0 Counter Low
 215      =5  SFR (PCA1L, 0xF9);                     // PCA1 Counter Low
 216      =5  SFR (SN0, 0xF9);                       // Serial Number 0
 217      =5  SFR (PCA0H, 0xFA);                     // PCA0 Counter High
 218      =5  SFR (PCA1H, 0xFA);                     // PCA1 Counter High
 219      =5  SFR (SN1, 0xFA);                       // Serial Number 1
 220      =5  SFR (PCA0CPL0, 0xFB);                  // PCA0 Capture 0 Low
 221      =5  SFR (PCA1CPL6, 0xFB);                  // PCA1 Capture 6 Low
 222      =5  SFR (SN2, 0xFB);                       // Serial Number 2
 223      =5  SFR (PCA0CPH0, 0xFC);                  // PCA0 Capture 0 High
 224      =5  SFR (PCA1CPH6, 0xFC);                  // PCA1 Capture 6 High
 225      =5  SFR (SN3, 0xFC);                       // Serial Number 3
 226      =5  SFR (PCA0CPL4, 0xFD);                  // PCA0 Capture 4 Low
 227      =5  SFR (PCA1CPL10, 0xFD);                 // PCA1 Capture 10 Low
 228      =5  SFR (PCA0CPH4, 0xFE);                  // PCA0 Capture 4 High
 229      =5  SFR (PCA1CPH10, 0xFE);                 // PCA1 Capture 10 High
 230      =5  SFR (VDM0CN, 0xFF);                    // VDD Monitor Control
 231      =5  
 232      =5  //-----------------------------------------------------------------------------
 233      =5  // Page C (CAN0) Registers
 234      =5  //-----------------------------------------------------------------------------
 235      =5  
 236      =5  SFR (CAN0CFG, 0x92);                   // CAN0 Clock Configuration
 237      =5  SFR (CAN0STAT, 0x94);                  // Status Register Low Byte
 238      =5  SFR (CAN0ERRL, 0x96);                  // Error Counter Low Byte
 239      =5  SFR (CAN0ERRH, 0x97);                  // Error Counter High Byte
 240      =5  SFR (CAN0BTL, 0x9A);                   // Bit Timing Register Low Byte
 241      =5  SFR (CAN0BTH, 0x9B);                   // Bit Timing Register High Byte
 242      =5  SFR (CAN0IIDL, 0x9C);                  // Interrupt Register Low Byte
 243      =5  SFR (CAN0IIDH, 0x9D);                  // Interrupt Register High Byte
 244      =5  SFR (CAN0TST, 0x9E);                   // Test Register Low Byte
 245      =5  SFR (CAN0BRPE, 0xA1);                  // BRP Extension Register Low Byte
 246      =5  SFR (CAN0TR1L, 0xA2);                  // Transmission Request 1 Low Byte
 247      =5  SFR (CAN0TR1H, 0xA3);                  // Transmission Request 1 High Byte
 248      =5  SFR (CAN0TR2L, 0xA4);                  // Transmission Request 2 Low Byte
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 17  

 249      =5  SFR (CAN0TR2H, 0xA5);                  // Transmission Request 2 High Byte
 250      =5  SFR (CAN0ND1L, 0xAA);                  // New Data 1 Low Byte
 251      =5  SFR (CAN0ND1H, 0xAB);                  // New Data 1 High Byte
 252      =5  SFR (CAN0ND2L, 0xAC);                  // New Data 2 Low Byte
 253      =5  SFR (CAN0ND2H, 0xAD);                  // New Data 2 High Byte
 254      =5  SFR (CAN0IP1L, 0xAE);                  // Interrupt Pending 1 Low Byte
 255      =5  SFR (CAN0IP1H, 0xAF);                  // Interrupt Pending 1 High Byte
 256      =5  SFR (CAN0IP2L, 0xB2);                  // Interrupt Pending 2 Low Byte
 257      =5  SFR (CAN0IP2H, 0xB3);                  // Interrupt Pending 2 High Byte
 258      =5  SFR (CAN0MV1L, 0xBA);                  // Message Valid 1 Low Byte
 259      =5  SFR (CAN0MV1H, 0xBB);                  // Message Valid 1 High Byte
 260      =5  SFR (CAN0MV2L, 0xBC);                  // Message Valid 2 Low Byte
 261      =5  SFR (CAN0MV2H, 0xBD);                  // Message Valid 2 High Byte
 262      =5  SFR (CAN0IF1CRL, 0xBE);                // IF1 Command Request Low Byte
 263      =5  SFR (CAN0IF1CRH, 0xBF);                // IF1 Command Request High Byte
 264      =5  SFR (CAN0CN, 0xC0);                    // CAN Control Register Low Byte
 265      =5  SFR (CAN0IF1CML, 0xC2);                // IF1 Command Mask Low Byte
 266      =5  SFR (CAN0IF1CMH, 0xC3);                // IF1 Command Mask High Byte
 267      =5  SFR (CAN0IF1M1L, 0xC4);                // IF1 Mask 1 Low Byte
 268      =5  SFR (CAN0IF1M1H, 0xC5);                // IF1 Mask 1 High Byte
 269      =5  SFR (CAN0IF1M2L, 0xC6);                // IF1 Mask 2 Low Byte
 270      =5  SFR (CAN0IF1M2H, 0xC7);                // IF1 Mask 2 High Byte
 271      =5  SFR (CAN0IF1A1L, 0xCA);                // IF1 Arbitration 1 Low Byte
 272      =5  SFR (CAN0IF1A1H, 0xCB);                // IF1 Arbitration 1 High Byte
 273      =5  SFR (CAN0IF1A2L, 0xCC);                // IF1 Arbitration 2 Low Byte
 274      =5  SFR (CAN0IF1A2H, 0xCD);                // IF1 Arbitration 2 High Byte
 275      =5  SFR (CAN0IF2MCL, 0xCE);                // IF2 Message Control Low Byte
 276      =5  SFR (CAN0IF2MCH, 0xCF);                // IF2 Message Control High Byte
 277      =5  SFR (CAN0IF1MCL, 0xD2);                // IF1 Message Control Low Byte
 278      =5  SFR (CAN0IF1MCH, 0xD3);                // IF1 Message Control High Byte
 279      =5  SFR (CAN0IF1DA1L, 0xD4);               // IF1 Data A 1 Low Byte
 280      =5  SFR (CAN0IF1DA1H, 0xD5);               // IF1 Data A 1 High Byte
 281      =5  SFR (CAN0IF1DA2L, 0xD6);               // IF1 Data A 2 Low Byte
 282      =5  SFR (CAN0IF1DA2H, 0xD7);               // IF1 Data A 2 High Byte
 283      =5  SFR (CAN0IF1DB1L, 0xDA);               // IF1 Data B 1 Low Byte
 284      =5  SFR (CAN0IF1DB1H, 0xDB);               // IF1 Data B 1 High Byte
 285      =5  SFR (CAN0IF1DB2L, 0xDC);               // IF1 Data B 2 Low Byte
 286      =5  SFR (CAN0IF1DB2H, 0xDD);               // IF1 Data B 2 High Byte
 287      =5  SFR (CAN0IF2CRL, 0xDE);                // IF2 Command Request Low Byte
 288      =5  SFR (CAN0IF2CRH, 0xDF);                // IF2 Command Request High Byte
 289      =5  SFR (CAN0IF2CML, 0xE2);                // IF2 Command Mask Low Byte
 290      =5  SFR (CAN0IF2CMH, 0xE3);                // IF2 Command Mask High Byte
 291      =5  SFR (CAN0IF2M1L, 0xEA);                // IF2 Mask 1 Low Byte
 292      =5  SFR (CAN0IF2M1H, 0xEB);                // IF2 Mask 1 High Byte
 293      =5  SFR (CAN0IF2M2L, 0xEC);                // IF2 Mask 2 Low Byte
 294      =5  SFR (CAN0IF2M2H, 0xED);                // IF2 Mask 2 High Byte
 295      =5  SFR (CAN0IF2A1L, 0xEE);                // IF2 Arbitration 1 Low Byte
 296      =5  SFR (CAN0IF2A1H, 0xEF);                // IF2 Arbitration 1 High Byte
 297      =5  SFR (CAN0IF2A2L, 0xF2);                // IF2 Arbitration 2 Low Byte
 298      =5  SFR (CAN0IF2A2H, 0xF3);                // IF2 Arbitration 2 High Byte
 299      =5  SFR (CAN0IF2DA1L, 0xF6);               // IF2 Data A 1 Low Byte
 300      =5  SFR (CAN0IF2DA1H, 0xF7);               // IF2 Data A 1 High Byte
 301      =5  SFR (CAN0IF2DA2L, 0xFA);               // IF2 Data A 2 Low Byte
 302      =5  SFR (CAN0IF2DA2H, 0xFB);               // IF2 Data A 2 High Byte
 303      =5  SFR (CAN0IF2DB1L, 0xFC);               // IF2 Data B 1 Low Byte
 304      =5  SFR (CAN0IF2DB1H, 0xFD);               // IF2 Data B 1 High Byte
 305      =5  SFR (CAN0IF2DB2L, 0xFE);               // IF2 Data B 2 Low Byte
 306      =5  SFR (CAN0IF2DB2H, 0xFF);               // IF2 Data B 2 High Byte
 307      =5  
 308      =5  
 309      =5  //-----------------------------------------------------------------------------
 310      =5  // 16-bit Register Definitions (might not be supported by all compilers)
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 18  

 311      =5  //-----------------------------------------------------------------------------
 312      =5  
 313      =5  SFR16 (DP, 0x82);                      // Data Pointer
 314      =5  SFR16 (TMR3RL, 0x92);                  // Timer 3 Reload
 315      =5  SFR16 (TMR5CAP, 0x92);                 // Timer 5 Capture
 316      =5  SFR16 (TMR3, 0x94);                    // Timer 3 Capture / Reload
 317      =5  SFR16 (TMR5, 0x94);                    // Timer 5
 318      =5  SFR16 (SBRL0, 0xAC);                   // UART0 Reload
 319      =5  SFR16 (ADC0, 0xBD);                    // ADC0 data
 320      =5  SFR16 (ADC0GT, 0xC3);                  // ADC0 Greater Than Window
 321      =5  SFR16 (ADC0LT, 0xC5);                  // ADC0 Less Than Window
 322      =5  SFR16 (TMR2RL, 0xCA);                  // Timer 2 Reload
 323      =5  SFR16 (TMR4CAP, 0xCA);                 // Timer 4 Capture
 324      =5  SFR16 (TMR2, 0xCC);                    // Timer 2 Capture / Reload
 325      =5  SFR16 (TMR4, 0xCC);                    // Timer 4
 326      =5  SFR16 (PCA0CP5, 0xCE);                 // PCA0 Module 5 Capture
 327      =5  SFR16 (PCA1CP11, 0xCE);                // PCA1 Module 11 Capture
 328      =5  SFR16 (PCA0CP1, 0xE9);                 // PCA0 Module 1 Capture
 329      =5  SFR16 (PCA1CP7, 0xE9);                 // PCA1 Module 7 Capture
 330      =5  SFR16 (PCA0CP2, 0xEB);                 // PCA0 Module 2 Capture
 331      =5  SFR16 (PCA1CP8, 0xEB);                 // PCA1 Module 8 Capture
 332      =5  SFR16 (PCA0CP3, 0xED);                 // PCA0 Module 3 Capture
 333      =5  SFR16 (PCA1CP9, 0xED);                 // PCA1 Module 9 Capture
 334      =5  SFR16 (PCA0, 0xF9);                    // PCA0 Counter
 335      =5  SFR16 (PCA1, 0xF9);                    // PCA1 Counter
 336      =5  SFR16 (PCA0CP0, 0xFB);                 // PCA0 Module 0 Capture
 337      =5  SFR16 (PCA1CP6, 0xFB);                 // PCA1 Module 6 Capture
 338      =5  SFR16 (PCA0CP4, 0xFD);                 // PCA0 Module 4 Capture
 339      =5  SFR16 (PCA1CP10, 0xFD);                 // PCA1 Module 10 Capture
 340      =5  
 341      =5  SFR16 (CAN0ERR, 0x96);                 // Error Counter
 342      =5  SFR16 (CAN0BT, 0x9A);                  // Bit Timing Register
 343      =5  SFR16 (CAN0IID, 0x9C);                 // Interrupt Register
 344      =5  SFR16 (CAN0TR1, 0xA2);                 // Transmission Request 1
 345      =5  SFR16 (CAN0TR2, 0xA4);                 // Transmission Request 2
 346      =5  SFR16 (CAN0ND1, 0xAA);                 // New Data 1
 347      =5  SFR16 (CAN0ND2, 0xAC);                 // New Data 2
 348      =5  SFR16 (CAN0IP1, 0xAE);                 // Interrupt Pending 1
 349      =5  SFR16 (CAN0IP2, 0xB2);                 // Interrupt Pending 2
 350      =5  SFR16 (CAN0MV1, 0xBA);                 // Message Valid 1
 351      =5  SFR16 (CAN0MV2, 0xBC);                 // Message Valid 2
 352      =5  SFR16 (CAN0IF1CR, 0xBE);               // IF1 Command Request
 353      =5  SFR16 (CAN0IF1CM, 0xC2);               // IF1 Command Mask
 354      =5  SFR16 (CAN0IF1M1, 0xC4);               // IF1 Mask 1
 355      =5  SFR16 (CAN0IF1M2, 0xC6);               // IF1 Mask 2
 356      =5  SFR16 (CAN0IF1A1, 0xCA);               // IF1 Arbitration 1
 357      =5  SFR16 (CAN0IF1A2, 0xCC);               // IF1 Arbitration 2
 358      =5  SFR16 (CAN0IF1MC, 0xD2);               // IF1 Message Control
 359      =5  SFR16 (CAN0IF1DA1, 0xD4);              // IF1 Data A 1
 360      =5  SFR16 (CAN0IF1DA2, 0xD6);              // IF1 Data A 2
 361      =5  SFR16 (CAN0IF1DB1, 0xDA);              // IF1 Data B 1
 362      =5  SFR16 (CAN0IF1DB2, 0xDC);              // IF1 Data B 2
 363      =5  SFR16 (CAN0IF2CR, 0xDE);               // IF2 Command Request
 364      =5  SFR16 (CAN0IF2CM, 0xE2);               // IF2 Command Mask
 365      =5  SFR16 (CAN0IF2M1, 0xEA);               // IF2 Mask 1
 366      =5  SFR16 (CAN0IF2M2, 0xEC);               // IF2 Mask 2
 367      =5  SFR16 (CAN0IF2A1, 0xEE);               // IF2 Arbitration 1
 368      =5  SFR16 (CAN0IF2A2, 0xF2);               // IF2 Arbitration 2
 369      =5  SFR16 (CAN0IF2MC, 0xCE);               // IF2 Message Control
 370      =5  SFR16 (CAN0IF2DA1, 0xF6);              // IF2 Data A 1
 371      =5  SFR16 (CAN0IF2DA2, 0xFA);              // IF2 Data A 2
 372      =5  SFR16 (CAN0IF2DB1, 0xFC);              // IF2 Data B 1
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 19  

 373      =5  SFR16 (CAN0IF2DB2, 0xFE);              // IF2 Data B 2
 374      =5  
 375      =5  //-----------------------------------------------------------------------------
 376      =5  // LIN0 Indirect Registers
 377      =5  //-----------------------------------------------------------------------------
 378      =5  
 379      =5  #define  LIN0DT1   0x00                // LIN0 Data Byte 1
 380      =5  #define  LIN0DT2   0x01                // LIN0 Data Byte 2
 381      =5  #define  LIN0DT3   0x02                // LIN0 Data Byte 3
 382      =5  #define  LIN0DT4   0x03                // LIN0 Data Byte 4
 383      =5  #define  LIN0DT5   0x04                // LIN0 Data Byte 5
 384      =5  #define  LIN0DT6   0x05                // LIN0 Data Byte 6
 385      =5  #define  LIN0DT7   0x06                // LIN0 Data Byte 7
 386      =5  #define  LIN0DT8   0x07                // LIN0 Data Byte 8
 387      =5  #define  LIN0CTRL  0x08                // LIN0 Control
 388      =5  #define  LIN0ST    0x09                // LIN0 Status
 389      =5  #define  LIN0ERR   0x0A                // LIN0 Error
 390      =5  #define  LIN0SIZE  0x0B                // LIN0 Message Size
 391      =5  #define  LIN0DIV   0x0C                // LIN0 Divider
 392      =5  #define  LIN0MUL   0x0D                // LIN0 Multiplier
 393      =5  #define  LIN0ID    0x0E                // LIN0 Identifier
 394      =5  
 395      =5  //-----------------------------------------------------------------------------
 396      =5  // Address Definitions for Bit-addressable Registers
 397      =5  //-----------------------------------------------------------------------------
 398      =5  
 399      =5  #define SFR_P0       0x80
 400      =5  #define SFR_TCON     0x88
 401      =5  #define SFR_P1       0x90
 402      =5  #define SFR_SCON0    0x98
 403      =5  #define SFR_SCON1    0x98
 404      =5  #define SFR_P2       0xA0
 405      =5  #define SFR_IE       0xA8
 406      =5  #define SFR_P3       0xB0
 407      =5  #define SFR_IP       0xB8
 408      =5  #define SFR_SMB0CN   0xC0
 409      =5  #define SFR_TMR2CN   0xC8
 410      =5  #define SFR_TMR4CN   0xC8
 411      =5  #define SFR_PSW      0xD0
 412      =5  #define SFR_PCA0CN   0xD8
 413      =5  #define SFR_PCA1CN   0xD8
 414      =5  #define SFR_ACC      0xE0
 415      =5  #define SFR_ADC0CN   0xE8
 416      =5  #define SFR_B        0xF0
 417      =5  #define SFR_SPI0CN   0xF8
 418      =5  
 419      =5  //-----------------------------------------------------------------------------
 420      =5  // Bit Definitions
 421      =5  //-----------------------------------------------------------------------------
 422      =5  
 423      =5  // TCON 0x88
 424      =5  SBIT (TF1, SFR_TCON, 7);               // Timer 1 Overflow Flag
 425      =5  SBIT (TR1, SFR_TCON, 6);               // Timer 1 On/Off Control
 426      =5  SBIT (TF0, SFR_TCON, 5);               // Timer 0 Overflow Flag
 427      =5  SBIT (TR0, SFR_TCON, 4);               // Timer 0 On/Off Control
 428      =5  SBIT (IE1, SFR_TCON, 3);               // Ext. Interrupt 1 Edge Flag
 429      =5  SBIT (IT1, SFR_TCON, 2);               // Ext. Interrupt 1 Type
 430      =5  SBIT (IE0, SFR_TCON, 1);               // Ext. Interrupt 0 Edge Flag
 431      =5  SBIT (IT0, SFR_TCON, 0);               // Ext. Interrupt 0 Type
 432      =5  
 433      =5  // SCON0 0x98
 434      =5  SBIT (OVR0, SFR_SCON0, 7);             // UART0 Receive FIFO Overrun Flag
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 20  

 435      =5  SBIT (PERR0, SFR_SCON0, 6);            // UART0 Parity Error Flag
 436      =5  SBIT (THRE0, SFR_SCON0, 5);            // UART0 Transmit Register Empty Flag
 437      =5  SBIT (REN0, SFR_SCON0, 4);             // UART0 RX Enable
 438      =5  SBIT (TBX0, SFR_SCON0, 3);             // UART0 Extra Transmission Bit
 439      =5  SBIT (RBX0, SFR_SCON0, 2);             // UART0 Extra Receive Bit
 440      =5  SBIT (TI0, SFR_SCON0, 1);              // UART0 TX Interrupt Flag
 441      =5  SBIT (RI0, SFR_SCON0, 0);              // UART0 RX Interrupt Flag
 442      =5  
 443      =5  // SCON1 0x98
 444      =5  SBIT (S1MODE, SFR_SCON1, 7);           // UART1 Mode 0
 445      =5                                         // Bit 6 UNUSED
 446      =5  SBIT (MCE1, SFR_SCON1, 5);             // UART1 Multiprocessor enable
 447      =5  SBIT (REN1, SFR_SCON1, 4);             // UART1 RX Enable
 448      =5  SBIT (TB81, SFR_SCON1, 3);             // UART1 TX Bit 8
 449      =5  SBIT (RB81, SFR_SCON1, 2);             // UART1 RX Bit 8
 450      =5  SBIT (TI1, SFR_SCON1, 1);              // UART1 TX Interrupt Flag
 451      =5  SBIT (RI1, SFR_SCON1, 0);              // UART1 RX Interrupt Flag
 452      =5  
 453      =5  // IE 0xA8
 454      =5  SBIT (EA, SFR_IE, 7);                  // Global Interrupt Enable
 455      =5  SBIT (ESPI0, SFR_IE, 6);               // SPI0 Interrupt Enable
 456      =5  SBIT (ET2, SFR_IE, 5);                 // Timer 2 Interrupt Enable
 457      =5  SBIT (ES0, SFR_IE, 4);                 // UART0 Interrupt Enable
 458      =5  SBIT (ET1, SFR_IE, 3);                 // Timer 1 Interrupt Enable
 459      =5  SBIT (EX1, SFR_IE, 2);                 // External Interrupt 1 Enable
 460      =5  SBIT (ET0, SFR_IE, 1);                 // Timer 0 Interrupt Enable
 461      =5  SBIT (EX0, SFR_IE, 0);                 // External Interrupt 0 Enable
 462      =5  
 463      =5  // IP 0xB8
 464      =5                                         // Bit 7 unused
 465      =5  SBIT (PSPI0, SFR_IP, 6);               // SPI0 Interrupt Priority
 466      =5  SBIT (PT2, SFR_IP, 5);                 // Timer 2 Priority
 467      =5  SBIT (PS0, SFR_IP, 4);                 // UART0 Priority
 468      =5  SBIT (PS, SFR_IP, 4);                  // UART0 Priority
 469      =5  SBIT (PT1, SFR_IP, 3);                 // Timer 1 Priority
 470      =5  SBIT (PX1, SFR_IP, 2);                 // External Interrupt 1 Priority
 471      =5  SBIT (PT0, SFR_IP, 1);                 // Timer 0 Priority
 472      =5  SBIT (PX0, SFR_IP, 0);                 // External Interrupt 0 Priority
 473      =5  
 474      =5  // SMB0CN 0xC0
 475      =5  SBIT (MASTER, SFR_SMB0CN, 7);          // SMBus0 Master/Slave Indicator
 476      =5  SBIT (TXMODE, SFR_SMB0CN, 6);          // SMBus0 Transmit Mode Indicator
 477      =5  SBIT (STA, SFR_SMB0CN, 5);             // SMBus0 Start Flag
 478      =5  SBIT (STO, SFR_SMB0CN, 4);             // SMBus0 Stop Flag
 479      =5  SBIT (ACKRQ, SFR_SMB0CN, 3);           // SMBus0 Acknowledge Request
 480      =5  SBIT (ARBLOST, SFR_SMB0CN, 2);         // SMBus0 Arbitration Lost Indicator
 481      =5  SBIT (ACK, SFR_SMB0CN, 1);             // SMBus0 Acknowledge
 482      =5  SBIT (SI, SFR_SMB0CN, 0);              // SMBus0 Interrupt Flag
 483      =5  
 484      =5  // TMR2CN 0xC8
 485      =5  SBIT (TF2H, SFR_TMR2CN, 7);            // Timer 2 High-Byte Overflow Flag
 486      =5  SBIT (TF2L, SFR_TMR2CN, 6);            // Timer 2 Low-Byte  Overflow Flag
 487      =5  SBIT (TF2LEN, SFR_TMR2CN, 5);          // Timer 2 Low-Byte Flag Enable
 488      =5  SBIT (TF2CEN, SFR_TMR2CN, 4);          // Timer 2 Capture Enable
 489      =5  SBIT (T2SPLIT, SFR_TMR2CN, 3);         // Timer 2 Split-Mode Enable
 490      =5  SBIT (TR2, SFR_TMR2CN, 2);             // Timer 2 Run Enable
 491      =5  SBIT (T2RCLK, SFR_TMR2CN, 1);          // Timer 2 Xclk/Rclk Select
 492      =5  SBIT (T2XCLK, SFR_TMR2CN, 0);          // Timer 2 Clk/8 Clock Source
 493      =5  
 494      =5  // TMR4CN 0xC8
 495      =5  SBIT (TF4, SFR_TMR4CN, 7);             // Timer 4 Overflow/Underflow Flag
 496      =5  SBIT (EXF4, SFR_TMR4CN, 6);            // Timer 4 External Flag
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 21  

 497      =5                                         // Bit 5 unused
 498      =5                                         // Bit 4 unused
 499      =5  SBIT (EXE4, SFR_TMR4CN, 3);            // Timer 4 External Enable
 500      =5  SBIT (TR4, SFR_TMR4CN, 2);             // Timer 4 Run Enable
 501      =5  SBIT (CT4, SFR_TMR4CN, 1);             // Timer 4 Counter/Timer Select
 502      =5  SBIT (CPRL4, SFR_TMR4CN, 0);           // Timer 4 Capture/Reload Select
 503      =5  
 504      =5  // PSW 0xD0
 505      =5  SBIT (CY, SFR_PSW, 7);                 // Carry Flag
 506      =5  SBIT (AC, SFR_PSW, 6);                 // Auxiliary Carry Flag
 507      =5  SBIT (F0, SFR_PSW, 5);                 // User Flag 0
 508      =5  SBIT (RS1, SFR_PSW, 4);                // Register Bank Select 1
 509      =5  SBIT (RS0, SFR_PSW, 3);                // Register Bank Select 0
 510      =5  SBIT (OV, SFR_PSW, 2);                 // Overflow Flag
 511      =5  SBIT (F1, SFR_PSW, 1);                 // User Flag 1
 512      =5  SBIT (P, SFR_PSW, 0);                  // Accumulator Parity Flag
 513      =5  
 514      =5  // PCA0CN 0xD8
 515      =5  SBIT (CF, SFR_PCA0CN, 7);              // PCA0 Counter Overflow Flag
 516      =5  SBIT (CR, SFR_PCA0CN, 6);              // PCA0 Counter Run Control Bit
 517      =5  SBIT (CCF5, SFR_PCA0CN, 5);            // PCA0 Module 5 Interrupt Flag
 518      =5  SBIT (CCF4, SFR_PCA0CN, 4);            // PCA0 Module 4 Interrupt Flag
 519      =5  SBIT (CCF3, SFR_PCA0CN, 3);            // PCA0 Module 3 Interrupt Flag
 520      =5  SBIT (CCF2, SFR_PCA0CN, 2);            // PCA0 Module 2 Interrupt Flag
 521      =5  SBIT (CCF1, SFR_PCA0CN, 1);            // PCA0 Module 1 Interrupt Flag
 522      =5  SBIT (CCF0, SFR_PCA0CN, 0);            // PCA0 Module 0 Interrupt Flag
 523      =5  
 524      =5  // PCA1CN 0xD8
 525      =5  SBIT (CF1, SFR_PCA1CN, 7);             // PCA1 Counter Overflow Flag
 526      =5  SBIT (CR1, SFR_PCA1CN, 6);             // PCA1 Counter Run Control Bit
 527      =5  SBIT (CCF11, SFR_PCA1CN, 5);           // PCA1 Module 11 Interrupt Flag
 528      =5  SBIT (CCF10, SFR_PCA1CN, 4);           // PCA1 Module 10 Interrupt Flag
 529      =5  SBIT (CCF9, SFR_PCA1CN, 3);            // PCA1 Module 9 Interrupt Flag
 530      =5  SBIT (CCF8, SFR_PCA1CN, 2);            // PCA1 Module 8 Interrupt Flag
 531      =5  SBIT (CCF7, SFR_PCA1CN, 1);            // PCA1 Module 7 Interrupt Flag
 532      =5  SBIT (CCF6, SFR_PCA1CN, 0);            // PCA1 Module 6 Interrupt Flag
 533      =5  
 534      =5  // ADC0CN 0xE8
 535      =5  SBIT (AD0EN, SFR_ADC0CN, 7);           // ADC0 Enable
 536      =5  SBIT (BURSTEN, SFR_ADC0CN, 6);         // ADC0 Burst Enable
 537      =5  SBIT (AD0INT, SFR_ADC0CN, 5);          // ADC0 EOC Interrupt Flag
 538      =5  SBIT (AD0BUSY, SFR_ADC0CN, 4);         // ADC0 Busy Flag
 539      =5  SBIT (AD0WINT, SFR_ADC0CN, 3);         // ADC0 Window Compare Interrupt Flag
 540      =5  SBIT (AD0LJST, SFR_ADC0CN, 2);         // ADC0 Left Justified
 541      =5  SBIT (AD0CM1, SFR_ADC0CN, 1);          // ADC0 Start Of Conversion Mode Bit 1
 542      =5  SBIT (AD0CM0, SFR_ADC0CN, 0);          // ADC0 Start Of Conversion Mode Bit 0
 543      =5  
 544      =5  // SPI0CN 0xF8
 545      =5  SBIT (SPIF, SFR_SPI0CN, 7);            // SPI0 Interrupt Flag
 546      =5  SBIT (WCOL, SFR_SPI0CN, 6);            // SPI0 Write Collision Flag
 547      =5  SBIT (MODF, SFR_SPI0CN, 5);            // SPI0 Mode Fault Flag
 548      =5  SBIT (RXOVRN, SFR_SPI0CN, 4);          // SPI0 RX Overrun Flag
 549      =5  SBIT (NSSMD1, SFR_SPI0CN, 3);          // SPI0 Slave Select Mode 1
 550      =5  SBIT (NSSMD0, SFR_SPI0CN, 2);          // SPI0 Slave Select Mode 0
 551      =5  SBIT (TXBMT, SFR_SPI0CN, 1);           // SPI0 TX Buffer Empty Flag
 552      =5  SBIT (SPIEN, SFR_SPI0CN, 0);           // SPI0 Enable
 553      =5  
 554      =5  //-----------------------------------------------------------------------------
 555      =5  // Interrupt Priorities
 556      =5  //-----------------------------------------------------------------------------
 557      =5  
 558      =5  #define INTERRUPT_INT0             0   // External Interrupt 0
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 22  

 559      =5  #define INTERRUPT_TIMER0           1   // Timer 0 Overflow
 560      =5  #define INTERRUPT_INT1             2   // External Interrupt 1
 561      =5  #define INTERRUPT_TIMER1           3   // Timer 1 Overflow
 562      =5  #define INTERRUPT_UART0            4   // UART0
 563      =5  #define INTERRUPT_TIMER2           5   // Timer 2 Overflow
 564      =5  #define INTERRUPT_SPI0             6   // SPI0
 565      =5  #define INTERRUPT_SMBUS0           7   // SMBus0 Interface
 566      =5  #define INTERRUPT_ADC0_WINDOW      8   // ADC0 Window Comparison
 567      =5  #define INTERRUPT_ADC0_EOC         9   // ADC0 End Of Conversion
 568      =5  #define INTERRUPT_PCA0            10   // PCA0 Peripheral
 569      =5  #define INTERRUPT_COMPARATOR0     11   // Comparator 0 Comparison
 570      =5  #define INTERRUPT_COMPARATOR1     12   // Comparator 1 Comparison
 571      =5  #define INTERRUPT_TIMER3          13   // Timer 3 Overflow
 572      =5  #define INTERRUPT_LIN0            14   // LIN Bus Interrupt
 573      =5  #define INTERRUPT_VREG            15   // Voltage Regulator
 574      =5  #define INTERRUPT_CAN0            16   // CAN Bus Interrupt
 575      =5  #define INTERRUPT_PORT_MATCH      17   // Port Match
 576      =5  #define INTERRUPT_UART1           18   // UART1
 577      =5  #define INTERRUPT_PCA1            19   // PCA1 Peripheral
 578      =5  #define INTERRUPT_COMPARATOR2     20   // Comparator 2 Comparison
 579      =5  #define INTERRUPT_TIMER4          21   // Timer 4 Overflow
 580      =5  #define INTERRUPT_TIMER5          22   // Timer 5 Overflow
 581      =5  
 582      =5  
 583      =5  //-----------------------------------------------------------------------------
 584      =5  // SFR Page Definitions
 585      =5  //-----------------------------------------------------------------------------
 586      =5  
 587      =5  #define  CONFIG_PAGE       0x0F        // System and Port Configuration Page
 588      =5  #define  ACTIVE_PAGE       0x00        // Active Use Page
 589      =5  #define  ACTIVE2_PAGE      0x10        // Active Use Page 2
 590      =5  #define  CAN0_PAGE         0x0C        // CAN0 Registers
 591      =5  
 592      =5  //-----------------------------------------------------------------------------
 593      =5  // SDCC PDATA External Memory Paging Support
 594      =5  //-----------------------------------------------------------------------------
 595      =5  
 596      =5  #if defined SDCC
           =5 
           =5 SFR(_XPAGE, 0xAA); // Point to the EMI0CN register
           =5 
           =5 #endif
 601      =5  
 602      =5  //-----------------------------------------------------------------------------
 603      =5  // Header File PreProcessor Directive
 604      =5  //-----------------------------------------------------------------------------
 605      =5  
 606      =5  #endif                                 // #define C8051F580_DEFS_H
 607      =5  
 608      =5  //-----------------------------------------------------------------------------
 609      =5  // End Of File
 610      =5  //-----------------------------------------------------------------------------
   9      =4  
  10      =4  #define SET 1U
  11      =4  #define RESET 0U
  12      =4  
  13      =4  #define PRESS 0U
  14      =4  #define RELEASE 1U
  15      =4  
  16      =4  SBIT(LED_G, SFR_P2, 1);
  17      =4  SBIT(LED_Y, SFR_P2, 0);
  18      =4  SBIT(SW2, SFR_P1, 2);
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 23  

  19      =4  typedef enum
  20      =4  {
  21      =4      LED_GREEN,
  22      =4      LED_YELLOW
  23      =4  } Led_e;
  24      =4  
  25      =4  void PORT_Init(void);
  26      =4  void Tonggle(Led_e led);
  27      =4  U8 Get_Button_state(void);
  28      =4  void External_Interrupt_Init(void);
  29      =4  void Ext0_Set_Callback_Ptr(void (*funct)(void));
  30      =4  #endif
   8      =3  #include "GPT.h"
   1      =4  /*
   2      =4   *  Created on: Apr 21, 2025
   3      =4   *      Author: Hoangtd2000
   4      =4   */
   5      =4  #ifndef _GPT_H_
   6      =4  #define _GPT_H_
   7      =4  #include <compiler_defs.h>
   1      =5  //-----------------------------------------------------------------------------
   2      =5  // compiler_defs.h
   3      =5  //-----------------------------------------------------------------------------
   4      =5  // Portions of this file are copyright Maarten Brock
   5      =5  // http://sdcc.sourceforge.net
   6      =5  // Portions of this file are copyright 2010, Silicon Laboratories, Inc.
   7      =5  // http://www.silabs.com
   8      =5  //
   9      =5  // GNU LGPL boilerplate:
  10      =5  /** This library is free software; you can redistribute it and/or
  11      =5    * modify it under the terms of the GNU Lesser General Public
  12      =5    * License as published by the Free Software Foundation; either
  13      =5    * version 2.1 of the License, or (at your option) any later version.
  14      =5    *
  15      =5    * This library is distributed in the hope that it will be useful,
  16      =5    * but WITHOUT ANY WARRANTY; without even the implied warranty of
  17      =5    * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  18      =5    * Lesser General Public License for more details.
  19      =5    *
  20      =5    * You should have received a copy of the GNU Lesser General Public
  21      =5    * License along with this library; if not, write to the Free Software
  22      =5    * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  23      =5    *
  24      =5    * In other words, you are welcome to use, share and improve this program.
  25      =5    * You are forbidden to forbid anyone else to use, share and improve
  26      =5    * what you give them. Help stamp out software-hoarding!
  27      =5  **/
  28      =5  // Program Description:
  29      =5  //
  30      =5  // **Important Note**: This header file should be included before including
  31      =5  // a device-specific header file such as C8051F300_defs.h.
  32      =5  //
  33      =5  // Macro definitions to accomodate 8051 compiler differences in specifying
  34      =5  // special function registers and other 8051-specific features such as NOP
  35      =5  // generation, and locating variables in memory-specific segments.  The
  36      =5  // compilers are identified by their unique predefined macros. See also:
  37      =5  // http://predef.sourceforge.net/precomp.html
  38      =5  //
  39      =5  // SBIT and SFR define special bit and special function registers at the given
  40      =5  // address. SFR16 and SFR32 define sfr combinations at adjacent addresses in
  41      =5  // little-endian format. SFR16E and SFR32E define sfr combinations without
  42      =5  // prerequisite byte order or adjacency. None of these multi-byte sfr
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 24  

  43      =5  // combinations will guarantee the order in which they are accessed when read
  44      =5  // or written.
  45      =5  //
  46      =5  // SFR16X and SFR32X for 16 bit and 32 bit xdata registers are not defined
  47      =5  // to avoid portability issues because of compiler endianness.
  48      =5  //
  49      =5  // Example:
  50      =5  // // my_mcu.c: main 'c' file for my mcu
  51      =5  // #include <compiler_defs.h>  // this file
  52      =5  // #include <C8051xxxx_defs.h> // SFR definitions for specific MCU target
  53      =5  //
  54      =5  // SBIT  (P0_1, 0x80, 1);      // Port 0 pin 1
  55      =5  // SFR   (P0, 0x80);           // Port 0
  56      =5  // SFRX  (CPUCS, 0xE600);      // Cypress FX2 Control and Status register in
  57      =5  //                             // xdata memory at 0xE600
  58      =5  // SFR16 (TMR2, 0xCC);         // Timer 2, lsb at 0xCC, msb at 0xCD
  59      =5  // SFR16E(TMR0, 0x8C8A);       // Timer 0, lsb at 0x8A, msb at 0x8C
  60      =5  // SFR32 (MAC0ACC, 0x93);      // SiLabs C8051F120 32 bits MAC0 Accumulator,
  61      =5  //                             // lsb at 0x93, msb at 0x96
  62      =5  // SFR32E(SUMR, 0xE5E4E3E2);   // TI MSC1210 SUMR 32 bits Summation register,
  63      =5  //                             // lsb at 0xE2, msb at 0xE5
  64      =5  //
  65      =5  // Target:         C8051xxxx
  66      =5  // Tool chain:     Generic
  67      =5  // Command Line:   None
  68      =5  // 
  69      =5  // Release 2.6 - 14 DEC 2012 (GO)
  70      =5  //        -Added define for deprecated SDCC keyword 'at'
  71      =5  // Release 2.5 - 12 SEP 2012 (TP)
  72      =5  //    -Added defines for deprecated SDCC keywords bit and code
  73      =5  // Release 2.4 - 27 AUG 2012 (TP)
  74      =5  //    -Added defines for deprecated SDCC keywords interrupt, _asm, and _endasm
  75      =5  // Release 2.3 - 27 MAY 2010 (DM)
  76      =5  //    -Removed 'LOCATED_VARIABLE' pragma from Keil because it is not supported
  77      =5  // Release 2.2 - 06 APR 2010 (ES)
  78      =5  //    -Removed 'PATHINCLUDE' pragma from Raisonance section
  79      =5  // Release 2.1 - 16 JUL 2009 (ES)
  80      =5  //    -Added SEGMENT_POINTER macro definitions for SDCC, Keil, and Raisonance
  81      =5  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for Raisonance
  82      =5  // Release 2.0 - 19 MAY 2009 (ES)
  83      =5  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for SDCC and Keil
  84      =5  // Release 1.9 - 23 OCT 2008 (ES)
  85      =5  //    -Updated Hi-Tech INTERRUPT and INTERRUPT_USING macro definitions
  86      =5  //    -Added SFR16 macro defintion for Hi-Tech
  87      =5  // Release 1.8 - 31 JUL 2008 (ES)
  88      =5  //    -Added INTERRUPT_USING and FUNCTION_USING macro's
  89      =5  //    -Added macro's for IAR
  90      =5  //    -Corrected Union definitions for Hi-Tech and added SFR16 macro defintion
  91      =5  // Release 1.7 - 11 SEP 2007 (BW)
  92      =5  //    -Added support for Raisonance EVAL 03.03.42 and Tasking Eval 7.2r1
  93      =5  // Release 1.6 - 27 AUG 2007 (BW)
  94      =5  //    -Updated copyright notice per agreement with Maartin Brock
  95      =5  //    -Added SDCC 2.7.0 "compiler.h" bug fixes
  96      =5  //    -Added memory segment defines (SEG_XDATA, for example)
  97      =5  // Release 1.5 - 24 AUG 2007 (BW)
  98      =5  //    -Added support for NOP () macro
  99      =5  //    -Added support for Hi-Tech ver 9.01
 100      =5  // Release 1.4 - 07 AUG 2007 (PKC)
 101      =5  //    -Removed FID and fixed formatting.
 102      =5  // Release 1.3 - 30 SEP 2007 (TP)
 103      =5  //    -Added INTERRUPT_PROTO_USING to properly support ISR context switching
 104      =5  //     under SDCC.
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 25  

 105      =5  // Release 1.2 - (BW)
 106      =5  //    -Added support for U8,U16,U32,S8,S16,S32,UU16,UU32 data types
 107      =5  // Release 1.1 - (BW)
 108      =5  //    -Added support for INTERRUPT, INTERRUPT_USING, INTERRUPT_PROTO,
 109      =5  //     SEGMENT_VARIABLE, VARIABLE_SEGMENT_POINTER,
 110      =5  //     SEGMENT_VARIABLE_SEGMENT_POINTER, and LOCATED_VARIABLE
 111      =5  // Release 1.0 - 29 SEP 2006 (PKC)
 112      =5  //    -Initial revision
 113      =5  
 114      =5  //-----------------------------------------------------------------------------
 115      =5  // Header File Preprocessor Directive
 116      =5  //-----------------------------------------------------------------------------
 117      =5  
 118      =5  #ifndef COMPILER_DEFS_H
           =5 #define COMPILER_DEFS_H
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 // Macro definitions
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 // SDCC - Small Device C Compiler
           =5 // http://sdcc.sourceforge.net
           =5 
           =5 #if defined SDCC
           =5 
           =5 #if (SDCC >= 300)
           =5 
           =5 #define interrupt __interrupt
           =5 #define _asm __asm
           =5 #define _endasm __endasm
           =5 #define bit __bit
           =5 #define code __code
           =5 #define at __at
           =5 
           =5 #endif
           =5 
           =5 # define SEG_GENERIC
           =5 # define SEG_FAR   __xdata
           =5 # define SEG_DATA  __data
           =5 # define SEG_NEAR  __data
           =5 # define SEG_IDATA __idata
           =5 # define SEG_XDATA __xdata
           =5 # define SEG_PDATA __pdata
           =5 # define SEG_CODE  __code
           =5 # define SEG_BDATA __bdata
           =5 
           =5 # define SBIT(name, addr, bit)  __sbit  __at(addr+bit)                  name
           =5 # define SFR(name, addr)        __sfr   __at(addr)                      name
           =5 # define SFRX(name, addr)       xdata volatile unsigned char __at(addr) name
           =5 # define SFR16(name, addr)      __sfr16 __at(((addr+1U)<<8) | addr)     name
           =5 # define SFR16E(name, fulladdr) __sfr16 __at(fulladdr)                  name
           =5 # define SFR32(name, addr)      __sfr32 __at(((addr+3UL)<<24) | ((addr+2UL)<<16) | ((addr+1UL)<<8) | addr)
             - name
           =5 # define SFR32E(name, fulladdr) __sfr32 __at(fulladdr)                  name
           =5 
           =5 # define INTERRUPT(name, vector) void name (void) interrupt (vector)
           =5 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =5 # define INTERRUPT_PROTO(name, vector) void name (void) interrupt (vector)
           =5 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =5 
           =5 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using (regnum
             -)
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 26  

           =5 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter) using (
             -regnum)
           =5 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =5 
           =5 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =5 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =5 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =5 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =5 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment at (addr) vartype name = init
           =5 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) locsegment at (addr) vartype name
           =5 
           =5 // used with UU16
           =5 # define LSB 0
           =5 # define MSB 1
           =5 
           =5 // used with UU32 (b0 is least-significant byte)
           =5 # define b0 0
           =5 # define b1 1
           =5 # define b2 2
           =5 # define b3 3
           =5 
           =5 typedef unsigned char U8;
           =5 typedef unsigned int U16;
           =5 typedef unsigned long U32;
           =5 
           =5 typedef signed char S8;
           =5 typedef signed int S16;
           =5 typedef signed long S32;
           =5 
           =5 typedef union UU16
           =5 {
           =5    U16 U16;
           =5    S16 S16;
           =5    U8 U8[2];
           =5    S8 S8[2];
           =5 } UU16;
           =5 
           =5 typedef union UU32
           =5 {
           =5    U32 U32;
           =5    S32 S32;
           =5    UU16 UU16[2];
           =5    U16 U16[2];
           =5    S16 S16[2];
           =5    U8 U8[4];
           =5    S8 S8[4];
           =5 } UU32;
           =5 
           =5 // NOP () macro support
           =5 #define NOP() _asm NOP _endasm
           =5 
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 // Raisonance (must be placed before Keil C51)
           =5 // http://www.raisonance.com
           =5 
           =5 #elif defined __RC51__
           =5 
           =5 //#error Raisonance C51 detected.
           =5 
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 27  

           =5 # define SEG_GENERIC generic     //SEG_GENERIC only applies to pointers in Raisonance, not variables.
           =5 # define SEG_FAR   xdata
           =5 # define SEG_DATA  data
           =5 # define SEG_NEAR  data
           =5 # define SEG_IDATA idata
           =5 # define SEG_XDATA xdata
           =5 # define SEG_PDATA pdata
           =5 # define SEG_CODE  code
           =5 # define SEG_BDATA bdata
           =5 
           =5 # define SBIT(name, addr, bit)  at (addr+bit) sbit         name
           =5 # define SFR(name, addr)        sfr at addr                name
           =5 # define SFR16(name, addr)      sfr16 at addr              name
           =5 # define SFR16E(name, fulladdr) /* not supported */
           =5 # define SFR32(name, fulladdr)  /* not supported */
           =5 # define SFR32E(name, fulladdr) /* not supported */
           =5 
           =5 # define INTERRUPT(name, vector) void name (void) interrupt vector
           =5 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =5 # define INTERRUPT_PROTO(name, vector) void name (void)
           =5 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =5 
           =5 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
           =5 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =5 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =5 
           =5 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =5 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =5 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =5 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =5 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) at addr locsegment vartype name
           =5 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) at addr locsegment vartype name
           =5 
           =5 
           =5 // used with UU16
           =5 # define LSB 1
           =5 # define MSB 0
           =5 
           =5 // used with UU32 (b0 is least-significant byte)
           =5 # define b0 3
           =5 # define b1 2
           =5 # define b2 1
           =5 # define b3 0
           =5 
           =5 typedef unsigned char U8;
           =5 typedef unsigned int U16;
           =5 typedef unsigned long U32;
           =5 
           =5 typedef signed char S8;
           =5 typedef signed int S16;
           =5 typedef signed long S32;
           =5 
           =5 typedef union UU16
           =5 {
           =5    U16 U16;
           =5    S16 S16;
           =5    U8 U8[2];
           =5    S8 S8[2];
           =5 } UU16;
           =5 
           =5 typedef union UU32
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 28  

           =5 {
           =5    U32 U32;
           =5    S32 S32;
           =5    UU16 UU16[2];
           =5    U16 U16[2];
           =5    S16 S16[2];
           =5    U8 U8[4];
           =5    S8 S8[4];
           =5 } UU32;
           =5 
           =5 // NOP () macro support -- NOP is opcode 0x00
           =5 #define NOP() asm { 0x00 }
           =5 
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 
           =5 // Keil C51
           =5 // http://www.keil.com
           =5 
           =5 #elif defined __C51__
           =5 
           =5 //#error Keil C51 detected.
           =5 
           =5 # define SEG_GENERIC
           =5 # define SEG_FAR   xdata
           =5 # define SEG_DATA  data
           =5 # define SEG_NEAR  data
           =5 # define SEG_IDATA idata
           =5 # define SEG_XDATA xdata
           =5 # define SEG_PDATA pdata
           =5 # define SEG_CODE  code
           =5 # define SEG_BDATA bdata
           =5 
           =5 # define SBIT(name, addr, bit)  sbit  name = addr^bit
           =5 # define SFR(name, addr)        sfr   name = addr
           =5 # define SFR16(name, addr)      sfr16 name = addr
           =5 # define SFR16E(name, fulladdr) /* not supported */
           =5 # define SFR32(name, fulladdr)  /* not supported */
           =5 # define SFR32E(name, fulladdr) /* not supported */
           =5 
           =5 # define INTERRUPT(name, vector) void name (void) interrupt vector
           =5 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =5 # define INTERRUPT_PROTO(name, vector) void name (void)
           =5 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =5 
           =5 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
           =5 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =5 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =5 
           =5 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =5 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =5 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =5 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =5 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) vartype locsegment name _at_ addr
           =5 
           =5 // used with UU16
           =5 # define LSB 1
           =5 # define MSB 0
           =5 
           =5 // used with UU32 (b0 is least-significant byte)
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 29  

           =5 # define b0 3
           =5 # define b1 2
           =5 # define b2 1
           =5 # define b3 0
           =5 
           =5 typedef unsigned char U8;
           =5 typedef unsigned int U16;
           =5 typedef unsigned long U32;
           =5 
           =5 typedef signed char S8;
           =5 typedef signed int S16;
           =5 typedef signed long S32;
           =5 
           =5 typedef union UU16
           =5 {
           =5    U16 U16;
           =5    S16 S16;
           =5    U8 U8[2];
           =5    S8 S8[2];
           =5 } UU16;
           =5 
           =5 typedef union UU32
           =5 {
           =5    U32 U32;
           =5    S32 S32;
           =5    UU16 UU16[2];
           =5    U16 U16[2];
           =5    S16 S16[2];
           =5    U8 U8[4];
           =5    S8 S8[4];
           =5 } UU32;
           =5 
           =5 // NOP () macro support
           =5 extern void _nop_ (void);
           =5 #define NOP() _nop_()
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 // Hi-Tech 8051
           =5 // http://www.htsoft.com
           =5 
           =5 #elif defined HI_TECH_C
           =5 
           =5 # define SEG_GENERIC
           =5 # define SEG_FAR   far
           =5 # define SEG_DATA  data
           =5 # define SEG_NEAR  near
           =5 # define SEG_IDATA idata
           =5 # define SEG_XDATA xdata
           =5 # define SEG_PDATA pdata
           =5 # define SEG_CODE  code
           =5 # define SEG_BDATA bdata
           =5 
           =5 
           =5 # define SBIT(name, addr, thebit) static volatile bit name @ (addr + thebit)
           =5 # define SFR(name, addr)          static volatile unsigned char name @ addr
           =5 # define SFR16(name, addr)        static volatile unsigned int name @ addr
           =5 # define SFR16E(name, fulladdr) /* not supported */
           =5 # define SFR32(name, fulladdr)  /* not supported */
           =5 # define SFR32E(name, fulladdr) /* not supported */
           =5 
           =5 # define INTERRUPT(name, vector)       void name (void) interrupt vector
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 30  

           =5 # define INTERRUPT_PROTO(name, vector)
           =5 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =5 # define INTERRUPT_PROTO_USING(name, vector, regnum)
           =5 
           =5 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =5 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =5 // Note: Hi-Tech does not support functions using different register banks. Register
           =5 //       banks can only be specified in interrupts. If a function is called from
           =5 //       inside an interrupt, it will use the same register bank as the interrupt.
           =5 
           =5 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =5 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =5 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =5 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment vartype name @ addr
           =5 
           =5 // used with UU16
           =5 # define LSB 0
           =5 # define MSB 1
           =5 
           =5 // used with UU32 (b0 is least-significant byte)
           =5 # define b0 0
           =5 # define b1 1
           =5 # define b2 2
           =5 # define b3 3
           =5 
           =5 typedef unsigned char U8;
           =5 typedef unsigned int U16;
           =5 typedef unsigned long U32;
           =5 
           =5 typedef signed char S8;
           =5 typedef signed int S16;
           =5 typedef signed long S32;
           =5 
           =5 typedef union UU16
           =5 {
           =5    U16 U16;
           =5    S16 S16;
           =5    U8 U8[2];
           =5    S8 S8[2];
           =5 } UU16;
           =5 
           =5 typedef union UU32
           =5 {
           =5    U32 U32;
           =5    S32 S32;
           =5    UU16 UU16[2];
           =5    U16 U16[2];
           =5    S16 S16[2];
           =5    U8 U8[4];
           =5    S8 S8[4];
           =5 } UU32;
           =5 
           =5 // NOP () macro support
           =5 #define NOP() asm(" nop ")
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 // Tasking / Altium
           =5 // http://www.altium.com/tasking
           =5 
           =5 
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 31  

           =5 #elif defined _CC51
           =5 
           =5 # define SEG_GENERIC
           =5 # define SEG_FAR   _xdat
           =5 # define SEG_DATA  _data
           =5 # define SEG_NEAR  _data
           =5 # define SEG_IDATA _idat
           =5 # define SEG_XDATA _xdat
           =5 # define SEG_PDATA _pdat
           =5 # define SEG_CODE  _rom
           =5 # define SEG_BDATA _bdat
           =5 
           =5 # define SBIT(name, addr, bit)  _sfrbit  name _at(addr+bit)
           =5 # define SFR(name, addr)        _sfrbyte name _at(addr)
           =5 # define SFRX(name, addr)       _xdat volatile unsigned char name _at(addr)
           =5 #if _CC51 > 71
           =5 # define SFR16(name, addr)      _sfrword _little name _at(addr)
           =5 #else
           =5 # define SFR16(name, addr)      /* not supported */
           =5 #endif
           =5 # define SFR16E(name, fulladdr) /* not supported */
           =5 # define SFR32(name, fulladdr)  /* not supported */
           =5 # define SFR32E(name, fulladdr) /* not supported */
           =5 
           =5 # define INTERRUPT(name, vector) _interrupt (vector) void name (void)
           =5 # define INTERRUPT_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =5 # define INTERRUPT_PROTO(name, vector) _interrupt (vector) void name (void)
           =5 # define INTERRUPT_PROTO_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =5 
           =5 // When calling FUNCTION_USING in Tasking, the function must be called from an interrupt or Main which
           =5 // is also using the same register bank. If not, the compiler will generate an error.
           =5 # define FUNCTION_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (parameter
             -)
           =5 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (par
             -ameter)
           =5 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =5 
           =5 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =5 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =5 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =5 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) vartype locsegment name _at( addr )
           =5 
           =5 // used with UU16
           =5 # define LSB 1
           =5 # define MSB 0
           =5 
           =5 // used with UU32 (b0 is least-significant byte)
           =5 # define b0 3
           =5 # define b1 2
           =5 # define b2 1
           =5 # define b3 0
           =5 
           =5 typedef unsigned char U8;
           =5 typedef unsigned int U16;
           =5 typedef unsigned long U32;
           =5 
           =5 typedef signed char S8;
           =5 typedef signed int S16;
           =5 typedef signed long S32;
           =5 
           =5 typedef union UU16
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 32  

           =5 {
           =5    U16 U16;
           =5    S16 S16;
           =5    U8 U8[2];
           =5    S8 S8[2];
           =5 } UU16;
           =5 
           =5 typedef union UU32
           =5 {
           =5    U32 U32;
           =5    S32 S32;
           =5    UU16 UU16[2];
           =5    U16 U16[2];
           =5    S16 S16[2];
           =5    U8 U8[4];
           =5    S8 S8[4];
           =5 } UU32;
           =5 
           =5 // NOP () macro support
           =5 extern void _nop (void);
           =5 #define NOP() _nop()
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 
           =5 // IAR 8051
           =5 // http://www.iar.com
           =5 
           =5 #elif defined __ICC8051__
           =5 
           =5 #include <stdbool.h>
           =5 #include <intrinsics.h>
           =5 
           =5 # define SBIT(name, addr, bit)  __bit __no_init volatile bool name @ (addr+bit)
           =5 # define SFR(name, addr)        __sfr __no_init volatile unsigned char name @ addr
           =5 # define SFRX(name, addr)       __xdata __no_init volatile unsigned char name @ addr
           =5 # define SFR16(name, addr)      __sfr __no_init volatile unsigned int  name @ addr
           =5 # define SFR16E(name, fulladdr) /* not supported */
           =5 # define SFR32(name, fulladdr) /* not supported */
           =5 # define SFR32E(name, fulladdr) /* not supported */
           =5 
           =5 # define SEG_GENERIC __generic
           =5 # define SEG_FAR  __xdata
           =5 # define SEG_DATA __data
           =5 # define SEG_NEAR __data
           =5 # define SEG_IDATA __idata
           =5 # define SEG_XDATA __xdata
           =5 # define SEG_PDATA __pdata
           =5 # define SEG_CODE  __code
           =5 # define SEG_BDATA __bdata
           =5 
           =5 #define bit bool
           =5 
           =5 # define _PPTOSTR_(x) #x
           =5 # define _PPARAM_(address) _PPTOSTR_(vector=address * 8 + 3)
           =5 # define _PPARAM2_(regbank) _PPTOSTR_(register_bank=regbank)
           =5 # define INTERRUPT(name, vector) _Pragma(_PPARAM_(vector)) __interrupt void name(void)
           =5 # define INTERRUPT_PROTO(name, vector)  __interrupt void name(void)
           =5 # define INTERRUPT_USING(name, vector, regnum) _Pragma(_PPARAM2_(regnum)) _Pragma(_PPARAM_(vector)) __inte
             -rrupt void name(void)
           =5 # define INTERRUPT_PROTO_USING(name, vector, regnum) __interrupt void name(void)
           =5 
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 33  

           =5 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =5 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =5 // Note: IAR does not support functions using different register banks. Register
           =5 //       banks can only be specified in interrupts. If a function is called from
           =5 //       inside an interrupt, it will use the same register bank as the interrupt.
           =5 
           =5 # define SEGMENT_VARIABLE(name, vartype, locsegment)  locsegment vartype name
           =5 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment  * name
           =5 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =5 
           =5 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment __no_init vartype name @ addr
           =5 
           =5 // used with UU16
           =5 # define LSB 0
           =5 # define MSB 1
           =5 
           =5 // used with UU32 (b0 is least-significant byte)
           =5 # define b0 0
           =5 # define b1 1
           =5 # define b2 2
           =5 # define b3 3
           =5 
           =5 typedef unsigned char U8;
           =5 typedef unsigned int U16;
           =5 typedef unsigned long U32;
           =5 
           =5 typedef signed char S8;
           =5 typedef signed int S16;
           =5 typedef signed long S32;
           =5 
           =5 typedef union UU16
           =5 {
           =5    U16 U16;
           =5    S16 S16;
           =5    U8 U8[2];
           =5    S8 S8[2];
           =5 } UU16;
           =5 
           =5 typedef union UU32
           =5 {
           =5    U32 U32;
           =5    S32 S32;
           =5    UU16 UU16[2];
           =5    U16 U16[2];
           =5    S16 S16[2];
           =5    U8 U8[4];
           =5    S8 S8[4];
           =5 } UU32;
           =5 
           =5 
           =5 #define NOP() __no_operation();
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 // Crossware
           =5 // http://www.crossware.com
           =5 
           =5 #elif defined _XC51_VER
           =5 # define SBIT(name, addr, bit)  _sfrbit  name = (addr+bit)
           =5 # define SFR(name, addr)        _sfr     name = addr
           =5 # define SFR16(name, addr)      _sfrword name = addr
           =5 # define SFR16E(name, fulladdr) /* not supported */
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 34  

           =5 # define SFR32(name, fulladdr)  /* not supported */
           =5 # define SFR32E(name, fulladdr) /* not supported */
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 // Wickenhäuser
           =5 // http://www.wickenhaeuser.de
           =5 
           =5 #elif defined __UC__
           =5 # define SBIT(name, addr, bit)  unsigned char bit  name @ (addr+bit)
           =5 # define SFR(name, addr)        near unsigned char name @ addr
           =5 # define SFR16(name, addr)      /* not supported */
           =5 # define SFR16E(name, fulladdr) /* not supported */
           =5 # define SFR32(name, fulladdr)  /* not supported */
           =5 # define SFR32E(name, fulladdr) /* not supported */
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 // Default
           =5 // Unknown compiler
           =5 
           =5 #else
           =5 # warning unrecognized compiler
           =5 # define SBIT(name, addr, bit)  volatile bool           name
           =5 # define SFR(name, addr)        volatile unsigned char  name
           =5 # define SFRX(name, addr)       volatile unsigned char  name
           =5 # define SFR16(name, addr)      volatile unsigned short name
           =5 # define SFR16E(name, fulladdr) volatile unsigned short name
           =5 # define SFR32(name, fulladdr)  volatile unsigned long  name
           =5 # define SFR32E(name, fulladdr) volatile unsigned long  name
           =5 
           =5 #endif
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 // Header File PreProcessor Directive
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 #endif                                 // #define COMPILER_DEFS_H
 689      =5  
 690      =5  //-----------------------------------------------------------------------------
 691      =5  // End Of File
 692      =5  //-----------------------------------------------------------------------------
   8      =4  #include <C8051F580_defs.h> // SFR declarations
   1      =5  //-----------------------------------------------------------------------------
   2      =5  // C8051F580_defs.h
   3      =5  //-----------------------------------------------------------------------------
   4      =5  // Copyright 2008, Silicon Laboratories, Inc.
   5      =5  // http://www.silabs.com
   6      =5  //
   7      =5  // Program Description:
   8      =5  //
   9      =5  // Register/bit definitions for the C8051F58x family.
  10      =5  // **Important Note**: The compiler_defs.h header file should be included
  11      =5  // before including this header file.
  12      =5  //
  13      =5  // Target:         C8051F580/1/2/3/4/5/6/7,8/9-F590/1
  14      =5  // Tool chain:     Generic
  15      =5  // Command Line:   None
  16      =5  //
  17      =5  // Release 0.6 - 20 AUG 2012 (TP)
  18      =5  //    -Added #define for _XPAGE to provide support for SDCC memory paging
  19      =5  //     (pdata)
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 35  

  20      =5  //
  21      =5  // Release 0.5 - 10 SEP 2011 (GP)
  22      =5  //    - Fixed SFR16 definition for CAN0IF2MC
  23      =5  //
  24      =5  // Release 0.4 - 08 OCT 2010 (TP)
  25      =5  //    - Fixed bit definitions for SCON0
  26      =5  //
  27      =5  // Release 0.3 - 01 APR 2009 (GP)
  28      =5  //    - Added SN0-SN3
  29      =5  //
  30      =5  // Release 0.2 - 29 JUL 2008 (ADT)
  31      =5  //    - Added Timer 4 bit definitions
  32      =5  //
  33      =5  // Release 0.1 - 09 JUL 2008 (GP)
  34      =5  //    - Initial Revision
  35      =5  //
  36      =5  //-----------------------------------------------------------------------------
  37      =5  // Header File Preprocessor Directive
  38      =5  //-----------------------------------------------------------------------------
  39      =5  
  40      =5  #ifndef C8051F580_DEFS_H
           =5 #define C8051F580_DEFS_H
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 // Page 0, Page 1 and Page F Registers
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 SFR (P0, 0x80);                        // Port 0 Latch
           =5 SFR (SP, 0x81);                        // Stack Pointer
           =5 SFR (DPL, 0x82);                       // Data Pointer Low
           =5 SFR (DPH, 0x83);                       // Data Pointer High
           =5 SFR (SFR0CN, 0x84);                    // SFR Page Control
           =5 SFR (SFRNEXT, 0x85);                   // SFR stack next page
           =5 SFR (SFRLAST, 0x86);                   // SFR stack last page
           =5 SFR (PCON, 0x87);                      // Power Control
           =5 SFR (TCON, 0x88);                      // Timer/Counter Control
           =5 SFR (TMOD, 0x89);                      // Timer/Counter Mode
           =5 SFR (TL0, 0x8A);                       // Timer/Counter 0 Low
           =5 SFR (TL1, 0x8B);                       // Timer/Counter 1 Low
           =5 SFR (TH0, 0x8C);                       // Timer/Counter 0 High
           =5 SFR (TH1, 0x8D);                       // Timer/Counter 1 High
           =5 SFR (CKCON, 0x8E);                     // Clock Control
           =5 SFR (PSCTL, 0x8F);                     // Program Store R/W Control
           =5 SFR (CLKSEL, 0x8F);                    // System clock select
           =5 SFR (P1, 0x90);                        // Port 1 Latch
           =5 SFR (TMR3CN, 0x91);                    // Timer/Counter 3 Control
           =5 SFR (TMR5CN, 0x91);                    // Timer/Counter 5 Control
           =5 SFR (TMR3RLL, 0x92);                   // Timer/Counter 3 Reload Low
           =5 SFR (TMR5CAPL, 0x92);                  // Timer/Counter 5 Capture Low
           =5 SFR (TMR3RLH, 0x93);                   // Timer/Counter 3 Reload High
           =5 SFR (TMR5CAPH, 0x93);                  // Timer/Counter 5 Capture High
           =5 SFR (TMR3L, 0x94);                     // Timer/Counter 3 Low
           =5 SFR (TMR5L, 0x94);                     // Timer/Counter 5 Low
           =5 SFR (TMR3H, 0x95);                     // Timer/Counter 3 High
           =5 SFR (TMR5H, 0x95);                     // Timer/Counter 5 High
           =5 SFR (TMR5CF, 0x96);                    // Timer/Counter 5 Configuration
           =5 SFR (CLKMUL, 0x97);                    // Clock Multiplier
           =5 SFR (SCON0, 0x98);                     // UART0 Control
           =5 SFR (SCON1, 0x98);                     // UART1 Control
           =5 SFR (SBUF0, 0x99);                     // UART0 Data Buffer
           =5 SFR (SBUF1, 0x99);                     // UART1 Data Buffer
           =5 SFR (CPT0CN, 0x9A);                    // Comparator 0 Control
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 36  

           =5 SFR (CPT2CN, 0x9A);                    // Comparator 2 Control
           =5 SFR (CPT0MD, 0x9B);                    // Comparator 0 Mode
           =5 SFR (CPT2MD, 0x9B);                    // Comparator 2 Mode
           =5 SFR (CPT0MX, 0x9C);                    // Comparator 0 Mux
           =5 SFR (CPT2MX, 0x9C);                    // Comparator 2 Mux
           =5 SFR (CPT1CN, 0x9D);                    // Comparator 1 Control
           =5 SFR (CPT1MD, 0x9E);                    // Comparator 0 Mode
           =5 SFR (OSCIFIN, 0x9E);                   // Internal Oscillator Fine Control
           =5 SFR (CPT1MX, 0x9F);                    // Comparator 1 Mux
           =5 SFR (OSCXCN, 0x9F);                    // External Oscillator Control
           =5 SFR (P2, 0xA0);                        // Port 2 Latch
           =5 SFR (SPI0CFG, 0xA1);                   // SPI0 Configuration
           =5 SFR (OSCICN, 0xA1);                    // Internal Oscillator Control
           =5 SFR (SPI0CKR, 0xA2);                   // SPI0 Clock rate control
           =5 SFR (OSCICRS, 0xA2);                   // Internal Oscillator Coarse Control
           =5 SFR (SPI0DAT, 0xA3);                   // SPI0 Data Buffer
           =5 SFR (P0MDOUT, 0xA4);                   // Port 0 Output Mode
           =5 SFR (P1MDOUT, 0xA5);                   // Port 1 Output Mode
           =5 SFR (P2MDOUT, 0xA6);                   // Port 2 Output Mode
           =5 SFR (SFRPAGE, 0xA7);                   // SFR Page Select
           =5 SFR (IE, 0xA8);                        // Interrupt Enable
           =5 SFR (SMOD0, 0xA9);                     // Serial Port 0 Control
           =5 SFR (EMI0CN, 0xAA);                    // EMIF Control
           =5 SFR (EMI0TC, 0xAA);                    // EMIF Timing control
           =5 SFR (SBCON0, 0xAB);                    // UART0 Baud Rate Generator Control
           =5 SFR (SBRLL0, 0xAC);                    // UART0 Baud Rate Generator Low
           =5 SFR (SBRLH0, 0xAD);                    // UART0 Baud Rate Generator High
           =5 SFR (P3MAT, 0xAE);                     // Port 3 Match
           =5 SFR (P3MDOUT, 0xAE);                   // Port 3 Mode
           =5 SFR (P3MASK, 0xAF);                    // Port 3 Mask
           =5 SFR (P4MDOUT, 0xAF);                   // Port 4 Mode
           =5 SFR (P3, 0xB0);                        // Port 3 Latch
           =5 SFR (P2MAT, 0xB1);                     // Port 2 Match
           =5 SFR (P2MASK, 0xB2);                    // Port 2 Mask
           =5 SFR (EMI0CF, 0xB2);                    // EMIF Configuration
           =5 SFR (P4, 0xB5);                        // Port 4 Latch
           =5 SFR (FLSCL, 0xB6);                     // Flash Scale
           =5 SFR (FLKEY, 0xB7);                     // Flash access limit
           =5 SFR (IP, 0xB8);                        // Interrupt Priority
           =5 SFR (SMB0ADR, 0xB9);                   // SMBus0 Slave address
           =5 SFR (ADC0TK, 0xBA);                    // ADC0 Tracking Mode Select
           =5 SFR (SMB0ADM, 0xBA);                   // SMBus0 Address Mask
           =5 SFR (ADC0MX, 0xBB);                    // AMUX0 Channel select
           =5 SFR (ADC0CF, 0xBC);                    // AMUX0 Channel configuration
           =5 SFR (ADC0L, 0xBD);                     // ADC0 Data Low
           =5 SFR (ADC0H, 0xBE);                     // ADC0 Data High
           =5 SFR (SMB0CN, 0xC0);                    // SMBus0 Control
           =5 SFR (SMB0CF, 0xC1);                    // SMBus0 Configuration
           =5 SFR (SMB0DAT, 0xC2);                   // SMBus0 Data
           =5 SFR (ADC0GTL, 0xC3);                   // ADC0 Greater-Than Compare Low
           =5 SFR (ADC0GTH, 0xC4);                   // ADC0 Greater-Than Compare High
           =5 SFR (ADC0LTL, 0xC5);                   // ADC0 Less-Than Compare Word Low
           =5 SFR (ADC0LTH, 0xC6);                   // ADC0 Less-Than Compare Word High
           =5 SFR (XBR3, 0xC6);                      // Port I/O Crossbar Control 3
           =5 SFR (XBR2, 0xC7);                      // Port I/O Crossbar Control 2
           =5 SFR (TMR2CN, 0xC8);                    // Timer/Counter 2 Control
           =5 SFR (TMR4CN, 0xC8);                    // Timer/Counter 4 Control
           =5 SFR (REG0CN, 0xC9);                    // Regulator Control
           =5 SFR (LIN0CF, 0xC9);                    // LIN 0 Configuration
           =5 SFR (TMR4CF, 0xC9);                    // Timer/Counter 4 Configuration
           =5 SFR (TMR2RLL, 0xCA);                   // Timer/Counter 2 Reload Low
           =5 SFR (TMR4CAPL, 0xCA);                  // Timer/Counter 4 Capture Low
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 37  

           =5 SFR (TMR2RLH, 0xCB);                   // Timer/Counter 2 Reload High
           =5 SFR (TMR4CAPH, 0xCB);                  // Timer/Counter 4 Capture High
           =5 SFR (TMR2L, 0xCC);                     // Timer/Counter 2 Low
           =5 SFR (TMR4L, 0xCC);                     // Timer/Counter 4 Low
           =5 SFR (TMR2H, 0xCD);                     // Timer/Counter 2 High
           =5 SFR (TMR4H, 0xCD);                     // Timer/Counter 4 High
           =5 SFR (PCA0CPL5, 0xCE);                  // PCA0 Capture 5 Low
           =5 SFR (PCA1CPL11, 0xCE);                 // PCA1 Capture 11 Low
           =5 SFR (PCA0CPH5, 0xCF);                  // PCA0 Capture 5 High
           =5 SFR (PCA1CPH11, 0xCF);                 // PCA1 Capture 11 High
           =5 SFR (PSW, 0xD0);                       // Program Status Word
           =5 SFR (REF0CN, 0xD1);                    // Voltage Reference Control
           =5 SFR (LIN0DAT, 0xD2);                   // LIN0 Data
           =5 SFR (LIN0ADR, 0xD3);                   // LIN0 Address
           =5 SFR (P0SKIP, 0xD4);                    // Port 0 Skip
           =5 SFR (P1SKIP, 0xD5);                    // Port 1 Skip
           =5 SFR (P2SKIP, 0xD6);                    // Port 2 Skip
           =5 SFR (P3SKIP, 0xD7);                    // Port 3 Skip
           =5 SFR (PCA0CN, 0xD8);                    // PCA0 Control
           =5 SFR (PCA1CN, 0xD8);                    // PCA1 Control
           =5 SFR (PCA0MD, 0xD9);                    // PCA0 Mode
           =5 SFR (PCA1MD, 0xD9);                    // PCA1 Mode
           =5 SFR (PCA0PWM, 0xD9);                   // PCA0 PWM Control
           =5 SFR (PCA0CPM0, 0xDA);                  // PCA0 Module 0 Mode
           =5 SFR (PCA1CPM6, 0xDA);                  // PCA1 Module 6 Mode
           =5 SFR (PCA1PWM, 0xDA);                   // PCA1 PWM Control
           =5 SFR (PCA0CPM1, 0xDB);                  // PCA0 Module 1  Mode
           =5 SFR (PCA1CPM7, 0xDB);                  // PCA1 Module 7  Mode
           =5 SFR (PCA0CPM2, 0xDC);                  // PCA0 Module 2  Mode
           =5 SFR (PCA1CPM8, 0xDC);                  // PCA1 Module 8  Mode
           =5 SFR (PCA0CPM3, 0xDD);                  // PCA0 Module 3  Mode
           =5 SFR (PCA1CPM9, 0xDD);                  // PCA1 Module 9  Mode
           =5 SFR (PCA0CPM4, 0xDE);                  // PCA0 Module 4  Mode
           =5 SFR (PCA1CPM10, 0xDE);                  // PCA1 Module 10 Mode
           =5 SFR (PCA0CPM5, 0xDF);                  // PCA0 Module 5  Mode
           =5 SFR (PCA1CPM11, 0xDF);                  // PCA1 Module 11 Mode
           =5 SFR (ACC, 0xE0);                       // Accumulator
           =5 SFR (XBR0, 0xE1);                      // Port I/O Crossbar Control 0
           =5 SFR (XBR1, 0xE2);                      // Port I/O Crossbar Control 1
           =5 SFR (CCH0CN, 0xE3);                    // Cache control
           =5 SFR (IT01CF, 0xE4);                    // INT0/INT1 Configuration
           =5 SFR (EIE1, 0xE6);                      // Extended Interrupt Enable 2
           =5 SFR (EIE2, 0xE7);                      // Extended Interrupt Enable 2
           =5 SFR (ADC0CN, 0xE8);                    // ADC0 Control
           =5 SFR (PCA0CPL1, 0xE9);                  // PCA0 Capture 1 Low
           =5 SFR (PCA1CPL1, 0xE9);                  // PCA1 Capture 7 Low
           =5 SFR (PCA0CPH1, 0xEA);                  // PCA0 Capture 1 High
           =5 SFR (PCA1CPH1, 0xEA);                  // PCA1 Capture 7 High
           =5 SFR (PCA0CPL2, 0xEB);                  // PCA0 Capture 2 Low
           =5 SFR (PCA1CPL2, 0xEB);                  // PCA1 Capture 8 Low
           =5 SFR (PCA0CPH2, 0xEC);                  // PCA0 Capture 2 High
           =5 SFR (PCA1CPH2, 0xEC);                  // PCA1 Capture 8 High
           =5 SFR (PCA0CPL3, 0xED);                  // PCA0 Capture 3 Low
           =5 SFR (PCA1CPL3, 0xED);                  // PCA1 Capture 9 Low
           =5 SFR (PCA0CPH3, 0xEE);                  // PCA0 Capture 3 High
           =5 SFR (PCA1CPH3, 0xEE);                  // PCA1 Capture 9 High
           =5 SFR (RSTSRC, 0xEF);                    // Reset Source Configuration/Status
           =5 SFR (B, 0xF0);                         // B Register
           =5 SFR (P0MAT, 0xF1);                     // Port 0 Match
           =5 SFR (P0MDIN, 0xF1);                    // Port 0 Input Mode
           =5 SFR (P0MASK, 0xF2);                    // Port 0 Mask
           =5 SFR (P1MDIN, 0xF2);                    // Port 1 Input Mode
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 38  

           =5 SFR (P1MAT, 0xF3);                     // Port 1 Match
           =5 SFR (P2MDIN, 0xF3);                    // Port 2 Input Mode
           =5 SFR (P1MASK, 0xF4);                    // Port 1 Mask
           =5 SFR (P3MDIN, 0xF4);                    // Port 3 Input Mode
           =5 SFR (PSBANK, 0xF5);                    // Program Space Bank Select
           =5 SFR (EIP1, 0xF6);                      // External Interrupt Priority 1
           =5 SFR (EIP2, 0xF7);                      // External Interrupt Priority 2
           =5 SFR (SPI0CN, 0xF8);                    // SPI0 Control
           =5 SFR (PCA0L, 0xF9);                     // PCA0 Counter Low
           =5 SFR (PCA1L, 0xF9);                     // PCA1 Counter Low
           =5 SFR (SN0, 0xF9);                       // Serial Number 0
           =5 SFR (PCA0H, 0xFA);                     // PCA0 Counter High
           =5 SFR (PCA1H, 0xFA);                     // PCA1 Counter High
           =5 SFR (SN1, 0xFA);                       // Serial Number 1
           =5 SFR (PCA0CPL0, 0xFB);                  // PCA0 Capture 0 Low
           =5 SFR (PCA1CPL6, 0xFB);                  // PCA1 Capture 6 Low
           =5 SFR (SN2, 0xFB);                       // Serial Number 2
           =5 SFR (PCA0CPH0, 0xFC);                  // PCA0 Capture 0 High
           =5 SFR (PCA1CPH6, 0xFC);                  // PCA1 Capture 6 High
           =5 SFR (SN3, 0xFC);                       // Serial Number 3
           =5 SFR (PCA0CPL4, 0xFD);                  // PCA0 Capture 4 Low
           =5 SFR (PCA1CPL10, 0xFD);                 // PCA1 Capture 10 Low
           =5 SFR (PCA0CPH4, 0xFE);                  // PCA0 Capture 4 High
           =5 SFR (PCA1CPH10, 0xFE);                 // PCA1 Capture 10 High
           =5 SFR (VDM0CN, 0xFF);                    // VDD Monitor Control
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 // Page C (CAN0) Registers
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 SFR (CAN0CFG, 0x92);                   // CAN0 Clock Configuration
           =5 SFR (CAN0STAT, 0x94);                  // Status Register Low Byte
           =5 SFR (CAN0ERRL, 0x96);                  // Error Counter Low Byte
           =5 SFR (CAN0ERRH, 0x97);                  // Error Counter High Byte
           =5 SFR (CAN0BTL, 0x9A);                   // Bit Timing Register Low Byte
           =5 SFR (CAN0BTH, 0x9B);                   // Bit Timing Register High Byte
           =5 SFR (CAN0IIDL, 0x9C);                  // Interrupt Register Low Byte
           =5 SFR (CAN0IIDH, 0x9D);                  // Interrupt Register High Byte
           =5 SFR (CAN0TST, 0x9E);                   // Test Register Low Byte
           =5 SFR (CAN0BRPE, 0xA1);                  // BRP Extension Register Low Byte
           =5 SFR (CAN0TR1L, 0xA2);                  // Transmission Request 1 Low Byte
           =5 SFR (CAN0TR1H, 0xA3);                  // Transmission Request 1 High Byte
           =5 SFR (CAN0TR2L, 0xA4);                  // Transmission Request 2 Low Byte
           =5 SFR (CAN0TR2H, 0xA5);                  // Transmission Request 2 High Byte
           =5 SFR (CAN0ND1L, 0xAA);                  // New Data 1 Low Byte
           =5 SFR (CAN0ND1H, 0xAB);                  // New Data 1 High Byte
           =5 SFR (CAN0ND2L, 0xAC);                  // New Data 2 Low Byte
           =5 SFR (CAN0ND2H, 0xAD);                  // New Data 2 High Byte
           =5 SFR (CAN0IP1L, 0xAE);                  // Interrupt Pending 1 Low Byte
           =5 SFR (CAN0IP1H, 0xAF);                  // Interrupt Pending 1 High Byte
           =5 SFR (CAN0IP2L, 0xB2);                  // Interrupt Pending 2 Low Byte
           =5 SFR (CAN0IP2H, 0xB3);                  // Interrupt Pending 2 High Byte
           =5 SFR (CAN0MV1L, 0xBA);                  // Message Valid 1 Low Byte
           =5 SFR (CAN0MV1H, 0xBB);                  // Message Valid 1 High Byte
           =5 SFR (CAN0MV2L, 0xBC);                  // Message Valid 2 Low Byte
           =5 SFR (CAN0MV2H, 0xBD);                  // Message Valid 2 High Byte
           =5 SFR (CAN0IF1CRL, 0xBE);                // IF1 Command Request Low Byte
           =5 SFR (CAN0IF1CRH, 0xBF);                // IF1 Command Request High Byte
           =5 SFR (CAN0CN, 0xC0);                    // CAN Control Register Low Byte
           =5 SFR (CAN0IF1CML, 0xC2);                // IF1 Command Mask Low Byte
           =5 SFR (CAN0IF1CMH, 0xC3);                // IF1 Command Mask High Byte
           =5 SFR (CAN0IF1M1L, 0xC4);                // IF1 Mask 1 Low Byte
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 39  

           =5 SFR (CAN0IF1M1H, 0xC5);                // IF1 Mask 1 High Byte
           =5 SFR (CAN0IF1M2L, 0xC6);                // IF1 Mask 2 Low Byte
           =5 SFR (CAN0IF1M2H, 0xC7);                // IF1 Mask 2 High Byte
           =5 SFR (CAN0IF1A1L, 0xCA);                // IF1 Arbitration 1 Low Byte
           =5 SFR (CAN0IF1A1H, 0xCB);                // IF1 Arbitration 1 High Byte
           =5 SFR (CAN0IF1A2L, 0xCC);                // IF1 Arbitration 2 Low Byte
           =5 SFR (CAN0IF1A2H, 0xCD);                // IF1 Arbitration 2 High Byte
           =5 SFR (CAN0IF2MCL, 0xCE);                // IF2 Message Control Low Byte
           =5 SFR (CAN0IF2MCH, 0xCF);                // IF2 Message Control High Byte
           =5 SFR (CAN0IF1MCL, 0xD2);                // IF1 Message Control Low Byte
           =5 SFR (CAN0IF1MCH, 0xD3);                // IF1 Message Control High Byte
           =5 SFR (CAN0IF1DA1L, 0xD4);               // IF1 Data A 1 Low Byte
           =5 SFR (CAN0IF1DA1H, 0xD5);               // IF1 Data A 1 High Byte
           =5 SFR (CAN0IF1DA2L, 0xD6);               // IF1 Data A 2 Low Byte
           =5 SFR (CAN0IF1DA2H, 0xD7);               // IF1 Data A 2 High Byte
           =5 SFR (CAN0IF1DB1L, 0xDA);               // IF1 Data B 1 Low Byte
           =5 SFR (CAN0IF1DB1H, 0xDB);               // IF1 Data B 1 High Byte
           =5 SFR (CAN0IF1DB2L, 0xDC);               // IF1 Data B 2 Low Byte
           =5 SFR (CAN0IF1DB2H, 0xDD);               // IF1 Data B 2 High Byte
           =5 SFR (CAN0IF2CRL, 0xDE);                // IF2 Command Request Low Byte
           =5 SFR (CAN0IF2CRH, 0xDF);                // IF2 Command Request High Byte
           =5 SFR (CAN0IF2CML, 0xE2);                // IF2 Command Mask Low Byte
           =5 SFR (CAN0IF2CMH, 0xE3);                // IF2 Command Mask High Byte
           =5 SFR (CAN0IF2M1L, 0xEA);                // IF2 Mask 1 Low Byte
           =5 SFR (CAN0IF2M1H, 0xEB);                // IF2 Mask 1 High Byte
           =5 SFR (CAN0IF2M2L, 0xEC);                // IF2 Mask 2 Low Byte
           =5 SFR (CAN0IF2M2H, 0xED);                // IF2 Mask 2 High Byte
           =5 SFR (CAN0IF2A1L, 0xEE);                // IF2 Arbitration 1 Low Byte
           =5 SFR (CAN0IF2A1H, 0xEF);                // IF2 Arbitration 1 High Byte
           =5 SFR (CAN0IF2A2L, 0xF2);                // IF2 Arbitration 2 Low Byte
           =5 SFR (CAN0IF2A2H, 0xF3);                // IF2 Arbitration 2 High Byte
           =5 SFR (CAN0IF2DA1L, 0xF6);               // IF2 Data A 1 Low Byte
           =5 SFR (CAN0IF2DA1H, 0xF7);               // IF2 Data A 1 High Byte
           =5 SFR (CAN0IF2DA2L, 0xFA);               // IF2 Data A 2 Low Byte
           =5 SFR (CAN0IF2DA2H, 0xFB);               // IF2 Data A 2 High Byte
           =5 SFR (CAN0IF2DB1L, 0xFC);               // IF2 Data B 1 Low Byte
           =5 SFR (CAN0IF2DB1H, 0xFD);               // IF2 Data B 1 High Byte
           =5 SFR (CAN0IF2DB2L, 0xFE);               // IF2 Data B 2 Low Byte
           =5 SFR (CAN0IF2DB2H, 0xFF);               // IF2 Data B 2 High Byte
           =5 
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 // 16-bit Register Definitions (might not be supported by all compilers)
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 SFR16 (DP, 0x82);                      // Data Pointer
           =5 SFR16 (TMR3RL, 0x92);                  // Timer 3 Reload
           =5 SFR16 (TMR5CAP, 0x92);                 // Timer 5 Capture
           =5 SFR16 (TMR3, 0x94);                    // Timer 3 Capture / Reload
           =5 SFR16 (TMR5, 0x94);                    // Timer 5
           =5 SFR16 (SBRL0, 0xAC);                   // UART0 Reload
           =5 SFR16 (ADC0, 0xBD);                    // ADC0 data
           =5 SFR16 (ADC0GT, 0xC3);                  // ADC0 Greater Than Window
           =5 SFR16 (ADC0LT, 0xC5);                  // ADC0 Less Than Window
           =5 SFR16 (TMR2RL, 0xCA);                  // Timer 2 Reload
           =5 SFR16 (TMR4CAP, 0xCA);                 // Timer 4 Capture
           =5 SFR16 (TMR2, 0xCC);                    // Timer 2 Capture / Reload
           =5 SFR16 (TMR4, 0xCC);                    // Timer 4
           =5 SFR16 (PCA0CP5, 0xCE);                 // PCA0 Module 5 Capture
           =5 SFR16 (PCA1CP11, 0xCE);                // PCA1 Module 11 Capture
           =5 SFR16 (PCA0CP1, 0xE9);                 // PCA0 Module 1 Capture
           =5 SFR16 (PCA1CP7, 0xE9);                 // PCA1 Module 7 Capture
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 40  

           =5 SFR16 (PCA0CP2, 0xEB);                 // PCA0 Module 2 Capture
           =5 SFR16 (PCA1CP8, 0xEB);                 // PCA1 Module 8 Capture
           =5 SFR16 (PCA0CP3, 0xED);                 // PCA0 Module 3 Capture
           =5 SFR16 (PCA1CP9, 0xED);                 // PCA1 Module 9 Capture
           =5 SFR16 (PCA0, 0xF9);                    // PCA0 Counter
           =5 SFR16 (PCA1, 0xF9);                    // PCA1 Counter
           =5 SFR16 (PCA0CP0, 0xFB);                 // PCA0 Module 0 Capture
           =5 SFR16 (PCA1CP6, 0xFB);                 // PCA1 Module 6 Capture
           =5 SFR16 (PCA0CP4, 0xFD);                 // PCA0 Module 4 Capture
           =5 SFR16 (PCA1CP10, 0xFD);                 // PCA1 Module 10 Capture
           =5 
           =5 SFR16 (CAN0ERR, 0x96);                 // Error Counter
           =5 SFR16 (CAN0BT, 0x9A);                  // Bit Timing Register
           =5 SFR16 (CAN0IID, 0x9C);                 // Interrupt Register
           =5 SFR16 (CAN0TR1, 0xA2);                 // Transmission Request 1
           =5 SFR16 (CAN0TR2, 0xA4);                 // Transmission Request 2
           =5 SFR16 (CAN0ND1, 0xAA);                 // New Data 1
           =5 SFR16 (CAN0ND2, 0xAC);                 // New Data 2
           =5 SFR16 (CAN0IP1, 0xAE);                 // Interrupt Pending 1
           =5 SFR16 (CAN0IP2, 0xB2);                 // Interrupt Pending 2
           =5 SFR16 (CAN0MV1, 0xBA);                 // Message Valid 1
           =5 SFR16 (CAN0MV2, 0xBC);                 // Message Valid 2
           =5 SFR16 (CAN0IF1CR, 0xBE);               // IF1 Command Request
           =5 SFR16 (CAN0IF1CM, 0xC2);               // IF1 Command Mask
           =5 SFR16 (CAN0IF1M1, 0xC4);               // IF1 Mask 1
           =5 SFR16 (CAN0IF1M2, 0xC6);               // IF1 Mask 2
           =5 SFR16 (CAN0IF1A1, 0xCA);               // IF1 Arbitration 1
           =5 SFR16 (CAN0IF1A2, 0xCC);               // IF1 Arbitration 2
           =5 SFR16 (CAN0IF1MC, 0xD2);               // IF1 Message Control
           =5 SFR16 (CAN0IF1DA1, 0xD4);              // IF1 Data A 1
           =5 SFR16 (CAN0IF1DA2, 0xD6);              // IF1 Data A 2
           =5 SFR16 (CAN0IF1DB1, 0xDA);              // IF1 Data B 1
           =5 SFR16 (CAN0IF1DB2, 0xDC);              // IF1 Data B 2
           =5 SFR16 (CAN0IF2CR, 0xDE);               // IF2 Command Request
           =5 SFR16 (CAN0IF2CM, 0xE2);               // IF2 Command Mask
           =5 SFR16 (CAN0IF2M1, 0xEA);               // IF2 Mask 1
           =5 SFR16 (CAN0IF2M2, 0xEC);               // IF2 Mask 2
           =5 SFR16 (CAN0IF2A1, 0xEE);               // IF2 Arbitration 1
           =5 SFR16 (CAN0IF2A2, 0xF2);               // IF2 Arbitration 2
           =5 SFR16 (CAN0IF2MC, 0xCE);               // IF2 Message Control
           =5 SFR16 (CAN0IF2DA1, 0xF6);              // IF2 Data A 1
           =5 SFR16 (CAN0IF2DA2, 0xFA);              // IF2 Data A 2
           =5 SFR16 (CAN0IF2DB1, 0xFC);              // IF2 Data B 1
           =5 SFR16 (CAN0IF2DB2, 0xFE);              // IF2 Data B 2
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 // LIN0 Indirect Registers
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 #define  LIN0DT1   0x00                // LIN0 Data Byte 1
           =5 #define  LIN0DT2   0x01                // LIN0 Data Byte 2
           =5 #define  LIN0DT3   0x02                // LIN0 Data Byte 3
           =5 #define  LIN0DT4   0x03                // LIN0 Data Byte 4
           =5 #define  LIN0DT5   0x04                // LIN0 Data Byte 5
           =5 #define  LIN0DT6   0x05                // LIN0 Data Byte 6
           =5 #define  LIN0DT7   0x06                // LIN0 Data Byte 7
           =5 #define  LIN0DT8   0x07                // LIN0 Data Byte 8
           =5 #define  LIN0CTRL  0x08                // LIN0 Control
           =5 #define  LIN0ST    0x09                // LIN0 Status
           =5 #define  LIN0ERR   0x0A                // LIN0 Error
           =5 #define  LIN0SIZE  0x0B                // LIN0 Message Size
           =5 #define  LIN0DIV   0x0C                // LIN0 Divider
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 41  

           =5 #define  LIN0MUL   0x0D                // LIN0 Multiplier
           =5 #define  LIN0ID    0x0E                // LIN0 Identifier
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 // Address Definitions for Bit-addressable Registers
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 #define SFR_P0       0x80
           =5 #define SFR_TCON     0x88
           =5 #define SFR_P1       0x90
           =5 #define SFR_SCON0    0x98
           =5 #define SFR_SCON1    0x98
           =5 #define SFR_P2       0xA0
           =5 #define SFR_IE       0xA8
           =5 #define SFR_P3       0xB0
           =5 #define SFR_IP       0xB8
           =5 #define SFR_SMB0CN   0xC0
           =5 #define SFR_TMR2CN   0xC8
           =5 #define SFR_TMR4CN   0xC8
           =5 #define SFR_PSW      0xD0
           =5 #define SFR_PCA0CN   0xD8
           =5 #define SFR_PCA1CN   0xD8
           =5 #define SFR_ACC      0xE0
           =5 #define SFR_ADC0CN   0xE8
           =5 #define SFR_B        0xF0
           =5 #define SFR_SPI0CN   0xF8
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 // Bit Definitions
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 // TCON 0x88
           =5 SBIT (TF1, SFR_TCON, 7);               // Timer 1 Overflow Flag
           =5 SBIT (TR1, SFR_TCON, 6);               // Timer 1 On/Off Control
           =5 SBIT (TF0, SFR_TCON, 5);               // Timer 0 Overflow Flag
           =5 SBIT (TR0, SFR_TCON, 4);               // Timer 0 On/Off Control
           =5 SBIT (IE1, SFR_TCON, 3);               // Ext. Interrupt 1 Edge Flag
           =5 SBIT (IT1, SFR_TCON, 2);               // Ext. Interrupt 1 Type
           =5 SBIT (IE0, SFR_TCON, 1);               // Ext. Interrupt 0 Edge Flag
           =5 SBIT (IT0, SFR_TCON, 0);               // Ext. Interrupt 0 Type
           =5 
           =5 // SCON0 0x98
           =5 SBIT (OVR0, SFR_SCON0, 7);             // UART0 Receive FIFO Overrun Flag
           =5 SBIT (PERR0, SFR_SCON0, 6);            // UART0 Parity Error Flag
           =5 SBIT (THRE0, SFR_SCON0, 5);            // UART0 Transmit Register Empty Flag
           =5 SBIT (REN0, SFR_SCON0, 4);             // UART0 RX Enable
           =5 SBIT (TBX0, SFR_SCON0, 3);             // UART0 Extra Transmission Bit
           =5 SBIT (RBX0, SFR_SCON0, 2);             // UART0 Extra Receive Bit
           =5 SBIT (TI0, SFR_SCON0, 1);              // UART0 TX Interrupt Flag
           =5 SBIT (RI0, SFR_SCON0, 0);              // UART0 RX Interrupt Flag
           =5 
           =5 // SCON1 0x98
           =5 SBIT (S1MODE, SFR_SCON1, 7);           // UART1 Mode 0
           =5                                        // Bit 6 UNUSED
           =5 SBIT (MCE1, SFR_SCON1, 5);             // UART1 Multiprocessor enable
           =5 SBIT (REN1, SFR_SCON1, 4);             // UART1 RX Enable
           =5 SBIT (TB81, SFR_SCON1, 3);             // UART1 TX Bit 8
           =5 SBIT (RB81, SFR_SCON1, 2);             // UART1 RX Bit 8
           =5 SBIT (TI1, SFR_SCON1, 1);              // UART1 TX Interrupt Flag
           =5 SBIT (RI1, SFR_SCON1, 0);              // UART1 RX Interrupt Flag
           =5 
           =5 // IE 0xA8
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 42  

           =5 SBIT (EA, SFR_IE, 7);                  // Global Interrupt Enable
           =5 SBIT (ESPI0, SFR_IE, 6);               // SPI0 Interrupt Enable
           =5 SBIT (ET2, SFR_IE, 5);                 // Timer 2 Interrupt Enable
           =5 SBIT (ES0, SFR_IE, 4);                 // UART0 Interrupt Enable
           =5 SBIT (ET1, SFR_IE, 3);                 // Timer 1 Interrupt Enable
           =5 SBIT (EX1, SFR_IE, 2);                 // External Interrupt 1 Enable
           =5 SBIT (ET0, SFR_IE, 1);                 // Timer 0 Interrupt Enable
           =5 SBIT (EX0, SFR_IE, 0);                 // External Interrupt 0 Enable
           =5 
           =5 // IP 0xB8
           =5                                        // Bit 7 unused
           =5 SBIT (PSPI0, SFR_IP, 6);               // SPI0 Interrupt Priority
           =5 SBIT (PT2, SFR_IP, 5);                 // Timer 2 Priority
           =5 SBIT (PS0, SFR_IP, 4);                 // UART0 Priority
           =5 SBIT (PS, SFR_IP, 4);                  // UART0 Priority
           =5 SBIT (PT1, SFR_IP, 3);                 // Timer 1 Priority
           =5 SBIT (PX1, SFR_IP, 2);                 // External Interrupt 1 Priority
           =5 SBIT (PT0, SFR_IP, 1);                 // Timer 0 Priority
           =5 SBIT (PX0, SFR_IP, 0);                 // External Interrupt 0 Priority
           =5 
           =5 // SMB0CN 0xC0
           =5 SBIT (MASTER, SFR_SMB0CN, 7);          // SMBus0 Master/Slave Indicator
           =5 SBIT (TXMODE, SFR_SMB0CN, 6);          // SMBus0 Transmit Mode Indicator
           =5 SBIT (STA, SFR_SMB0CN, 5);             // SMBus0 Start Flag
           =5 SBIT (STO, SFR_SMB0CN, 4);             // SMBus0 Stop Flag
           =5 SBIT (ACKRQ, SFR_SMB0CN, 3);           // SMBus0 Acknowledge Request
           =5 SBIT (ARBLOST, SFR_SMB0CN, 2);         // SMBus0 Arbitration Lost Indicator
           =5 SBIT (ACK, SFR_SMB0CN, 1);             // SMBus0 Acknowledge
           =5 SBIT (SI, SFR_SMB0CN, 0);              // SMBus0 Interrupt Flag
           =5 
           =5 // TMR2CN 0xC8
           =5 SBIT (TF2H, SFR_TMR2CN, 7);            // Timer 2 High-Byte Overflow Flag
           =5 SBIT (TF2L, SFR_TMR2CN, 6);            // Timer 2 Low-Byte  Overflow Flag
           =5 SBIT (TF2LEN, SFR_TMR2CN, 5);          // Timer 2 Low-Byte Flag Enable
           =5 SBIT (TF2CEN, SFR_TMR2CN, 4);          // Timer 2 Capture Enable
           =5 SBIT (T2SPLIT, SFR_TMR2CN, 3);         // Timer 2 Split-Mode Enable
           =5 SBIT (TR2, SFR_TMR2CN, 2);             // Timer 2 Run Enable
           =5 SBIT (T2RCLK, SFR_TMR2CN, 1);          // Timer 2 Xclk/Rclk Select
           =5 SBIT (T2XCLK, SFR_TMR2CN, 0);          // Timer 2 Clk/8 Clock Source
           =5 
           =5 // TMR4CN 0xC8
           =5 SBIT (TF4, SFR_TMR4CN, 7);             // Timer 4 Overflow/Underflow Flag
           =5 SBIT (EXF4, SFR_TMR4CN, 6);            // Timer 4 External Flag
           =5                                        // Bit 5 unused
           =5                                        // Bit 4 unused
           =5 SBIT (EXE4, SFR_TMR4CN, 3);            // Timer 4 External Enable
           =5 SBIT (TR4, SFR_TMR4CN, 2);             // Timer 4 Run Enable
           =5 SBIT (CT4, SFR_TMR4CN, 1);             // Timer 4 Counter/Timer Select
           =5 SBIT (CPRL4, SFR_TMR4CN, 0);           // Timer 4 Capture/Reload Select
           =5 
           =5 // PSW 0xD0
           =5 SBIT (CY, SFR_PSW, 7);                 // Carry Flag
           =5 SBIT (AC, SFR_PSW, 6);                 // Auxiliary Carry Flag
           =5 SBIT (F0, SFR_PSW, 5);                 // User Flag 0
           =5 SBIT (RS1, SFR_PSW, 4);                // Register Bank Select 1
           =5 SBIT (RS0, SFR_PSW, 3);                // Register Bank Select 0
           =5 SBIT (OV, SFR_PSW, 2);                 // Overflow Flag
           =5 SBIT (F1, SFR_PSW, 1);                 // User Flag 1
           =5 SBIT (P, SFR_PSW, 0);                  // Accumulator Parity Flag
           =5 
           =5 // PCA0CN 0xD8
           =5 SBIT (CF, SFR_PCA0CN, 7);              // PCA0 Counter Overflow Flag
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 43  

           =5 SBIT (CR, SFR_PCA0CN, 6);              // PCA0 Counter Run Control Bit
           =5 SBIT (CCF5, SFR_PCA0CN, 5);            // PCA0 Module 5 Interrupt Flag
           =5 SBIT (CCF4, SFR_PCA0CN, 4);            // PCA0 Module 4 Interrupt Flag
           =5 SBIT (CCF3, SFR_PCA0CN, 3);            // PCA0 Module 3 Interrupt Flag
           =5 SBIT (CCF2, SFR_PCA0CN, 2);            // PCA0 Module 2 Interrupt Flag
           =5 SBIT (CCF1, SFR_PCA0CN, 1);            // PCA0 Module 1 Interrupt Flag
           =5 SBIT (CCF0, SFR_PCA0CN, 0);            // PCA0 Module 0 Interrupt Flag
           =5 
           =5 // PCA1CN 0xD8
           =5 SBIT (CF1, SFR_PCA1CN, 7);             // PCA1 Counter Overflow Flag
           =5 SBIT (CR1, SFR_PCA1CN, 6);             // PCA1 Counter Run Control Bit
           =5 SBIT (CCF11, SFR_PCA1CN, 5);           // PCA1 Module 11 Interrupt Flag
           =5 SBIT (CCF10, SFR_PCA1CN, 4);           // PCA1 Module 10 Interrupt Flag
           =5 SBIT (CCF9, SFR_PCA1CN, 3);            // PCA1 Module 9 Interrupt Flag
           =5 SBIT (CCF8, SFR_PCA1CN, 2);            // PCA1 Module 8 Interrupt Flag
           =5 SBIT (CCF7, SFR_PCA1CN, 1);            // PCA1 Module 7 Interrupt Flag
           =5 SBIT (CCF6, SFR_PCA1CN, 0);            // PCA1 Module 6 Interrupt Flag
           =5 
           =5 // ADC0CN 0xE8
           =5 SBIT (AD0EN, SFR_ADC0CN, 7);           // ADC0 Enable
           =5 SBIT (BURSTEN, SFR_ADC0CN, 6);         // ADC0 Burst Enable
           =5 SBIT (AD0INT, SFR_ADC0CN, 5);          // ADC0 EOC Interrupt Flag
           =5 SBIT (AD0BUSY, SFR_ADC0CN, 4);         // ADC0 Busy Flag
           =5 SBIT (AD0WINT, SFR_ADC0CN, 3);         // ADC0 Window Compare Interrupt Flag
           =5 SBIT (AD0LJST, SFR_ADC0CN, 2);         // ADC0 Left Justified
           =5 SBIT (AD0CM1, SFR_ADC0CN, 1);          // ADC0 Start Of Conversion Mode Bit 1
           =5 SBIT (AD0CM0, SFR_ADC0CN, 0);          // ADC0 Start Of Conversion Mode Bit 0
           =5 
           =5 // SPI0CN 0xF8
           =5 SBIT (SPIF, SFR_SPI0CN, 7);            // SPI0 Interrupt Flag
           =5 SBIT (WCOL, SFR_SPI0CN, 6);            // SPI0 Write Collision Flag
           =5 SBIT (MODF, SFR_SPI0CN, 5);            // SPI0 Mode Fault Flag
           =5 SBIT (RXOVRN, SFR_SPI0CN, 4);          // SPI0 RX Overrun Flag
           =5 SBIT (NSSMD1, SFR_SPI0CN, 3);          // SPI0 Slave Select Mode 1
           =5 SBIT (NSSMD0, SFR_SPI0CN, 2);          // SPI0 Slave Select Mode 0
           =5 SBIT (TXBMT, SFR_SPI0CN, 1);           // SPI0 TX Buffer Empty Flag
           =5 SBIT (SPIEN, SFR_SPI0CN, 0);           // SPI0 Enable
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 // Interrupt Priorities
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 #define INTERRUPT_INT0             0   // External Interrupt 0
           =5 #define INTERRUPT_TIMER0           1   // Timer 0 Overflow
           =5 #define INTERRUPT_INT1             2   // External Interrupt 1
           =5 #define INTERRUPT_TIMER1           3   // Timer 1 Overflow
           =5 #define INTERRUPT_UART0            4   // UART0
           =5 #define INTERRUPT_TIMER2           5   // Timer 2 Overflow
           =5 #define INTERRUPT_SPI0             6   // SPI0
           =5 #define INTERRUPT_SMBUS0           7   // SMBus0 Interface
           =5 #define INTERRUPT_ADC0_WINDOW      8   // ADC0 Window Comparison
           =5 #define INTERRUPT_ADC0_EOC         9   // ADC0 End Of Conversion
           =5 #define INTERRUPT_PCA0            10   // PCA0 Peripheral
           =5 #define INTERRUPT_COMPARATOR0     11   // Comparator 0 Comparison
           =5 #define INTERRUPT_COMPARATOR1     12   // Comparator 1 Comparison
           =5 #define INTERRUPT_TIMER3          13   // Timer 3 Overflow
           =5 #define INTERRUPT_LIN0            14   // LIN Bus Interrupt
           =5 #define INTERRUPT_VREG            15   // Voltage Regulator
           =5 #define INTERRUPT_CAN0            16   // CAN Bus Interrupt
           =5 #define INTERRUPT_PORT_MATCH      17   // Port Match
           =5 #define INTERRUPT_UART1           18   // UART1
           =5 #define INTERRUPT_PCA1            19   // PCA1 Peripheral
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 44  

           =5 #define INTERRUPT_COMPARATOR2     20   // Comparator 2 Comparison
           =5 #define INTERRUPT_TIMER4          21   // Timer 4 Overflow
           =5 #define INTERRUPT_TIMER5          22   // Timer 5 Overflow
           =5 
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 // SFR Page Definitions
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 #define  CONFIG_PAGE       0x0F        // System and Port Configuration Page
           =5 #define  ACTIVE_PAGE       0x00        // Active Use Page
           =5 #define  ACTIVE2_PAGE      0x10        // Active Use Page 2
           =5 #define  CAN0_PAGE         0x0C        // CAN0 Registers
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 // SDCC PDATA External Memory Paging Support
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 #if defined SDCC
           =5 
           =5 SFR(_XPAGE, 0xAA); // Point to the EMI0CN register
           =5 
           =5 #endif
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 // Header File PreProcessor Directive
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 #endif                                 // #define C8051F580_DEFS_H
 607      =5  
 608      =5  //-----------------------------------------------------------------------------
 609      =5  // End Of File
 610      =5  //-----------------------------------------------------------------------------
   9      =4  void SYSCLK_Init(void);
  10      =4  #endif
   9      =3  #include "Dio.h"
   1      =4  /*
   2      =4   *  Created on: Apr 21, 2025
   3      =4   *      Author: Hoangtd2000
   4      =4   */
   5      =4  #ifndef _DIO_H_
           =4 #define _DIO_H_
           =4 #include <compiler_defs.h>
           =4 #include <C8051F580_defs.h> // SFR declarations
           =4 
           =4 #define SET 1U
           =4 #define RESET 0U
           =4 
           =4 #define PRESS 0U
           =4 #define RELEASE 1U
           =4 
           =4 SBIT(LED_G, SFR_P2, 1);
           =4 SBIT(LED_Y, SFR_P2, 0);
           =4 SBIT(SW2, SFR_P1, 2);
           =4 typedef enum
           =4 {
           =4     LED_GREEN,
           =4     LED_YELLOW
           =4 } Led_e;
           =4 
           =4 void PORT_Init(void);
           =4 void Tonggle(Led_e led);
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 45  

           =4 U8 Get_Button_state(void);
           =4 void External_Interrupt_Init(void);
           =4 void Ext0_Set_Callback_Ptr(void (*funct)(void));
           =4 #endif
  10      =3  #include "Timer.h"
   1      =4  /*
   2      =4   *  Created on: Apr 21, 2025
   3      =4   *      Author: Hoangtd2000
   4      =4   */
   5      =4  #ifndef _TIMER_H_
   6      =4  #define _TIMER_H_
   7      =4  #include <compiler_defs.h>
   1      =5  //-----------------------------------------------------------------------------
   2      =5  // compiler_defs.h
   3      =5  //-----------------------------------------------------------------------------
   4      =5  // Portions of this file are copyright Maarten Brock
   5      =5  // http://sdcc.sourceforge.net
   6      =5  // Portions of this file are copyright 2010, Silicon Laboratories, Inc.
   7      =5  // http://www.silabs.com
   8      =5  //
   9      =5  // GNU LGPL boilerplate:
  10      =5  /** This library is free software; you can redistribute it and/or
  11      =5    * modify it under the terms of the GNU Lesser General Public
  12      =5    * License as published by the Free Software Foundation; either
  13      =5    * version 2.1 of the License, or (at your option) any later version.
  14      =5    *
  15      =5    * This library is distributed in the hope that it will be useful,
  16      =5    * but WITHOUT ANY WARRANTY; without even the implied warranty of
  17      =5    * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  18      =5    * Lesser General Public License for more details.
  19      =5    *
  20      =5    * You should have received a copy of the GNU Lesser General Public
  21      =5    * License along with this library; if not, write to the Free Software
  22      =5    * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  23      =5    *
  24      =5    * In other words, you are welcome to use, share and improve this program.
  25      =5    * You are forbidden to forbid anyone else to use, share and improve
  26      =5    * what you give them. Help stamp out software-hoarding!
  27      =5  **/
  28      =5  // Program Description:
  29      =5  //
  30      =5  // **Important Note**: This header file should be included before including
  31      =5  // a device-specific header file such as C8051F300_defs.h.
  32      =5  //
  33      =5  // Macro definitions to accomodate 8051 compiler differences in specifying
  34      =5  // special function registers and other 8051-specific features such as NOP
  35      =5  // generation, and locating variables in memory-specific segments.  The
  36      =5  // compilers are identified by their unique predefined macros. See also:
  37      =5  // http://predef.sourceforge.net/precomp.html
  38      =5  //
  39      =5  // SBIT and SFR define special bit and special function registers at the given
  40      =5  // address. SFR16 and SFR32 define sfr combinations at adjacent addresses in
  41      =5  // little-endian format. SFR16E and SFR32E define sfr combinations without
  42      =5  // prerequisite byte order or adjacency. None of these multi-byte sfr
  43      =5  // combinations will guarantee the order in which they are accessed when read
  44      =5  // or written.
  45      =5  //
  46      =5  // SFR16X and SFR32X for 16 bit and 32 bit xdata registers are not defined
  47      =5  // to avoid portability issues because of compiler endianness.
  48      =5  //
  49      =5  // Example:
  50      =5  // // my_mcu.c: main 'c' file for my mcu
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 46  

  51      =5  // #include <compiler_defs.h>  // this file
  52      =5  // #include <C8051xxxx_defs.h> // SFR definitions for specific MCU target
  53      =5  //
  54      =5  // SBIT  (P0_1, 0x80, 1);      // Port 0 pin 1
  55      =5  // SFR   (P0, 0x80);           // Port 0
  56      =5  // SFRX  (CPUCS, 0xE600);      // Cypress FX2 Control and Status register in
  57      =5  //                             // xdata memory at 0xE600
  58      =5  // SFR16 (TMR2, 0xCC);         // Timer 2, lsb at 0xCC, msb at 0xCD
  59      =5  // SFR16E(TMR0, 0x8C8A);       // Timer 0, lsb at 0x8A, msb at 0x8C
  60      =5  // SFR32 (MAC0ACC, 0x93);      // SiLabs C8051F120 32 bits MAC0 Accumulator,
  61      =5  //                             // lsb at 0x93, msb at 0x96
  62      =5  // SFR32E(SUMR, 0xE5E4E3E2);   // TI MSC1210 SUMR 32 bits Summation register,
  63      =5  //                             // lsb at 0xE2, msb at 0xE5
  64      =5  //
  65      =5  // Target:         C8051xxxx
  66      =5  // Tool chain:     Generic
  67      =5  // Command Line:   None
  68      =5  // 
  69      =5  // Release 2.6 - 14 DEC 2012 (GO)
  70      =5  //        -Added define for deprecated SDCC keyword 'at'
  71      =5  // Release 2.5 - 12 SEP 2012 (TP)
  72      =5  //    -Added defines for deprecated SDCC keywords bit and code
  73      =5  // Release 2.4 - 27 AUG 2012 (TP)
  74      =5  //    -Added defines for deprecated SDCC keywords interrupt, _asm, and _endasm
  75      =5  // Release 2.3 - 27 MAY 2010 (DM)
  76      =5  //    -Removed 'LOCATED_VARIABLE' pragma from Keil because it is not supported
  77      =5  // Release 2.2 - 06 APR 2010 (ES)
  78      =5  //    -Removed 'PATHINCLUDE' pragma from Raisonance section
  79      =5  // Release 2.1 - 16 JUL 2009 (ES)
  80      =5  //    -Added SEGMENT_POINTER macro definitions for SDCC, Keil, and Raisonance
  81      =5  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for Raisonance
  82      =5  // Release 2.0 - 19 MAY 2009 (ES)
  83      =5  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for SDCC and Keil
  84      =5  // Release 1.9 - 23 OCT 2008 (ES)
  85      =5  //    -Updated Hi-Tech INTERRUPT and INTERRUPT_USING macro definitions
  86      =5  //    -Added SFR16 macro defintion for Hi-Tech
  87      =5  // Release 1.8 - 31 JUL 2008 (ES)
  88      =5  //    -Added INTERRUPT_USING and FUNCTION_USING macro's
  89      =5  //    -Added macro's for IAR
  90      =5  //    -Corrected Union definitions for Hi-Tech and added SFR16 macro defintion
  91      =5  // Release 1.7 - 11 SEP 2007 (BW)
  92      =5  //    -Added support for Raisonance EVAL 03.03.42 and Tasking Eval 7.2r1
  93      =5  // Release 1.6 - 27 AUG 2007 (BW)
  94      =5  //    -Updated copyright notice per agreement with Maartin Brock
  95      =5  //    -Added SDCC 2.7.0 "compiler.h" bug fixes
  96      =5  //    -Added memory segment defines (SEG_XDATA, for example)
  97      =5  // Release 1.5 - 24 AUG 2007 (BW)
  98      =5  //    -Added support for NOP () macro
  99      =5  //    -Added support for Hi-Tech ver 9.01
 100      =5  // Release 1.4 - 07 AUG 2007 (PKC)
 101      =5  //    -Removed FID and fixed formatting.
 102      =5  // Release 1.3 - 30 SEP 2007 (TP)
 103      =5  //    -Added INTERRUPT_PROTO_USING to properly support ISR context switching
 104      =5  //     under SDCC.
 105      =5  // Release 1.2 - (BW)
 106      =5  //    -Added support for U8,U16,U32,S8,S16,S32,UU16,UU32 data types
 107      =5  // Release 1.1 - (BW)
 108      =5  //    -Added support for INTERRUPT, INTERRUPT_USING, INTERRUPT_PROTO,
 109      =5  //     SEGMENT_VARIABLE, VARIABLE_SEGMENT_POINTER,
 110      =5  //     SEGMENT_VARIABLE_SEGMENT_POINTER, and LOCATED_VARIABLE
 111      =5  // Release 1.0 - 29 SEP 2006 (PKC)
 112      =5  //    -Initial revision
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 47  

 113      =5  
 114      =5  //-----------------------------------------------------------------------------
 115      =5  // Header File Preprocessor Directive
 116      =5  //-----------------------------------------------------------------------------
 117      =5  
 118      =5  #ifndef COMPILER_DEFS_H
           =5 #define COMPILER_DEFS_H
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 // Macro definitions
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 // SDCC - Small Device C Compiler
           =5 // http://sdcc.sourceforge.net
           =5 
           =5 #if defined SDCC
           =5 
           =5 #if (SDCC >= 300)
           =5 
           =5 #define interrupt __interrupt
           =5 #define _asm __asm
           =5 #define _endasm __endasm
           =5 #define bit __bit
           =5 #define code __code
           =5 #define at __at
           =5 
           =5 #endif
           =5 
           =5 # define SEG_GENERIC
           =5 # define SEG_FAR   __xdata
           =5 # define SEG_DATA  __data
           =5 # define SEG_NEAR  __data
           =5 # define SEG_IDATA __idata
           =5 # define SEG_XDATA __xdata
           =5 # define SEG_PDATA __pdata
           =5 # define SEG_CODE  __code
           =5 # define SEG_BDATA __bdata
           =5 
           =5 # define SBIT(name, addr, bit)  __sbit  __at(addr+bit)                  name
           =5 # define SFR(name, addr)        __sfr   __at(addr)                      name
           =5 # define SFRX(name, addr)       xdata volatile unsigned char __at(addr) name
           =5 # define SFR16(name, addr)      __sfr16 __at(((addr+1U)<<8) | addr)     name
           =5 # define SFR16E(name, fulladdr) __sfr16 __at(fulladdr)                  name
           =5 # define SFR32(name, addr)      __sfr32 __at(((addr+3UL)<<24) | ((addr+2UL)<<16) | ((addr+1UL)<<8) | addr)
             - name
           =5 # define SFR32E(name, fulladdr) __sfr32 __at(fulladdr)                  name
           =5 
           =5 # define INTERRUPT(name, vector) void name (void) interrupt (vector)
           =5 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =5 # define INTERRUPT_PROTO(name, vector) void name (void) interrupt (vector)
           =5 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =5 
           =5 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using (regnum
             -)
           =5 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter) using (
             -regnum)
           =5 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =5 
           =5 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =5 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =5 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 48  

           =5 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =5 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment at (addr) vartype name = init
           =5 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) locsegment at (addr) vartype name
           =5 
           =5 // used with UU16
           =5 # define LSB 0
           =5 # define MSB 1
           =5 
           =5 // used with UU32 (b0 is least-significant byte)
           =5 # define b0 0
           =5 # define b1 1
           =5 # define b2 2
           =5 # define b3 3
           =5 
           =5 typedef unsigned char U8;
           =5 typedef unsigned int U16;
           =5 typedef unsigned long U32;
           =5 
           =5 typedef signed char S8;
           =5 typedef signed int S16;
           =5 typedef signed long S32;
           =5 
           =5 typedef union UU16
           =5 {
           =5    U16 U16;
           =5    S16 S16;
           =5    U8 U8[2];
           =5    S8 S8[2];
           =5 } UU16;
           =5 
           =5 typedef union UU32
           =5 {
           =5    U32 U32;
           =5    S32 S32;
           =5    UU16 UU16[2];
           =5    U16 U16[2];
           =5    S16 S16[2];
           =5    U8 U8[4];
           =5    S8 S8[4];
           =5 } UU32;
           =5 
           =5 // NOP () macro support
           =5 #define NOP() _asm NOP _endasm
           =5 
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 // Raisonance (must be placed before Keil C51)
           =5 // http://www.raisonance.com
           =5 
           =5 #elif defined __RC51__
           =5 
           =5 //#error Raisonance C51 detected.
           =5 
           =5 # define SEG_GENERIC generic     //SEG_GENERIC only applies to pointers in Raisonance, not variables.
           =5 # define SEG_FAR   xdata
           =5 # define SEG_DATA  data
           =5 # define SEG_NEAR  data
           =5 # define SEG_IDATA idata
           =5 # define SEG_XDATA xdata
           =5 # define SEG_PDATA pdata
           =5 # define SEG_CODE  code
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 49  

           =5 # define SEG_BDATA bdata
           =5 
           =5 # define SBIT(name, addr, bit)  at (addr+bit) sbit         name
           =5 # define SFR(name, addr)        sfr at addr                name
           =5 # define SFR16(name, addr)      sfr16 at addr              name
           =5 # define SFR16E(name, fulladdr) /* not supported */
           =5 # define SFR32(name, fulladdr)  /* not supported */
           =5 # define SFR32E(name, fulladdr) /* not supported */
           =5 
           =5 # define INTERRUPT(name, vector) void name (void) interrupt vector
           =5 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =5 # define INTERRUPT_PROTO(name, vector) void name (void)
           =5 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =5 
           =5 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
           =5 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =5 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =5 
           =5 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =5 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =5 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =5 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =5 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) at addr locsegment vartype name
           =5 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) at addr locsegment vartype name
           =5 
           =5 
           =5 // used with UU16
           =5 # define LSB 1
           =5 # define MSB 0
           =5 
           =5 // used with UU32 (b0 is least-significant byte)
           =5 # define b0 3
           =5 # define b1 2
           =5 # define b2 1
           =5 # define b3 0
           =5 
           =5 typedef unsigned char U8;
           =5 typedef unsigned int U16;
           =5 typedef unsigned long U32;
           =5 
           =5 typedef signed char S8;
           =5 typedef signed int S16;
           =5 typedef signed long S32;
           =5 
           =5 typedef union UU16
           =5 {
           =5    U16 U16;
           =5    S16 S16;
           =5    U8 U8[2];
           =5    S8 S8[2];
           =5 } UU16;
           =5 
           =5 typedef union UU32
           =5 {
           =5    U32 U32;
           =5    S32 S32;
           =5    UU16 UU16[2];
           =5    U16 U16[2];
           =5    S16 S16[2];
           =5    U8 U8[4];
           =5    S8 S8[4];
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 50  

           =5 } UU32;
           =5 
           =5 // NOP () macro support -- NOP is opcode 0x00
           =5 #define NOP() asm { 0x00 }
           =5 
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 
           =5 // Keil C51
           =5 // http://www.keil.com
           =5 
           =5 #elif defined __C51__
           =5 
           =5 //#error Keil C51 detected.
           =5 
           =5 # define SEG_GENERIC
           =5 # define SEG_FAR   xdata
           =5 # define SEG_DATA  data
           =5 # define SEG_NEAR  data
           =5 # define SEG_IDATA idata
           =5 # define SEG_XDATA xdata
           =5 # define SEG_PDATA pdata
           =5 # define SEG_CODE  code
           =5 # define SEG_BDATA bdata
           =5 
           =5 # define SBIT(name, addr, bit)  sbit  name = addr^bit
           =5 # define SFR(name, addr)        sfr   name = addr
           =5 # define SFR16(name, addr)      sfr16 name = addr
           =5 # define SFR16E(name, fulladdr) /* not supported */
           =5 # define SFR32(name, fulladdr)  /* not supported */
           =5 # define SFR32E(name, fulladdr) /* not supported */
           =5 
           =5 # define INTERRUPT(name, vector) void name (void) interrupt vector
           =5 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =5 # define INTERRUPT_PROTO(name, vector) void name (void)
           =5 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =5 
           =5 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
           =5 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =5 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =5 
           =5 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =5 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =5 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =5 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =5 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) vartype locsegment name _at_ addr
           =5 
           =5 // used with UU16
           =5 # define LSB 1
           =5 # define MSB 0
           =5 
           =5 // used with UU32 (b0 is least-significant byte)
           =5 # define b0 3
           =5 # define b1 2
           =5 # define b2 1
           =5 # define b3 0
           =5 
           =5 typedef unsigned char U8;
           =5 typedef unsigned int U16;
           =5 typedef unsigned long U32;
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 51  

           =5 
           =5 typedef signed char S8;
           =5 typedef signed int S16;
           =5 typedef signed long S32;
           =5 
           =5 typedef union UU16
           =5 {
           =5    U16 U16;
           =5    S16 S16;
           =5    U8 U8[2];
           =5    S8 S8[2];
           =5 } UU16;
           =5 
           =5 typedef union UU32
           =5 {
           =5    U32 U32;
           =5    S32 S32;
           =5    UU16 UU16[2];
           =5    U16 U16[2];
           =5    S16 S16[2];
           =5    U8 U8[4];
           =5    S8 S8[4];
           =5 } UU32;
           =5 
           =5 // NOP () macro support
           =5 extern void _nop_ (void);
           =5 #define NOP() _nop_()
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 // Hi-Tech 8051
           =5 // http://www.htsoft.com
           =5 
           =5 #elif defined HI_TECH_C
           =5 
           =5 # define SEG_GENERIC
           =5 # define SEG_FAR   far
           =5 # define SEG_DATA  data
           =5 # define SEG_NEAR  near
           =5 # define SEG_IDATA idata
           =5 # define SEG_XDATA xdata
           =5 # define SEG_PDATA pdata
           =5 # define SEG_CODE  code
           =5 # define SEG_BDATA bdata
           =5 
           =5 
           =5 # define SBIT(name, addr, thebit) static volatile bit name @ (addr + thebit)
           =5 # define SFR(name, addr)          static volatile unsigned char name @ addr
           =5 # define SFR16(name, addr)        static volatile unsigned int name @ addr
           =5 # define SFR16E(name, fulladdr) /* not supported */
           =5 # define SFR32(name, fulladdr)  /* not supported */
           =5 # define SFR32E(name, fulladdr) /* not supported */
           =5 
           =5 # define INTERRUPT(name, vector)       void name (void) interrupt vector
           =5 # define INTERRUPT_PROTO(name, vector)
           =5 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =5 # define INTERRUPT_PROTO_USING(name, vector, regnum)
           =5 
           =5 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =5 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =5 // Note: Hi-Tech does not support functions using different register banks. Register
           =5 //       banks can only be specified in interrupts. If a function is called from
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 52  

           =5 //       inside an interrupt, it will use the same register bank as the interrupt.
           =5 
           =5 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =5 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =5 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =5 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment vartype name @ addr
           =5 
           =5 // used with UU16
           =5 # define LSB 0
           =5 # define MSB 1
           =5 
           =5 // used with UU32 (b0 is least-significant byte)
           =5 # define b0 0
           =5 # define b1 1
           =5 # define b2 2
           =5 # define b3 3
           =5 
           =5 typedef unsigned char U8;
           =5 typedef unsigned int U16;
           =5 typedef unsigned long U32;
           =5 
           =5 typedef signed char S8;
           =5 typedef signed int S16;
           =5 typedef signed long S32;
           =5 
           =5 typedef union UU16
           =5 {
           =5    U16 U16;
           =5    S16 S16;
           =5    U8 U8[2];
           =5    S8 S8[2];
           =5 } UU16;
           =5 
           =5 typedef union UU32
           =5 {
           =5    U32 U32;
           =5    S32 S32;
           =5    UU16 UU16[2];
           =5    U16 U16[2];
           =5    S16 S16[2];
           =5    U8 U8[4];
           =5    S8 S8[4];
           =5 } UU32;
           =5 
           =5 // NOP () macro support
           =5 #define NOP() asm(" nop ")
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 // Tasking / Altium
           =5 // http://www.altium.com/tasking
           =5 
           =5 
           =5 #elif defined _CC51
           =5 
           =5 # define SEG_GENERIC
           =5 # define SEG_FAR   _xdat
           =5 # define SEG_DATA  _data
           =5 # define SEG_NEAR  _data
           =5 # define SEG_IDATA _idat
           =5 # define SEG_XDATA _xdat
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 53  

           =5 # define SEG_PDATA _pdat
           =5 # define SEG_CODE  _rom
           =5 # define SEG_BDATA _bdat
           =5 
           =5 # define SBIT(name, addr, bit)  _sfrbit  name _at(addr+bit)
           =5 # define SFR(name, addr)        _sfrbyte name _at(addr)
           =5 # define SFRX(name, addr)       _xdat volatile unsigned char name _at(addr)
           =5 #if _CC51 > 71
           =5 # define SFR16(name, addr)      _sfrword _little name _at(addr)
           =5 #else
           =5 # define SFR16(name, addr)      /* not supported */
           =5 #endif
           =5 # define SFR16E(name, fulladdr) /* not supported */
           =5 # define SFR32(name, fulladdr)  /* not supported */
           =5 # define SFR32E(name, fulladdr) /* not supported */
           =5 
           =5 # define INTERRUPT(name, vector) _interrupt (vector) void name (void)
           =5 # define INTERRUPT_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =5 # define INTERRUPT_PROTO(name, vector) _interrupt (vector) void name (void)
           =5 # define INTERRUPT_PROTO_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =5 
           =5 // When calling FUNCTION_USING in Tasking, the function must be called from an interrupt or Main which
           =5 // is also using the same register bank. If not, the compiler will generate an error.
           =5 # define FUNCTION_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (parameter
             -)
           =5 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (par
             -ameter)
           =5 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =5 
           =5 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =5 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =5 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =5 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) vartype locsegment name _at( addr )
           =5 
           =5 // used with UU16
           =5 # define LSB 1
           =5 # define MSB 0
           =5 
           =5 // used with UU32 (b0 is least-significant byte)
           =5 # define b0 3
           =5 # define b1 2
           =5 # define b2 1
           =5 # define b3 0
           =5 
           =5 typedef unsigned char U8;
           =5 typedef unsigned int U16;
           =5 typedef unsigned long U32;
           =5 
           =5 typedef signed char S8;
           =5 typedef signed int S16;
           =5 typedef signed long S32;
           =5 
           =5 typedef union UU16
           =5 {
           =5    U16 U16;
           =5    S16 S16;
           =5    U8 U8[2];
           =5    S8 S8[2];
           =5 } UU16;
           =5 
           =5 typedef union UU32
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 54  

           =5 {
           =5    U32 U32;
           =5    S32 S32;
           =5    UU16 UU16[2];
           =5    U16 U16[2];
           =5    S16 S16[2];
           =5    U8 U8[4];
           =5    S8 S8[4];
           =5 } UU32;
           =5 
           =5 // NOP () macro support
           =5 extern void _nop (void);
           =5 #define NOP() _nop()
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 
           =5 // IAR 8051
           =5 // http://www.iar.com
           =5 
           =5 #elif defined __ICC8051__
           =5 
           =5 #include <stdbool.h>
           =5 #include <intrinsics.h>
           =5 
           =5 # define SBIT(name, addr, bit)  __bit __no_init volatile bool name @ (addr+bit)
           =5 # define SFR(name, addr)        __sfr __no_init volatile unsigned char name @ addr
           =5 # define SFRX(name, addr)       __xdata __no_init volatile unsigned char name @ addr
           =5 # define SFR16(name, addr)      __sfr __no_init volatile unsigned int  name @ addr
           =5 # define SFR16E(name, fulladdr) /* not supported */
           =5 # define SFR32(name, fulladdr) /* not supported */
           =5 # define SFR32E(name, fulladdr) /* not supported */
           =5 
           =5 # define SEG_GENERIC __generic
           =5 # define SEG_FAR  __xdata
           =5 # define SEG_DATA __data
           =5 # define SEG_NEAR __data
           =5 # define SEG_IDATA __idata
           =5 # define SEG_XDATA __xdata
           =5 # define SEG_PDATA __pdata
           =5 # define SEG_CODE  __code
           =5 # define SEG_BDATA __bdata
           =5 
           =5 #define bit bool
           =5 
           =5 # define _PPTOSTR_(x) #x
           =5 # define _PPARAM_(address) _PPTOSTR_(vector=address * 8 + 3)
           =5 # define _PPARAM2_(regbank) _PPTOSTR_(register_bank=regbank)
           =5 # define INTERRUPT(name, vector) _Pragma(_PPARAM_(vector)) __interrupt void name(void)
           =5 # define INTERRUPT_PROTO(name, vector)  __interrupt void name(void)
           =5 # define INTERRUPT_USING(name, vector, regnum) _Pragma(_PPARAM2_(regnum)) _Pragma(_PPARAM_(vector)) __inte
             -rrupt void name(void)
           =5 # define INTERRUPT_PROTO_USING(name, vector, regnum) __interrupt void name(void)
           =5 
           =5 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =5 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =5 // Note: IAR does not support functions using different register banks. Register
           =5 //       banks can only be specified in interrupts. If a function is called from
           =5 //       inside an interrupt, it will use the same register bank as the interrupt.
           =5 
           =5 # define SEGMENT_VARIABLE(name, vartype, locsegment)  locsegment vartype name
           =5 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment  * name
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 55  

           =5 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =5 
           =5 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment __no_init vartype name @ addr
           =5 
           =5 // used with UU16
           =5 # define LSB 0
           =5 # define MSB 1
           =5 
           =5 // used with UU32 (b0 is least-significant byte)
           =5 # define b0 0
           =5 # define b1 1
           =5 # define b2 2
           =5 # define b3 3
           =5 
           =5 typedef unsigned char U8;
           =5 typedef unsigned int U16;
           =5 typedef unsigned long U32;
           =5 
           =5 typedef signed char S8;
           =5 typedef signed int S16;
           =5 typedef signed long S32;
           =5 
           =5 typedef union UU16
           =5 {
           =5    U16 U16;
           =5    S16 S16;
           =5    U8 U8[2];
           =5    S8 S8[2];
           =5 } UU16;
           =5 
           =5 typedef union UU32
           =5 {
           =5    U32 U32;
           =5    S32 S32;
           =5    UU16 UU16[2];
           =5    U16 U16[2];
           =5    S16 S16[2];
           =5    U8 U8[4];
           =5    S8 S8[4];
           =5 } UU32;
           =5 
           =5 
           =5 #define NOP() __no_operation();
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 // Crossware
           =5 // http://www.crossware.com
           =5 
           =5 #elif defined _XC51_VER
           =5 # define SBIT(name, addr, bit)  _sfrbit  name = (addr+bit)
           =5 # define SFR(name, addr)        _sfr     name = addr
           =5 # define SFR16(name, addr)      _sfrword name = addr
           =5 # define SFR16E(name, fulladdr) /* not supported */
           =5 # define SFR32(name, fulladdr)  /* not supported */
           =5 # define SFR32E(name, fulladdr) /* not supported */
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 // Wickenhäuser
           =5 // http://www.wickenhaeuser.de
           =5 
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 56  

           =5 #elif defined __UC__
           =5 # define SBIT(name, addr, bit)  unsigned char bit  name @ (addr+bit)
           =5 # define SFR(name, addr)        near unsigned char name @ addr
           =5 # define SFR16(name, addr)      /* not supported */
           =5 # define SFR16E(name, fulladdr) /* not supported */
           =5 # define SFR32(name, fulladdr)  /* not supported */
           =5 # define SFR32E(name, fulladdr) /* not supported */
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 // Default
           =5 // Unknown compiler
           =5 
           =5 #else
           =5 # warning unrecognized compiler
           =5 # define SBIT(name, addr, bit)  volatile bool           name
           =5 # define SFR(name, addr)        volatile unsigned char  name
           =5 # define SFRX(name, addr)       volatile unsigned char  name
           =5 # define SFR16(name, addr)      volatile unsigned short name
           =5 # define SFR16E(name, fulladdr) volatile unsigned short name
           =5 # define SFR32(name, fulladdr)  volatile unsigned long  name
           =5 # define SFR32E(name, fulladdr) volatile unsigned long  name
           =5 
           =5 #endif
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 // Header File PreProcessor Directive
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 #endif                                 // #define COMPILER_DEFS_H
 689      =5  
 690      =5  //-----------------------------------------------------------------------------
 691      =5  // End Of File
 692      =5  //-----------------------------------------------------------------------------
   8      =4  #include <C8051F580_defs.h> // SFR declarations
   1      =5  //-----------------------------------------------------------------------------
   2      =5  // C8051F580_defs.h
   3      =5  //-----------------------------------------------------------------------------
   4      =5  // Copyright 2008, Silicon Laboratories, Inc.
   5      =5  // http://www.silabs.com
   6      =5  //
   7      =5  // Program Description:
   8      =5  //
   9      =5  // Register/bit definitions for the C8051F58x family.
  10      =5  // **Important Note**: The compiler_defs.h header file should be included
  11      =5  // before including this header file.
  12      =5  //
  13      =5  // Target:         C8051F580/1/2/3/4/5/6/7,8/9-F590/1
  14      =5  // Tool chain:     Generic
  15      =5  // Command Line:   None
  16      =5  //
  17      =5  // Release 0.6 - 20 AUG 2012 (TP)
  18      =5  //    -Added #define for _XPAGE to provide support for SDCC memory paging
  19      =5  //     (pdata)
  20      =5  //
  21      =5  // Release 0.5 - 10 SEP 2011 (GP)
  22      =5  //    - Fixed SFR16 definition for CAN0IF2MC
  23      =5  //
  24      =5  // Release 0.4 - 08 OCT 2010 (TP)
  25      =5  //    - Fixed bit definitions for SCON0
  26      =5  //
  27      =5  // Release 0.3 - 01 APR 2009 (GP)
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 57  

  28      =5  //    - Added SN0-SN3
  29      =5  //
  30      =5  // Release 0.2 - 29 JUL 2008 (ADT)
  31      =5  //    - Added Timer 4 bit definitions
  32      =5  //
  33      =5  // Release 0.1 - 09 JUL 2008 (GP)
  34      =5  //    - Initial Revision
  35      =5  //
  36      =5  //-----------------------------------------------------------------------------
  37      =5  // Header File Preprocessor Directive
  38      =5  //-----------------------------------------------------------------------------
  39      =5  
  40      =5  #ifndef C8051F580_DEFS_H
           =5 #define C8051F580_DEFS_H
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 // Page 0, Page 1 and Page F Registers
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 SFR (P0, 0x80);                        // Port 0 Latch
           =5 SFR (SP, 0x81);                        // Stack Pointer
           =5 SFR (DPL, 0x82);                       // Data Pointer Low
           =5 SFR (DPH, 0x83);                       // Data Pointer High
           =5 SFR (SFR0CN, 0x84);                    // SFR Page Control
           =5 SFR (SFRNEXT, 0x85);                   // SFR stack next page
           =5 SFR (SFRLAST, 0x86);                   // SFR stack last page
           =5 SFR (PCON, 0x87);                      // Power Control
           =5 SFR (TCON, 0x88);                      // Timer/Counter Control
           =5 SFR (TMOD, 0x89);                      // Timer/Counter Mode
           =5 SFR (TL0, 0x8A);                       // Timer/Counter 0 Low
           =5 SFR (TL1, 0x8B);                       // Timer/Counter 1 Low
           =5 SFR (TH0, 0x8C);                       // Timer/Counter 0 High
           =5 SFR (TH1, 0x8D);                       // Timer/Counter 1 High
           =5 SFR (CKCON, 0x8E);                     // Clock Control
           =5 SFR (PSCTL, 0x8F);                     // Program Store R/W Control
           =5 SFR (CLKSEL, 0x8F);                    // System clock select
           =5 SFR (P1, 0x90);                        // Port 1 Latch
           =5 SFR (TMR3CN, 0x91);                    // Timer/Counter 3 Control
           =5 SFR (TMR5CN, 0x91);                    // Timer/Counter 5 Control
           =5 SFR (TMR3RLL, 0x92);                   // Timer/Counter 3 Reload Low
           =5 SFR (TMR5CAPL, 0x92);                  // Timer/Counter 5 Capture Low
           =5 SFR (TMR3RLH, 0x93);                   // Timer/Counter 3 Reload High
           =5 SFR (TMR5CAPH, 0x93);                  // Timer/Counter 5 Capture High
           =5 SFR (TMR3L, 0x94);                     // Timer/Counter 3 Low
           =5 SFR (TMR5L, 0x94);                     // Timer/Counter 5 Low
           =5 SFR (TMR3H, 0x95);                     // Timer/Counter 3 High
           =5 SFR (TMR5H, 0x95);                     // Timer/Counter 5 High
           =5 SFR (TMR5CF, 0x96);                    // Timer/Counter 5 Configuration
           =5 SFR (CLKMUL, 0x97);                    // Clock Multiplier
           =5 SFR (SCON0, 0x98);                     // UART0 Control
           =5 SFR (SCON1, 0x98);                     // UART1 Control
           =5 SFR (SBUF0, 0x99);                     // UART0 Data Buffer
           =5 SFR (SBUF1, 0x99);                     // UART1 Data Buffer
           =5 SFR (CPT0CN, 0x9A);                    // Comparator 0 Control
           =5 SFR (CPT2CN, 0x9A);                    // Comparator 2 Control
           =5 SFR (CPT0MD, 0x9B);                    // Comparator 0 Mode
           =5 SFR (CPT2MD, 0x9B);                    // Comparator 2 Mode
           =5 SFR (CPT0MX, 0x9C);                    // Comparator 0 Mux
           =5 SFR (CPT2MX, 0x9C);                    // Comparator 2 Mux
           =5 SFR (CPT1CN, 0x9D);                    // Comparator 1 Control
           =5 SFR (CPT1MD, 0x9E);                    // Comparator 0 Mode
           =5 SFR (OSCIFIN, 0x9E);                   // Internal Oscillator Fine Control
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 58  

           =5 SFR (CPT1MX, 0x9F);                    // Comparator 1 Mux
           =5 SFR (OSCXCN, 0x9F);                    // External Oscillator Control
           =5 SFR (P2, 0xA0);                        // Port 2 Latch
           =5 SFR (SPI0CFG, 0xA1);                   // SPI0 Configuration
           =5 SFR (OSCICN, 0xA1);                    // Internal Oscillator Control
           =5 SFR (SPI0CKR, 0xA2);                   // SPI0 Clock rate control
           =5 SFR (OSCICRS, 0xA2);                   // Internal Oscillator Coarse Control
           =5 SFR (SPI0DAT, 0xA3);                   // SPI0 Data Buffer
           =5 SFR (P0MDOUT, 0xA4);                   // Port 0 Output Mode
           =5 SFR (P1MDOUT, 0xA5);                   // Port 1 Output Mode
           =5 SFR (P2MDOUT, 0xA6);                   // Port 2 Output Mode
           =5 SFR (SFRPAGE, 0xA7);                   // SFR Page Select
           =5 SFR (IE, 0xA8);                        // Interrupt Enable
           =5 SFR (SMOD0, 0xA9);                     // Serial Port 0 Control
           =5 SFR (EMI0CN, 0xAA);                    // EMIF Control
           =5 SFR (EMI0TC, 0xAA);                    // EMIF Timing control
           =5 SFR (SBCON0, 0xAB);                    // UART0 Baud Rate Generator Control
           =5 SFR (SBRLL0, 0xAC);                    // UART0 Baud Rate Generator Low
           =5 SFR (SBRLH0, 0xAD);                    // UART0 Baud Rate Generator High
           =5 SFR (P3MAT, 0xAE);                     // Port 3 Match
           =5 SFR (P3MDOUT, 0xAE);                   // Port 3 Mode
           =5 SFR (P3MASK, 0xAF);                    // Port 3 Mask
           =5 SFR (P4MDOUT, 0xAF);                   // Port 4 Mode
           =5 SFR (P3, 0xB0);                        // Port 3 Latch
           =5 SFR (P2MAT, 0xB1);                     // Port 2 Match
           =5 SFR (P2MASK, 0xB2);                    // Port 2 Mask
           =5 SFR (EMI0CF, 0xB2);                    // EMIF Configuration
           =5 SFR (P4, 0xB5);                        // Port 4 Latch
           =5 SFR (FLSCL, 0xB6);                     // Flash Scale
           =5 SFR (FLKEY, 0xB7);                     // Flash access limit
           =5 SFR (IP, 0xB8);                        // Interrupt Priority
           =5 SFR (SMB0ADR, 0xB9);                   // SMBus0 Slave address
           =5 SFR (ADC0TK, 0xBA);                    // ADC0 Tracking Mode Select
           =5 SFR (SMB0ADM, 0xBA);                   // SMBus0 Address Mask
           =5 SFR (ADC0MX, 0xBB);                    // AMUX0 Channel select
           =5 SFR (ADC0CF, 0xBC);                    // AMUX0 Channel configuration
           =5 SFR (ADC0L, 0xBD);                     // ADC0 Data Low
           =5 SFR (ADC0H, 0xBE);                     // ADC0 Data High
           =5 SFR (SMB0CN, 0xC0);                    // SMBus0 Control
           =5 SFR (SMB0CF, 0xC1);                    // SMBus0 Configuration
           =5 SFR (SMB0DAT, 0xC2);                   // SMBus0 Data
           =5 SFR (ADC0GTL, 0xC3);                   // ADC0 Greater-Than Compare Low
           =5 SFR (ADC0GTH, 0xC4);                   // ADC0 Greater-Than Compare High
           =5 SFR (ADC0LTL, 0xC5);                   // ADC0 Less-Than Compare Word Low
           =5 SFR (ADC0LTH, 0xC6);                   // ADC0 Less-Than Compare Word High
           =5 SFR (XBR3, 0xC6);                      // Port I/O Crossbar Control 3
           =5 SFR (XBR2, 0xC7);                      // Port I/O Crossbar Control 2
           =5 SFR (TMR2CN, 0xC8);                    // Timer/Counter 2 Control
           =5 SFR (TMR4CN, 0xC8);                    // Timer/Counter 4 Control
           =5 SFR (REG0CN, 0xC9);                    // Regulator Control
           =5 SFR (LIN0CF, 0xC9);                    // LIN 0 Configuration
           =5 SFR (TMR4CF, 0xC9);                    // Timer/Counter 4 Configuration
           =5 SFR (TMR2RLL, 0xCA);                   // Timer/Counter 2 Reload Low
           =5 SFR (TMR4CAPL, 0xCA);                  // Timer/Counter 4 Capture Low
           =5 SFR (TMR2RLH, 0xCB);                   // Timer/Counter 2 Reload High
           =5 SFR (TMR4CAPH, 0xCB);                  // Timer/Counter 4 Capture High
           =5 SFR (TMR2L, 0xCC);                     // Timer/Counter 2 Low
           =5 SFR (TMR4L, 0xCC);                     // Timer/Counter 4 Low
           =5 SFR (TMR2H, 0xCD);                     // Timer/Counter 2 High
           =5 SFR (TMR4H, 0xCD);                     // Timer/Counter 4 High
           =5 SFR (PCA0CPL5, 0xCE);                  // PCA0 Capture 5 Low
           =5 SFR (PCA1CPL11, 0xCE);                 // PCA1 Capture 11 Low
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 59  

           =5 SFR (PCA0CPH5, 0xCF);                  // PCA0 Capture 5 High
           =5 SFR (PCA1CPH11, 0xCF);                 // PCA1 Capture 11 High
           =5 SFR (PSW, 0xD0);                       // Program Status Word
           =5 SFR (REF0CN, 0xD1);                    // Voltage Reference Control
           =5 SFR (LIN0DAT, 0xD2);                   // LIN0 Data
           =5 SFR (LIN0ADR, 0xD3);                   // LIN0 Address
           =5 SFR (P0SKIP, 0xD4);                    // Port 0 Skip
           =5 SFR (P1SKIP, 0xD5);                    // Port 1 Skip
           =5 SFR (P2SKIP, 0xD6);                    // Port 2 Skip
           =5 SFR (P3SKIP, 0xD7);                    // Port 3 Skip
           =5 SFR (PCA0CN, 0xD8);                    // PCA0 Control
           =5 SFR (PCA1CN, 0xD8);                    // PCA1 Control
           =5 SFR (PCA0MD, 0xD9);                    // PCA0 Mode
           =5 SFR (PCA1MD, 0xD9);                    // PCA1 Mode
           =5 SFR (PCA0PWM, 0xD9);                   // PCA0 PWM Control
           =5 SFR (PCA0CPM0, 0xDA);                  // PCA0 Module 0 Mode
           =5 SFR (PCA1CPM6, 0xDA);                  // PCA1 Module 6 Mode
           =5 SFR (PCA1PWM, 0xDA);                   // PCA1 PWM Control
           =5 SFR (PCA0CPM1, 0xDB);                  // PCA0 Module 1  Mode
           =5 SFR (PCA1CPM7, 0xDB);                  // PCA1 Module 7  Mode
           =5 SFR (PCA0CPM2, 0xDC);                  // PCA0 Module 2  Mode
           =5 SFR (PCA1CPM8, 0xDC);                  // PCA1 Module 8  Mode
           =5 SFR (PCA0CPM3, 0xDD);                  // PCA0 Module 3  Mode
           =5 SFR (PCA1CPM9, 0xDD);                  // PCA1 Module 9  Mode
           =5 SFR (PCA0CPM4, 0xDE);                  // PCA0 Module 4  Mode
           =5 SFR (PCA1CPM10, 0xDE);                  // PCA1 Module 10 Mode
           =5 SFR (PCA0CPM5, 0xDF);                  // PCA0 Module 5  Mode
           =5 SFR (PCA1CPM11, 0xDF);                  // PCA1 Module 11 Mode
           =5 SFR (ACC, 0xE0);                       // Accumulator
           =5 SFR (XBR0, 0xE1);                      // Port I/O Crossbar Control 0
           =5 SFR (XBR1, 0xE2);                      // Port I/O Crossbar Control 1
           =5 SFR (CCH0CN, 0xE3);                    // Cache control
           =5 SFR (IT01CF, 0xE4);                    // INT0/INT1 Configuration
           =5 SFR (EIE1, 0xE6);                      // Extended Interrupt Enable 2
           =5 SFR (EIE2, 0xE7);                      // Extended Interrupt Enable 2
           =5 SFR (ADC0CN, 0xE8);                    // ADC0 Control
           =5 SFR (PCA0CPL1, 0xE9);                  // PCA0 Capture 1 Low
           =5 SFR (PCA1CPL1, 0xE9);                  // PCA1 Capture 7 Low
           =5 SFR (PCA0CPH1, 0xEA);                  // PCA0 Capture 1 High
           =5 SFR (PCA1CPH1, 0xEA);                  // PCA1 Capture 7 High
           =5 SFR (PCA0CPL2, 0xEB);                  // PCA0 Capture 2 Low
           =5 SFR (PCA1CPL2, 0xEB);                  // PCA1 Capture 8 Low
           =5 SFR (PCA0CPH2, 0xEC);                  // PCA0 Capture 2 High
           =5 SFR (PCA1CPH2, 0xEC);                  // PCA1 Capture 8 High
           =5 SFR (PCA0CPL3, 0xED);                  // PCA0 Capture 3 Low
           =5 SFR (PCA1CPL3, 0xED);                  // PCA1 Capture 9 Low
           =5 SFR (PCA0CPH3, 0xEE);                  // PCA0 Capture 3 High
           =5 SFR (PCA1CPH3, 0xEE);                  // PCA1 Capture 9 High
           =5 SFR (RSTSRC, 0xEF);                    // Reset Source Configuration/Status
           =5 SFR (B, 0xF0);                         // B Register
           =5 SFR (P0MAT, 0xF1);                     // Port 0 Match
           =5 SFR (P0MDIN, 0xF1);                    // Port 0 Input Mode
           =5 SFR (P0MASK, 0xF2);                    // Port 0 Mask
           =5 SFR (P1MDIN, 0xF2);                    // Port 1 Input Mode
           =5 SFR (P1MAT, 0xF3);                     // Port 1 Match
           =5 SFR (P2MDIN, 0xF3);                    // Port 2 Input Mode
           =5 SFR (P1MASK, 0xF4);                    // Port 1 Mask
           =5 SFR (P3MDIN, 0xF4);                    // Port 3 Input Mode
           =5 SFR (PSBANK, 0xF5);                    // Program Space Bank Select
           =5 SFR (EIP1, 0xF6);                      // External Interrupt Priority 1
           =5 SFR (EIP2, 0xF7);                      // External Interrupt Priority 2
           =5 SFR (SPI0CN, 0xF8);                    // SPI0 Control
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 60  

           =5 SFR (PCA0L, 0xF9);                     // PCA0 Counter Low
           =5 SFR (PCA1L, 0xF9);                     // PCA1 Counter Low
           =5 SFR (SN0, 0xF9);                       // Serial Number 0
           =5 SFR (PCA0H, 0xFA);                     // PCA0 Counter High
           =5 SFR (PCA1H, 0xFA);                     // PCA1 Counter High
           =5 SFR (SN1, 0xFA);                       // Serial Number 1
           =5 SFR (PCA0CPL0, 0xFB);                  // PCA0 Capture 0 Low
           =5 SFR (PCA1CPL6, 0xFB);                  // PCA1 Capture 6 Low
           =5 SFR (SN2, 0xFB);                       // Serial Number 2
           =5 SFR (PCA0CPH0, 0xFC);                  // PCA0 Capture 0 High
           =5 SFR (PCA1CPH6, 0xFC);                  // PCA1 Capture 6 High
           =5 SFR (SN3, 0xFC);                       // Serial Number 3
           =5 SFR (PCA0CPL4, 0xFD);                  // PCA0 Capture 4 Low
           =5 SFR (PCA1CPL10, 0xFD);                 // PCA1 Capture 10 Low
           =5 SFR (PCA0CPH4, 0xFE);                  // PCA0 Capture 4 High
           =5 SFR (PCA1CPH10, 0xFE);                 // PCA1 Capture 10 High
           =5 SFR (VDM0CN, 0xFF);                    // VDD Monitor Control
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 // Page C (CAN0) Registers
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 SFR (CAN0CFG, 0x92);                   // CAN0 Clock Configuration
           =5 SFR (CAN0STAT, 0x94);                  // Status Register Low Byte
           =5 SFR (CAN0ERRL, 0x96);                  // Error Counter Low Byte
           =5 SFR (CAN0ERRH, 0x97);                  // Error Counter High Byte
           =5 SFR (CAN0BTL, 0x9A);                   // Bit Timing Register Low Byte
           =5 SFR (CAN0BTH, 0x9B);                   // Bit Timing Register High Byte
           =5 SFR (CAN0IIDL, 0x9C);                  // Interrupt Register Low Byte
           =5 SFR (CAN0IIDH, 0x9D);                  // Interrupt Register High Byte
           =5 SFR (CAN0TST, 0x9E);                   // Test Register Low Byte
           =5 SFR (CAN0BRPE, 0xA1);                  // BRP Extension Register Low Byte
           =5 SFR (CAN0TR1L, 0xA2);                  // Transmission Request 1 Low Byte
           =5 SFR (CAN0TR1H, 0xA3);                  // Transmission Request 1 High Byte
           =5 SFR (CAN0TR2L, 0xA4);                  // Transmission Request 2 Low Byte
           =5 SFR (CAN0TR2H, 0xA5);                  // Transmission Request 2 High Byte
           =5 SFR (CAN0ND1L, 0xAA);                  // New Data 1 Low Byte
           =5 SFR (CAN0ND1H, 0xAB);                  // New Data 1 High Byte
           =5 SFR (CAN0ND2L, 0xAC);                  // New Data 2 Low Byte
           =5 SFR (CAN0ND2H, 0xAD);                  // New Data 2 High Byte
           =5 SFR (CAN0IP1L, 0xAE);                  // Interrupt Pending 1 Low Byte
           =5 SFR (CAN0IP1H, 0xAF);                  // Interrupt Pending 1 High Byte
           =5 SFR (CAN0IP2L, 0xB2);                  // Interrupt Pending 2 Low Byte
           =5 SFR (CAN0IP2H, 0xB3);                  // Interrupt Pending 2 High Byte
           =5 SFR (CAN0MV1L, 0xBA);                  // Message Valid 1 Low Byte
           =5 SFR (CAN0MV1H, 0xBB);                  // Message Valid 1 High Byte
           =5 SFR (CAN0MV2L, 0xBC);                  // Message Valid 2 Low Byte
           =5 SFR (CAN0MV2H, 0xBD);                  // Message Valid 2 High Byte
           =5 SFR (CAN0IF1CRL, 0xBE);                // IF1 Command Request Low Byte
           =5 SFR (CAN0IF1CRH, 0xBF);                // IF1 Command Request High Byte
           =5 SFR (CAN0CN, 0xC0);                    // CAN Control Register Low Byte
           =5 SFR (CAN0IF1CML, 0xC2);                // IF1 Command Mask Low Byte
           =5 SFR (CAN0IF1CMH, 0xC3);                // IF1 Command Mask High Byte
           =5 SFR (CAN0IF1M1L, 0xC4);                // IF1 Mask 1 Low Byte
           =5 SFR (CAN0IF1M1H, 0xC5);                // IF1 Mask 1 High Byte
           =5 SFR (CAN0IF1M2L, 0xC6);                // IF1 Mask 2 Low Byte
           =5 SFR (CAN0IF1M2H, 0xC7);                // IF1 Mask 2 High Byte
           =5 SFR (CAN0IF1A1L, 0xCA);                // IF1 Arbitration 1 Low Byte
           =5 SFR (CAN0IF1A1H, 0xCB);                // IF1 Arbitration 1 High Byte
           =5 SFR (CAN0IF1A2L, 0xCC);                // IF1 Arbitration 2 Low Byte
           =5 SFR (CAN0IF1A2H, 0xCD);                // IF1 Arbitration 2 High Byte
           =5 SFR (CAN0IF2MCL, 0xCE);                // IF2 Message Control Low Byte
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 61  

           =5 SFR (CAN0IF2MCH, 0xCF);                // IF2 Message Control High Byte
           =5 SFR (CAN0IF1MCL, 0xD2);                // IF1 Message Control Low Byte
           =5 SFR (CAN0IF1MCH, 0xD3);                // IF1 Message Control High Byte
           =5 SFR (CAN0IF1DA1L, 0xD4);               // IF1 Data A 1 Low Byte
           =5 SFR (CAN0IF1DA1H, 0xD5);               // IF1 Data A 1 High Byte
           =5 SFR (CAN0IF1DA2L, 0xD6);               // IF1 Data A 2 Low Byte
           =5 SFR (CAN0IF1DA2H, 0xD7);               // IF1 Data A 2 High Byte
           =5 SFR (CAN0IF1DB1L, 0xDA);               // IF1 Data B 1 Low Byte
           =5 SFR (CAN0IF1DB1H, 0xDB);               // IF1 Data B 1 High Byte
           =5 SFR (CAN0IF1DB2L, 0xDC);               // IF1 Data B 2 Low Byte
           =5 SFR (CAN0IF1DB2H, 0xDD);               // IF1 Data B 2 High Byte
           =5 SFR (CAN0IF2CRL, 0xDE);                // IF2 Command Request Low Byte
           =5 SFR (CAN0IF2CRH, 0xDF);                // IF2 Command Request High Byte
           =5 SFR (CAN0IF2CML, 0xE2);                // IF2 Command Mask Low Byte
           =5 SFR (CAN0IF2CMH, 0xE3);                // IF2 Command Mask High Byte
           =5 SFR (CAN0IF2M1L, 0xEA);                // IF2 Mask 1 Low Byte
           =5 SFR (CAN0IF2M1H, 0xEB);                // IF2 Mask 1 High Byte
           =5 SFR (CAN0IF2M2L, 0xEC);                // IF2 Mask 2 Low Byte
           =5 SFR (CAN0IF2M2H, 0xED);                // IF2 Mask 2 High Byte
           =5 SFR (CAN0IF2A1L, 0xEE);                // IF2 Arbitration 1 Low Byte
           =5 SFR (CAN0IF2A1H, 0xEF);                // IF2 Arbitration 1 High Byte
           =5 SFR (CAN0IF2A2L, 0xF2);                // IF2 Arbitration 2 Low Byte
           =5 SFR (CAN0IF2A2H, 0xF3);                // IF2 Arbitration 2 High Byte
           =5 SFR (CAN0IF2DA1L, 0xF6);               // IF2 Data A 1 Low Byte
           =5 SFR (CAN0IF2DA1H, 0xF7);               // IF2 Data A 1 High Byte
           =5 SFR (CAN0IF2DA2L, 0xFA);               // IF2 Data A 2 Low Byte
           =5 SFR (CAN0IF2DA2H, 0xFB);               // IF2 Data A 2 High Byte
           =5 SFR (CAN0IF2DB1L, 0xFC);               // IF2 Data B 1 Low Byte
           =5 SFR (CAN0IF2DB1H, 0xFD);               // IF2 Data B 1 High Byte
           =5 SFR (CAN0IF2DB2L, 0xFE);               // IF2 Data B 2 Low Byte
           =5 SFR (CAN0IF2DB2H, 0xFF);               // IF2 Data B 2 High Byte
           =5 
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 // 16-bit Register Definitions (might not be supported by all compilers)
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 SFR16 (DP, 0x82);                      // Data Pointer
           =5 SFR16 (TMR3RL, 0x92);                  // Timer 3 Reload
           =5 SFR16 (TMR5CAP, 0x92);                 // Timer 5 Capture
           =5 SFR16 (TMR3, 0x94);                    // Timer 3 Capture / Reload
           =5 SFR16 (TMR5, 0x94);                    // Timer 5
           =5 SFR16 (SBRL0, 0xAC);                   // UART0 Reload
           =5 SFR16 (ADC0, 0xBD);                    // ADC0 data
           =5 SFR16 (ADC0GT, 0xC3);                  // ADC0 Greater Than Window
           =5 SFR16 (ADC0LT, 0xC5);                  // ADC0 Less Than Window
           =5 SFR16 (TMR2RL, 0xCA);                  // Timer 2 Reload
           =5 SFR16 (TMR4CAP, 0xCA);                 // Timer 4 Capture
           =5 SFR16 (TMR2, 0xCC);                    // Timer 2 Capture / Reload
           =5 SFR16 (TMR4, 0xCC);                    // Timer 4
           =5 SFR16 (PCA0CP5, 0xCE);                 // PCA0 Module 5 Capture
           =5 SFR16 (PCA1CP11, 0xCE);                // PCA1 Module 11 Capture
           =5 SFR16 (PCA0CP1, 0xE9);                 // PCA0 Module 1 Capture
           =5 SFR16 (PCA1CP7, 0xE9);                 // PCA1 Module 7 Capture
           =5 SFR16 (PCA0CP2, 0xEB);                 // PCA0 Module 2 Capture
           =5 SFR16 (PCA1CP8, 0xEB);                 // PCA1 Module 8 Capture
           =5 SFR16 (PCA0CP3, 0xED);                 // PCA0 Module 3 Capture
           =5 SFR16 (PCA1CP9, 0xED);                 // PCA1 Module 9 Capture
           =5 SFR16 (PCA0, 0xF9);                    // PCA0 Counter
           =5 SFR16 (PCA1, 0xF9);                    // PCA1 Counter
           =5 SFR16 (PCA0CP0, 0xFB);                 // PCA0 Module 0 Capture
           =5 SFR16 (PCA1CP6, 0xFB);                 // PCA1 Module 6 Capture
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 62  

           =5 SFR16 (PCA0CP4, 0xFD);                 // PCA0 Module 4 Capture
           =5 SFR16 (PCA1CP10, 0xFD);                 // PCA1 Module 10 Capture
           =5 
           =5 SFR16 (CAN0ERR, 0x96);                 // Error Counter
           =5 SFR16 (CAN0BT, 0x9A);                  // Bit Timing Register
           =5 SFR16 (CAN0IID, 0x9C);                 // Interrupt Register
           =5 SFR16 (CAN0TR1, 0xA2);                 // Transmission Request 1
           =5 SFR16 (CAN0TR2, 0xA4);                 // Transmission Request 2
           =5 SFR16 (CAN0ND1, 0xAA);                 // New Data 1
           =5 SFR16 (CAN0ND2, 0xAC);                 // New Data 2
           =5 SFR16 (CAN0IP1, 0xAE);                 // Interrupt Pending 1
           =5 SFR16 (CAN0IP2, 0xB2);                 // Interrupt Pending 2
           =5 SFR16 (CAN0MV1, 0xBA);                 // Message Valid 1
           =5 SFR16 (CAN0MV2, 0xBC);                 // Message Valid 2
           =5 SFR16 (CAN0IF1CR, 0xBE);               // IF1 Command Request
           =5 SFR16 (CAN0IF1CM, 0xC2);               // IF1 Command Mask
           =5 SFR16 (CAN0IF1M1, 0xC4);               // IF1 Mask 1
           =5 SFR16 (CAN0IF1M2, 0xC6);               // IF1 Mask 2
           =5 SFR16 (CAN0IF1A1, 0xCA);               // IF1 Arbitration 1
           =5 SFR16 (CAN0IF1A2, 0xCC);               // IF1 Arbitration 2
           =5 SFR16 (CAN0IF1MC, 0xD2);               // IF1 Message Control
           =5 SFR16 (CAN0IF1DA1, 0xD4);              // IF1 Data A 1
           =5 SFR16 (CAN0IF1DA2, 0xD6);              // IF1 Data A 2
           =5 SFR16 (CAN0IF1DB1, 0xDA);              // IF1 Data B 1
           =5 SFR16 (CAN0IF1DB2, 0xDC);              // IF1 Data B 2
           =5 SFR16 (CAN0IF2CR, 0xDE);               // IF2 Command Request
           =5 SFR16 (CAN0IF2CM, 0xE2);               // IF2 Command Mask
           =5 SFR16 (CAN0IF2M1, 0xEA);               // IF2 Mask 1
           =5 SFR16 (CAN0IF2M2, 0xEC);               // IF2 Mask 2
           =5 SFR16 (CAN0IF2A1, 0xEE);               // IF2 Arbitration 1
           =5 SFR16 (CAN0IF2A2, 0xF2);               // IF2 Arbitration 2
           =5 SFR16 (CAN0IF2MC, 0xCE);               // IF2 Message Control
           =5 SFR16 (CAN0IF2DA1, 0xF6);              // IF2 Data A 1
           =5 SFR16 (CAN0IF2DA2, 0xFA);              // IF2 Data A 2
           =5 SFR16 (CAN0IF2DB1, 0xFC);              // IF2 Data B 1
           =5 SFR16 (CAN0IF2DB2, 0xFE);              // IF2 Data B 2
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 // LIN0 Indirect Registers
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 #define  LIN0DT1   0x00                // LIN0 Data Byte 1
           =5 #define  LIN0DT2   0x01                // LIN0 Data Byte 2
           =5 #define  LIN0DT3   0x02                // LIN0 Data Byte 3
           =5 #define  LIN0DT4   0x03                // LIN0 Data Byte 4
           =5 #define  LIN0DT5   0x04                // LIN0 Data Byte 5
           =5 #define  LIN0DT6   0x05                // LIN0 Data Byte 6
           =5 #define  LIN0DT7   0x06                // LIN0 Data Byte 7
           =5 #define  LIN0DT8   0x07                // LIN0 Data Byte 8
           =5 #define  LIN0CTRL  0x08                // LIN0 Control
           =5 #define  LIN0ST    0x09                // LIN0 Status
           =5 #define  LIN0ERR   0x0A                // LIN0 Error
           =5 #define  LIN0SIZE  0x0B                // LIN0 Message Size
           =5 #define  LIN0DIV   0x0C                // LIN0 Divider
           =5 #define  LIN0MUL   0x0D                // LIN0 Multiplier
           =5 #define  LIN0ID    0x0E                // LIN0 Identifier
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 // Address Definitions for Bit-addressable Registers
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 #define SFR_P0       0x80
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 63  

           =5 #define SFR_TCON     0x88
           =5 #define SFR_P1       0x90
           =5 #define SFR_SCON0    0x98
           =5 #define SFR_SCON1    0x98
           =5 #define SFR_P2       0xA0
           =5 #define SFR_IE       0xA8
           =5 #define SFR_P3       0xB0
           =5 #define SFR_IP       0xB8
           =5 #define SFR_SMB0CN   0xC0
           =5 #define SFR_TMR2CN   0xC8
           =5 #define SFR_TMR4CN   0xC8
           =5 #define SFR_PSW      0xD0
           =5 #define SFR_PCA0CN   0xD8
           =5 #define SFR_PCA1CN   0xD8
           =5 #define SFR_ACC      0xE0
           =5 #define SFR_ADC0CN   0xE8
           =5 #define SFR_B        0xF0
           =5 #define SFR_SPI0CN   0xF8
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 // Bit Definitions
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 // TCON 0x88
           =5 SBIT (TF1, SFR_TCON, 7);               // Timer 1 Overflow Flag
           =5 SBIT (TR1, SFR_TCON, 6);               // Timer 1 On/Off Control
           =5 SBIT (TF0, SFR_TCON, 5);               // Timer 0 Overflow Flag
           =5 SBIT (TR0, SFR_TCON, 4);               // Timer 0 On/Off Control
           =5 SBIT (IE1, SFR_TCON, 3);               // Ext. Interrupt 1 Edge Flag
           =5 SBIT (IT1, SFR_TCON, 2);               // Ext. Interrupt 1 Type
           =5 SBIT (IE0, SFR_TCON, 1);               // Ext. Interrupt 0 Edge Flag
           =5 SBIT (IT0, SFR_TCON, 0);               // Ext. Interrupt 0 Type
           =5 
           =5 // SCON0 0x98
           =5 SBIT (OVR0, SFR_SCON0, 7);             // UART0 Receive FIFO Overrun Flag
           =5 SBIT (PERR0, SFR_SCON0, 6);            // UART0 Parity Error Flag
           =5 SBIT (THRE0, SFR_SCON0, 5);            // UART0 Transmit Register Empty Flag
           =5 SBIT (REN0, SFR_SCON0, 4);             // UART0 RX Enable
           =5 SBIT (TBX0, SFR_SCON0, 3);             // UART0 Extra Transmission Bit
           =5 SBIT (RBX0, SFR_SCON0, 2);             // UART0 Extra Receive Bit
           =5 SBIT (TI0, SFR_SCON0, 1);              // UART0 TX Interrupt Flag
           =5 SBIT (RI0, SFR_SCON0, 0);              // UART0 RX Interrupt Flag
           =5 
           =5 // SCON1 0x98
           =5 SBIT (S1MODE, SFR_SCON1, 7);           // UART1 Mode 0
           =5                                        // Bit 6 UNUSED
           =5 SBIT (MCE1, SFR_SCON1, 5);             // UART1 Multiprocessor enable
           =5 SBIT (REN1, SFR_SCON1, 4);             // UART1 RX Enable
           =5 SBIT (TB81, SFR_SCON1, 3);             // UART1 TX Bit 8
           =5 SBIT (RB81, SFR_SCON1, 2);             // UART1 RX Bit 8
           =5 SBIT (TI1, SFR_SCON1, 1);              // UART1 TX Interrupt Flag
           =5 SBIT (RI1, SFR_SCON1, 0);              // UART1 RX Interrupt Flag
           =5 
           =5 // IE 0xA8
           =5 SBIT (EA, SFR_IE, 7);                  // Global Interrupt Enable
           =5 SBIT (ESPI0, SFR_IE, 6);               // SPI0 Interrupt Enable
           =5 SBIT (ET2, SFR_IE, 5);                 // Timer 2 Interrupt Enable
           =5 SBIT (ES0, SFR_IE, 4);                 // UART0 Interrupt Enable
           =5 SBIT (ET1, SFR_IE, 3);                 // Timer 1 Interrupt Enable
           =5 SBIT (EX1, SFR_IE, 2);                 // External Interrupt 1 Enable
           =5 SBIT (ET0, SFR_IE, 1);                 // Timer 0 Interrupt Enable
           =5 SBIT (EX0, SFR_IE, 0);                 // External Interrupt 0 Enable
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 64  

           =5 
           =5 // IP 0xB8
           =5                                        // Bit 7 unused
           =5 SBIT (PSPI0, SFR_IP, 6);               // SPI0 Interrupt Priority
           =5 SBIT (PT2, SFR_IP, 5);                 // Timer 2 Priority
           =5 SBIT (PS0, SFR_IP, 4);                 // UART0 Priority
           =5 SBIT (PS, SFR_IP, 4);                  // UART0 Priority
           =5 SBIT (PT1, SFR_IP, 3);                 // Timer 1 Priority
           =5 SBIT (PX1, SFR_IP, 2);                 // External Interrupt 1 Priority
           =5 SBIT (PT0, SFR_IP, 1);                 // Timer 0 Priority
           =5 SBIT (PX0, SFR_IP, 0);                 // External Interrupt 0 Priority
           =5 
           =5 // SMB0CN 0xC0
           =5 SBIT (MASTER, SFR_SMB0CN, 7);          // SMBus0 Master/Slave Indicator
           =5 SBIT (TXMODE, SFR_SMB0CN, 6);          // SMBus0 Transmit Mode Indicator
           =5 SBIT (STA, SFR_SMB0CN, 5);             // SMBus0 Start Flag
           =5 SBIT (STO, SFR_SMB0CN, 4);             // SMBus0 Stop Flag
           =5 SBIT (ACKRQ, SFR_SMB0CN, 3);           // SMBus0 Acknowledge Request
           =5 SBIT (ARBLOST, SFR_SMB0CN, 2);         // SMBus0 Arbitration Lost Indicator
           =5 SBIT (ACK, SFR_SMB0CN, 1);             // SMBus0 Acknowledge
           =5 SBIT (SI, SFR_SMB0CN, 0);              // SMBus0 Interrupt Flag
           =5 
           =5 // TMR2CN 0xC8
           =5 SBIT (TF2H, SFR_TMR2CN, 7);            // Timer 2 High-Byte Overflow Flag
           =5 SBIT (TF2L, SFR_TMR2CN, 6);            // Timer 2 Low-Byte  Overflow Flag
           =5 SBIT (TF2LEN, SFR_TMR2CN, 5);          // Timer 2 Low-Byte Flag Enable
           =5 SBIT (TF2CEN, SFR_TMR2CN, 4);          // Timer 2 Capture Enable
           =5 SBIT (T2SPLIT, SFR_TMR2CN, 3);         // Timer 2 Split-Mode Enable
           =5 SBIT (TR2, SFR_TMR2CN, 2);             // Timer 2 Run Enable
           =5 SBIT (T2RCLK, SFR_TMR2CN, 1);          // Timer 2 Xclk/Rclk Select
           =5 SBIT (T2XCLK, SFR_TMR2CN, 0);          // Timer 2 Clk/8 Clock Source
           =5 
           =5 // TMR4CN 0xC8
           =5 SBIT (TF4, SFR_TMR4CN, 7);             // Timer 4 Overflow/Underflow Flag
           =5 SBIT (EXF4, SFR_TMR4CN, 6);            // Timer 4 External Flag
           =5                                        // Bit 5 unused
           =5                                        // Bit 4 unused
           =5 SBIT (EXE4, SFR_TMR4CN, 3);            // Timer 4 External Enable
           =5 SBIT (TR4, SFR_TMR4CN, 2);             // Timer 4 Run Enable
           =5 SBIT (CT4, SFR_TMR4CN, 1);             // Timer 4 Counter/Timer Select
           =5 SBIT (CPRL4, SFR_TMR4CN, 0);           // Timer 4 Capture/Reload Select
           =5 
           =5 // PSW 0xD0
           =5 SBIT (CY, SFR_PSW, 7);                 // Carry Flag
           =5 SBIT (AC, SFR_PSW, 6);                 // Auxiliary Carry Flag
           =5 SBIT (F0, SFR_PSW, 5);                 // User Flag 0
           =5 SBIT (RS1, SFR_PSW, 4);                // Register Bank Select 1
           =5 SBIT (RS0, SFR_PSW, 3);                // Register Bank Select 0
           =5 SBIT (OV, SFR_PSW, 2);                 // Overflow Flag
           =5 SBIT (F1, SFR_PSW, 1);                 // User Flag 1
           =5 SBIT (P, SFR_PSW, 0);                  // Accumulator Parity Flag
           =5 
           =5 // PCA0CN 0xD8
           =5 SBIT (CF, SFR_PCA0CN, 7);              // PCA0 Counter Overflow Flag
           =5 SBIT (CR, SFR_PCA0CN, 6);              // PCA0 Counter Run Control Bit
           =5 SBIT (CCF5, SFR_PCA0CN, 5);            // PCA0 Module 5 Interrupt Flag
           =5 SBIT (CCF4, SFR_PCA0CN, 4);            // PCA0 Module 4 Interrupt Flag
           =5 SBIT (CCF3, SFR_PCA0CN, 3);            // PCA0 Module 3 Interrupt Flag
           =5 SBIT (CCF2, SFR_PCA0CN, 2);            // PCA0 Module 2 Interrupt Flag
           =5 SBIT (CCF1, SFR_PCA0CN, 1);            // PCA0 Module 1 Interrupt Flag
           =5 SBIT (CCF0, SFR_PCA0CN, 0);            // PCA0 Module 0 Interrupt Flag
           =5 
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 65  

           =5 // PCA1CN 0xD8
           =5 SBIT (CF1, SFR_PCA1CN, 7);             // PCA1 Counter Overflow Flag
           =5 SBIT (CR1, SFR_PCA1CN, 6);             // PCA1 Counter Run Control Bit
           =5 SBIT (CCF11, SFR_PCA1CN, 5);           // PCA1 Module 11 Interrupt Flag
           =5 SBIT (CCF10, SFR_PCA1CN, 4);           // PCA1 Module 10 Interrupt Flag
           =5 SBIT (CCF9, SFR_PCA1CN, 3);            // PCA1 Module 9 Interrupt Flag
           =5 SBIT (CCF8, SFR_PCA1CN, 2);            // PCA1 Module 8 Interrupt Flag
           =5 SBIT (CCF7, SFR_PCA1CN, 1);            // PCA1 Module 7 Interrupt Flag
           =5 SBIT (CCF6, SFR_PCA1CN, 0);            // PCA1 Module 6 Interrupt Flag
           =5 
           =5 // ADC0CN 0xE8
           =5 SBIT (AD0EN, SFR_ADC0CN, 7);           // ADC0 Enable
           =5 SBIT (BURSTEN, SFR_ADC0CN, 6);         // ADC0 Burst Enable
           =5 SBIT (AD0INT, SFR_ADC0CN, 5);          // ADC0 EOC Interrupt Flag
           =5 SBIT (AD0BUSY, SFR_ADC0CN, 4);         // ADC0 Busy Flag
           =5 SBIT (AD0WINT, SFR_ADC0CN, 3);         // ADC0 Window Compare Interrupt Flag
           =5 SBIT (AD0LJST, SFR_ADC0CN, 2);         // ADC0 Left Justified
           =5 SBIT (AD0CM1, SFR_ADC0CN, 1);          // ADC0 Start Of Conversion Mode Bit 1
           =5 SBIT (AD0CM0, SFR_ADC0CN, 0);          // ADC0 Start Of Conversion Mode Bit 0
           =5 
           =5 // SPI0CN 0xF8
           =5 SBIT (SPIF, SFR_SPI0CN, 7);            // SPI0 Interrupt Flag
           =5 SBIT (WCOL, SFR_SPI0CN, 6);            // SPI0 Write Collision Flag
           =5 SBIT (MODF, SFR_SPI0CN, 5);            // SPI0 Mode Fault Flag
           =5 SBIT (RXOVRN, SFR_SPI0CN, 4);          // SPI0 RX Overrun Flag
           =5 SBIT (NSSMD1, SFR_SPI0CN, 3);          // SPI0 Slave Select Mode 1
           =5 SBIT (NSSMD0, SFR_SPI0CN, 2);          // SPI0 Slave Select Mode 0
           =5 SBIT (TXBMT, SFR_SPI0CN, 1);           // SPI0 TX Buffer Empty Flag
           =5 SBIT (SPIEN, SFR_SPI0CN, 0);           // SPI0 Enable
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 // Interrupt Priorities
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 #define INTERRUPT_INT0             0   // External Interrupt 0
           =5 #define INTERRUPT_TIMER0           1   // Timer 0 Overflow
           =5 #define INTERRUPT_INT1             2   // External Interrupt 1
           =5 #define INTERRUPT_TIMER1           3   // Timer 1 Overflow
           =5 #define INTERRUPT_UART0            4   // UART0
           =5 #define INTERRUPT_TIMER2           5   // Timer 2 Overflow
           =5 #define INTERRUPT_SPI0             6   // SPI0
           =5 #define INTERRUPT_SMBUS0           7   // SMBus0 Interface
           =5 #define INTERRUPT_ADC0_WINDOW      8   // ADC0 Window Comparison
           =5 #define INTERRUPT_ADC0_EOC         9   // ADC0 End Of Conversion
           =5 #define INTERRUPT_PCA0            10   // PCA0 Peripheral
           =5 #define INTERRUPT_COMPARATOR0     11   // Comparator 0 Comparison
           =5 #define INTERRUPT_COMPARATOR1     12   // Comparator 1 Comparison
           =5 #define INTERRUPT_TIMER3          13   // Timer 3 Overflow
           =5 #define INTERRUPT_LIN0            14   // LIN Bus Interrupt
           =5 #define INTERRUPT_VREG            15   // Voltage Regulator
           =5 #define INTERRUPT_CAN0            16   // CAN Bus Interrupt
           =5 #define INTERRUPT_PORT_MATCH      17   // Port Match
           =5 #define INTERRUPT_UART1           18   // UART1
           =5 #define INTERRUPT_PCA1            19   // PCA1 Peripheral
           =5 #define INTERRUPT_COMPARATOR2     20   // Comparator 2 Comparison
           =5 #define INTERRUPT_TIMER4          21   // Timer 4 Overflow
           =5 #define INTERRUPT_TIMER5          22   // Timer 5 Overflow
           =5 
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 // SFR Page Definitions
           =5 //-----------------------------------------------------------------------------
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 66  

           =5 
           =5 #define  CONFIG_PAGE       0x0F        // System and Port Configuration Page
           =5 #define  ACTIVE_PAGE       0x00        // Active Use Page
           =5 #define  ACTIVE2_PAGE      0x10        // Active Use Page 2
           =5 #define  CAN0_PAGE         0x0C        // CAN0 Registers
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 // SDCC PDATA External Memory Paging Support
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 #if defined SDCC
           =5 
           =5 SFR(_XPAGE, 0xAA); // Point to the EMI0CN register
           =5 
           =5 #endif
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 // Header File PreProcessor Directive
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 #endif                                 // #define C8051F580_DEFS_H
 607      =5  
 608      =5  //-----------------------------------------------------------------------------
 609      =5  // End Of File
 610      =5  //-----------------------------------------------------------------------------
   9      =4  void TIMER2_Init(U16 counts);
  10      =4  void Timer2_Set_Callback_Ptr(void (*funct)(void));
  11      =4  void Clear_Timer2_ISR_Flag(void);
  12      =4  void Increase_G_systick(void);
  13      =4  U32 Get_G_systick(void);
  14      =4  #endif
  11      =3  #include "Uart.h"
   1      =4  /*
   2      =4   *  Created on: Apr 21, 2025
   3      =4   *      Author: Hoangtd2000
   4      =4   */
   5      =4  #ifndef _UART_H_
   6      =4  #define _UART_H_
   7      =4  #include <compiler_defs.h>
   1      =5  //-----------------------------------------------------------------------------
   2      =5  // compiler_defs.h
   3      =5  //-----------------------------------------------------------------------------
   4      =5  // Portions of this file are copyright Maarten Brock
   5      =5  // http://sdcc.sourceforge.net
   6      =5  // Portions of this file are copyright 2010, Silicon Laboratories, Inc.
   7      =5  // http://www.silabs.com
   8      =5  //
   9      =5  // GNU LGPL boilerplate:
  10      =5  /** This library is free software; you can redistribute it and/or
  11      =5    * modify it under the terms of the GNU Lesser General Public
  12      =5    * License as published by the Free Software Foundation; either
  13      =5    * version 2.1 of the License, or (at your option) any later version.
  14      =5    *
  15      =5    * This library is distributed in the hope that it will be useful,
  16      =5    * but WITHOUT ANY WARRANTY; without even the implied warranty of
  17      =5    * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  18      =5    * Lesser General Public License for more details.
  19      =5    *
  20      =5    * You should have received a copy of the GNU Lesser General Public
  21      =5    * License along with this library; if not, write to the Free Software
  22      =5    * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  23      =5    *
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 67  

  24      =5    * In other words, you are welcome to use, share and improve this program.
  25      =5    * You are forbidden to forbid anyone else to use, share and improve
  26      =5    * what you give them. Help stamp out software-hoarding!
  27      =5  **/
  28      =5  // Program Description:
  29      =5  //
  30      =5  // **Important Note**: This header file should be included before including
  31      =5  // a device-specific header file such as C8051F300_defs.h.
  32      =5  //
  33      =5  // Macro definitions to accomodate 8051 compiler differences in specifying
  34      =5  // special function registers and other 8051-specific features such as NOP
  35      =5  // generation, and locating variables in memory-specific segments.  The
  36      =5  // compilers are identified by their unique predefined macros. See also:
  37      =5  // http://predef.sourceforge.net/precomp.html
  38      =5  //
  39      =5  // SBIT and SFR define special bit and special function registers at the given
  40      =5  // address. SFR16 and SFR32 define sfr combinations at adjacent addresses in
  41      =5  // little-endian format. SFR16E and SFR32E define sfr combinations without
  42      =5  // prerequisite byte order or adjacency. None of these multi-byte sfr
  43      =5  // combinations will guarantee the order in which they are accessed when read
  44      =5  // or written.
  45      =5  //
  46      =5  // SFR16X and SFR32X for 16 bit and 32 bit xdata registers are not defined
  47      =5  // to avoid portability issues because of compiler endianness.
  48      =5  //
  49      =5  // Example:
  50      =5  // // my_mcu.c: main 'c' file for my mcu
  51      =5  // #include <compiler_defs.h>  // this file
  52      =5  // #include <C8051xxxx_defs.h> // SFR definitions for specific MCU target
  53      =5  //
  54      =5  // SBIT  (P0_1, 0x80, 1);      // Port 0 pin 1
  55      =5  // SFR   (P0, 0x80);           // Port 0
  56      =5  // SFRX  (CPUCS, 0xE600);      // Cypress FX2 Control and Status register in
  57      =5  //                             // xdata memory at 0xE600
  58      =5  // SFR16 (TMR2, 0xCC);         // Timer 2, lsb at 0xCC, msb at 0xCD
  59      =5  // SFR16E(TMR0, 0x8C8A);       // Timer 0, lsb at 0x8A, msb at 0x8C
  60      =5  // SFR32 (MAC0ACC, 0x93);      // SiLabs C8051F120 32 bits MAC0 Accumulator,
  61      =5  //                             // lsb at 0x93, msb at 0x96
  62      =5  // SFR32E(SUMR, 0xE5E4E3E2);   // TI MSC1210 SUMR 32 bits Summation register,
  63      =5  //                             // lsb at 0xE2, msb at 0xE5
  64      =5  //
  65      =5  // Target:         C8051xxxx
  66      =5  // Tool chain:     Generic
  67      =5  // Command Line:   None
  68      =5  // 
  69      =5  // Release 2.6 - 14 DEC 2012 (GO)
  70      =5  //        -Added define for deprecated SDCC keyword 'at'
  71      =5  // Release 2.5 - 12 SEP 2012 (TP)
  72      =5  //    -Added defines for deprecated SDCC keywords bit and code
  73      =5  // Release 2.4 - 27 AUG 2012 (TP)
  74      =5  //    -Added defines for deprecated SDCC keywords interrupt, _asm, and _endasm
  75      =5  // Release 2.3 - 27 MAY 2010 (DM)
  76      =5  //    -Removed 'LOCATED_VARIABLE' pragma from Keil because it is not supported
  77      =5  // Release 2.2 - 06 APR 2010 (ES)
  78      =5  //    -Removed 'PATHINCLUDE' pragma from Raisonance section
  79      =5  // Release 2.1 - 16 JUL 2009 (ES)
  80      =5  //    -Added SEGMENT_POINTER macro definitions for SDCC, Keil, and Raisonance
  81      =5  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for Raisonance
  82      =5  // Release 2.0 - 19 MAY 2009 (ES)
  83      =5  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for SDCC and Keil
  84      =5  // Release 1.9 - 23 OCT 2008 (ES)
  85      =5  //    -Updated Hi-Tech INTERRUPT and INTERRUPT_USING macro definitions
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 68  

  86      =5  //    -Added SFR16 macro defintion for Hi-Tech
  87      =5  // Release 1.8 - 31 JUL 2008 (ES)
  88      =5  //    -Added INTERRUPT_USING and FUNCTION_USING macro's
  89      =5  //    -Added macro's for IAR
  90      =5  //    -Corrected Union definitions for Hi-Tech and added SFR16 macro defintion
  91      =5  // Release 1.7 - 11 SEP 2007 (BW)
  92      =5  //    -Added support for Raisonance EVAL 03.03.42 and Tasking Eval 7.2r1
  93      =5  // Release 1.6 - 27 AUG 2007 (BW)
  94      =5  //    -Updated copyright notice per agreement with Maartin Brock
  95      =5  //    -Added SDCC 2.7.0 "compiler.h" bug fixes
  96      =5  //    -Added memory segment defines (SEG_XDATA, for example)
  97      =5  // Release 1.5 - 24 AUG 2007 (BW)
  98      =5  //    -Added support for NOP () macro
  99      =5  //    -Added support for Hi-Tech ver 9.01
 100      =5  // Release 1.4 - 07 AUG 2007 (PKC)
 101      =5  //    -Removed FID and fixed formatting.
 102      =5  // Release 1.3 - 30 SEP 2007 (TP)
 103      =5  //    -Added INTERRUPT_PROTO_USING to properly support ISR context switching
 104      =5  //     under SDCC.
 105      =5  // Release 1.2 - (BW)
 106      =5  //    -Added support for U8,U16,U32,S8,S16,S32,UU16,UU32 data types
 107      =5  // Release 1.1 - (BW)
 108      =5  //    -Added support for INTERRUPT, INTERRUPT_USING, INTERRUPT_PROTO,
 109      =5  //     SEGMENT_VARIABLE, VARIABLE_SEGMENT_POINTER,
 110      =5  //     SEGMENT_VARIABLE_SEGMENT_POINTER, and LOCATED_VARIABLE
 111      =5  // Release 1.0 - 29 SEP 2006 (PKC)
 112      =5  //    -Initial revision
 113      =5  
 114      =5  //-----------------------------------------------------------------------------
 115      =5  // Header File Preprocessor Directive
 116      =5  //-----------------------------------------------------------------------------
 117      =5  
 118      =5  #ifndef COMPILER_DEFS_H
           =5 #define COMPILER_DEFS_H
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 // Macro definitions
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 // SDCC - Small Device C Compiler
           =5 // http://sdcc.sourceforge.net
           =5 
           =5 #if defined SDCC
           =5 
           =5 #if (SDCC >= 300)
           =5 
           =5 #define interrupt __interrupt
           =5 #define _asm __asm
           =5 #define _endasm __endasm
           =5 #define bit __bit
           =5 #define code __code
           =5 #define at __at
           =5 
           =5 #endif
           =5 
           =5 # define SEG_GENERIC
           =5 # define SEG_FAR   __xdata
           =5 # define SEG_DATA  __data
           =5 # define SEG_NEAR  __data
           =5 # define SEG_IDATA __idata
           =5 # define SEG_XDATA __xdata
           =5 # define SEG_PDATA __pdata
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 69  

           =5 # define SEG_CODE  __code
           =5 # define SEG_BDATA __bdata
           =5 
           =5 # define SBIT(name, addr, bit)  __sbit  __at(addr+bit)                  name
           =5 # define SFR(name, addr)        __sfr   __at(addr)                      name
           =5 # define SFRX(name, addr)       xdata volatile unsigned char __at(addr) name
           =5 # define SFR16(name, addr)      __sfr16 __at(((addr+1U)<<8) | addr)     name
           =5 # define SFR16E(name, fulladdr) __sfr16 __at(fulladdr)                  name
           =5 # define SFR32(name, addr)      __sfr32 __at(((addr+3UL)<<24) | ((addr+2UL)<<16) | ((addr+1UL)<<8) | addr)
             - name
           =5 # define SFR32E(name, fulladdr) __sfr32 __at(fulladdr)                  name
           =5 
           =5 # define INTERRUPT(name, vector) void name (void) interrupt (vector)
           =5 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =5 # define INTERRUPT_PROTO(name, vector) void name (void) interrupt (vector)
           =5 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =5 
           =5 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using (regnum
             -)
           =5 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter) using (
             -regnum)
           =5 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =5 
           =5 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =5 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =5 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =5 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =5 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment at (addr) vartype name = init
           =5 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) locsegment at (addr) vartype name
           =5 
           =5 // used with UU16
           =5 # define LSB 0
           =5 # define MSB 1
           =5 
           =5 // used with UU32 (b0 is least-significant byte)
           =5 # define b0 0
           =5 # define b1 1
           =5 # define b2 2
           =5 # define b3 3
           =5 
           =5 typedef unsigned char U8;
           =5 typedef unsigned int U16;
           =5 typedef unsigned long U32;
           =5 
           =5 typedef signed char S8;
           =5 typedef signed int S16;
           =5 typedef signed long S32;
           =5 
           =5 typedef union UU16
           =5 {
           =5    U16 U16;
           =5    S16 S16;
           =5    U8 U8[2];
           =5    S8 S8[2];
           =5 } UU16;
           =5 
           =5 typedef union UU32
           =5 {
           =5    U32 U32;
           =5    S32 S32;
           =5    UU16 UU16[2];
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 70  

           =5    U16 U16[2];
           =5    S16 S16[2];
           =5    U8 U8[4];
           =5    S8 S8[4];
           =5 } UU32;
           =5 
           =5 // NOP () macro support
           =5 #define NOP() _asm NOP _endasm
           =5 
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 // Raisonance (must be placed before Keil C51)
           =5 // http://www.raisonance.com
           =5 
           =5 #elif defined __RC51__
           =5 
           =5 //#error Raisonance C51 detected.
           =5 
           =5 # define SEG_GENERIC generic     //SEG_GENERIC only applies to pointers in Raisonance, not variables.
           =5 # define SEG_FAR   xdata
           =5 # define SEG_DATA  data
           =5 # define SEG_NEAR  data
           =5 # define SEG_IDATA idata
           =5 # define SEG_XDATA xdata
           =5 # define SEG_PDATA pdata
           =5 # define SEG_CODE  code
           =5 # define SEG_BDATA bdata
           =5 
           =5 # define SBIT(name, addr, bit)  at (addr+bit) sbit         name
           =5 # define SFR(name, addr)        sfr at addr                name
           =5 # define SFR16(name, addr)      sfr16 at addr              name
           =5 # define SFR16E(name, fulladdr) /* not supported */
           =5 # define SFR32(name, fulladdr)  /* not supported */
           =5 # define SFR32E(name, fulladdr) /* not supported */
           =5 
           =5 # define INTERRUPT(name, vector) void name (void) interrupt vector
           =5 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =5 # define INTERRUPT_PROTO(name, vector) void name (void)
           =5 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =5 
           =5 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
           =5 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =5 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =5 
           =5 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =5 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =5 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =5 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =5 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) at addr locsegment vartype name
           =5 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) at addr locsegment vartype name
           =5 
           =5 
           =5 // used with UU16
           =5 # define LSB 1
           =5 # define MSB 0
           =5 
           =5 // used with UU32 (b0 is least-significant byte)
           =5 # define b0 3
           =5 # define b1 2
           =5 # define b2 1
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 71  

           =5 # define b3 0
           =5 
           =5 typedef unsigned char U8;
           =5 typedef unsigned int U16;
           =5 typedef unsigned long U32;
           =5 
           =5 typedef signed char S8;
           =5 typedef signed int S16;
           =5 typedef signed long S32;
           =5 
           =5 typedef union UU16
           =5 {
           =5    U16 U16;
           =5    S16 S16;
           =5    U8 U8[2];
           =5    S8 S8[2];
           =5 } UU16;
           =5 
           =5 typedef union UU32
           =5 {
           =5    U32 U32;
           =5    S32 S32;
           =5    UU16 UU16[2];
           =5    U16 U16[2];
           =5    S16 S16[2];
           =5    U8 U8[4];
           =5    S8 S8[4];
           =5 } UU32;
           =5 
           =5 // NOP () macro support -- NOP is opcode 0x00
           =5 #define NOP() asm { 0x00 }
           =5 
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 
           =5 // Keil C51
           =5 // http://www.keil.com
           =5 
           =5 #elif defined __C51__
           =5 
           =5 //#error Keil C51 detected.
           =5 
           =5 # define SEG_GENERIC
           =5 # define SEG_FAR   xdata
           =5 # define SEG_DATA  data
           =5 # define SEG_NEAR  data
           =5 # define SEG_IDATA idata
           =5 # define SEG_XDATA xdata
           =5 # define SEG_PDATA pdata
           =5 # define SEG_CODE  code
           =5 # define SEG_BDATA bdata
           =5 
           =5 # define SBIT(name, addr, bit)  sbit  name = addr^bit
           =5 # define SFR(name, addr)        sfr   name = addr
           =5 # define SFR16(name, addr)      sfr16 name = addr
           =5 # define SFR16E(name, fulladdr) /* not supported */
           =5 # define SFR32(name, fulladdr)  /* not supported */
           =5 # define SFR32E(name, fulladdr) /* not supported */
           =5 
           =5 # define INTERRUPT(name, vector) void name (void) interrupt vector
           =5 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 72  

           =5 # define INTERRUPT_PROTO(name, vector) void name (void)
           =5 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =5 
           =5 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
           =5 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =5 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =5 
           =5 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =5 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =5 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =5 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =5 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) vartype locsegment name _at_ addr
           =5 
           =5 // used with UU16
           =5 # define LSB 1
           =5 # define MSB 0
           =5 
           =5 // used with UU32 (b0 is least-significant byte)
           =5 # define b0 3
           =5 # define b1 2
           =5 # define b2 1
           =5 # define b3 0
           =5 
           =5 typedef unsigned char U8;
           =5 typedef unsigned int U16;
           =5 typedef unsigned long U32;
           =5 
           =5 typedef signed char S8;
           =5 typedef signed int S16;
           =5 typedef signed long S32;
           =5 
           =5 typedef union UU16
           =5 {
           =5    U16 U16;
           =5    S16 S16;
           =5    U8 U8[2];
           =5    S8 S8[2];
           =5 } UU16;
           =5 
           =5 typedef union UU32
           =5 {
           =5    U32 U32;
           =5    S32 S32;
           =5    UU16 UU16[2];
           =5    U16 U16[2];
           =5    S16 S16[2];
           =5    U8 U8[4];
           =5    S8 S8[4];
           =5 } UU32;
           =5 
           =5 // NOP () macro support
           =5 extern void _nop_ (void);
           =5 #define NOP() _nop_()
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 // Hi-Tech 8051
           =5 // http://www.htsoft.com
           =5 
           =5 #elif defined HI_TECH_C
           =5 
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 73  

           =5 # define SEG_GENERIC
           =5 # define SEG_FAR   far
           =5 # define SEG_DATA  data
           =5 # define SEG_NEAR  near
           =5 # define SEG_IDATA idata
           =5 # define SEG_XDATA xdata
           =5 # define SEG_PDATA pdata
           =5 # define SEG_CODE  code
           =5 # define SEG_BDATA bdata
           =5 
           =5 
           =5 # define SBIT(name, addr, thebit) static volatile bit name @ (addr + thebit)
           =5 # define SFR(name, addr)          static volatile unsigned char name @ addr
           =5 # define SFR16(name, addr)        static volatile unsigned int name @ addr
           =5 # define SFR16E(name, fulladdr) /* not supported */
           =5 # define SFR32(name, fulladdr)  /* not supported */
           =5 # define SFR32E(name, fulladdr) /* not supported */
           =5 
           =5 # define INTERRUPT(name, vector)       void name (void) interrupt vector
           =5 # define INTERRUPT_PROTO(name, vector)
           =5 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =5 # define INTERRUPT_PROTO_USING(name, vector, regnum)
           =5 
           =5 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =5 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =5 // Note: Hi-Tech does not support functions using different register banks. Register
           =5 //       banks can only be specified in interrupts. If a function is called from
           =5 //       inside an interrupt, it will use the same register bank as the interrupt.
           =5 
           =5 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =5 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =5 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =5 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment vartype name @ addr
           =5 
           =5 // used with UU16
           =5 # define LSB 0
           =5 # define MSB 1
           =5 
           =5 // used with UU32 (b0 is least-significant byte)
           =5 # define b0 0
           =5 # define b1 1
           =5 # define b2 2
           =5 # define b3 3
           =5 
           =5 typedef unsigned char U8;
           =5 typedef unsigned int U16;
           =5 typedef unsigned long U32;
           =5 
           =5 typedef signed char S8;
           =5 typedef signed int S16;
           =5 typedef signed long S32;
           =5 
           =5 typedef union UU16
           =5 {
           =5    U16 U16;
           =5    S16 S16;
           =5    U8 U8[2];
           =5    S8 S8[2];
           =5 } UU16;
           =5 
           =5 typedef union UU32
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 74  

           =5 {
           =5    U32 U32;
           =5    S32 S32;
           =5    UU16 UU16[2];
           =5    U16 U16[2];
           =5    S16 S16[2];
           =5    U8 U8[4];
           =5    S8 S8[4];
           =5 } UU32;
           =5 
           =5 // NOP () macro support
           =5 #define NOP() asm(" nop ")
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 // Tasking / Altium
           =5 // http://www.altium.com/tasking
           =5 
           =5 
           =5 #elif defined _CC51
           =5 
           =5 # define SEG_GENERIC
           =5 # define SEG_FAR   _xdat
           =5 # define SEG_DATA  _data
           =5 # define SEG_NEAR  _data
           =5 # define SEG_IDATA _idat
           =5 # define SEG_XDATA _xdat
           =5 # define SEG_PDATA _pdat
           =5 # define SEG_CODE  _rom
           =5 # define SEG_BDATA _bdat
           =5 
           =5 # define SBIT(name, addr, bit)  _sfrbit  name _at(addr+bit)
           =5 # define SFR(name, addr)        _sfrbyte name _at(addr)
           =5 # define SFRX(name, addr)       _xdat volatile unsigned char name _at(addr)
           =5 #if _CC51 > 71
           =5 # define SFR16(name, addr)      _sfrword _little name _at(addr)
           =5 #else
           =5 # define SFR16(name, addr)      /* not supported */
           =5 #endif
           =5 # define SFR16E(name, fulladdr) /* not supported */
           =5 # define SFR32(name, fulladdr)  /* not supported */
           =5 # define SFR32E(name, fulladdr) /* not supported */
           =5 
           =5 # define INTERRUPT(name, vector) _interrupt (vector) void name (void)
           =5 # define INTERRUPT_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =5 # define INTERRUPT_PROTO(name, vector) _interrupt (vector) void name (void)
           =5 # define INTERRUPT_PROTO_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =5 
           =5 // When calling FUNCTION_USING in Tasking, the function must be called from an interrupt or Main which
           =5 // is also using the same register bank. If not, the compiler will generate an error.
           =5 # define FUNCTION_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (parameter
             -)
           =5 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (par
             -ameter)
           =5 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =5 
           =5 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =5 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =5 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =5 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) vartype locsegment name _at( addr )
           =5 
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 75  

           =5 // used with UU16
           =5 # define LSB 1
           =5 # define MSB 0
           =5 
           =5 // used with UU32 (b0 is least-significant byte)
           =5 # define b0 3
           =5 # define b1 2
           =5 # define b2 1
           =5 # define b3 0
           =5 
           =5 typedef unsigned char U8;
           =5 typedef unsigned int U16;
           =5 typedef unsigned long U32;
           =5 
           =5 typedef signed char S8;
           =5 typedef signed int S16;
           =5 typedef signed long S32;
           =5 
           =5 typedef union UU16
           =5 {
           =5    U16 U16;
           =5    S16 S16;
           =5    U8 U8[2];
           =5    S8 S8[2];
           =5 } UU16;
           =5 
           =5 typedef union UU32
           =5 {
           =5    U32 U32;
           =5    S32 S32;
           =5    UU16 UU16[2];
           =5    U16 U16[2];
           =5    S16 S16[2];
           =5    U8 U8[4];
           =5    S8 S8[4];
           =5 } UU32;
           =5 
           =5 // NOP () macro support
           =5 extern void _nop (void);
           =5 #define NOP() _nop()
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 
           =5 // IAR 8051
           =5 // http://www.iar.com
           =5 
           =5 #elif defined __ICC8051__
           =5 
           =5 #include <stdbool.h>
           =5 #include <intrinsics.h>
           =5 
           =5 # define SBIT(name, addr, bit)  __bit __no_init volatile bool name @ (addr+bit)
           =5 # define SFR(name, addr)        __sfr __no_init volatile unsigned char name @ addr
           =5 # define SFRX(name, addr)       __xdata __no_init volatile unsigned char name @ addr
           =5 # define SFR16(name, addr)      __sfr __no_init volatile unsigned int  name @ addr
           =5 # define SFR16E(name, fulladdr) /* not supported */
           =5 # define SFR32(name, fulladdr) /* not supported */
           =5 # define SFR32E(name, fulladdr) /* not supported */
           =5 
           =5 # define SEG_GENERIC __generic
           =5 # define SEG_FAR  __xdata
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 76  

           =5 # define SEG_DATA __data
           =5 # define SEG_NEAR __data
           =5 # define SEG_IDATA __idata
           =5 # define SEG_XDATA __xdata
           =5 # define SEG_PDATA __pdata
           =5 # define SEG_CODE  __code
           =5 # define SEG_BDATA __bdata
           =5 
           =5 #define bit bool
           =5 
           =5 # define _PPTOSTR_(x) #x
           =5 # define _PPARAM_(address) _PPTOSTR_(vector=address * 8 + 3)
           =5 # define _PPARAM2_(regbank) _PPTOSTR_(register_bank=regbank)
           =5 # define INTERRUPT(name, vector) _Pragma(_PPARAM_(vector)) __interrupt void name(void)
           =5 # define INTERRUPT_PROTO(name, vector)  __interrupt void name(void)
           =5 # define INTERRUPT_USING(name, vector, regnum) _Pragma(_PPARAM2_(regnum)) _Pragma(_PPARAM_(vector)) __inte
             -rrupt void name(void)
           =5 # define INTERRUPT_PROTO_USING(name, vector, regnum) __interrupt void name(void)
           =5 
           =5 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =5 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =5 // Note: IAR does not support functions using different register banks. Register
           =5 //       banks can only be specified in interrupts. If a function is called from
           =5 //       inside an interrupt, it will use the same register bank as the interrupt.
           =5 
           =5 # define SEGMENT_VARIABLE(name, vartype, locsegment)  locsegment vartype name
           =5 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment  * name
           =5 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =5 
           =5 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment __no_init vartype name @ addr
           =5 
           =5 // used with UU16
           =5 # define LSB 0
           =5 # define MSB 1
           =5 
           =5 // used with UU32 (b0 is least-significant byte)
           =5 # define b0 0
           =5 # define b1 1
           =5 # define b2 2
           =5 # define b3 3
           =5 
           =5 typedef unsigned char U8;
           =5 typedef unsigned int U16;
           =5 typedef unsigned long U32;
           =5 
           =5 typedef signed char S8;
           =5 typedef signed int S16;
           =5 typedef signed long S32;
           =5 
           =5 typedef union UU16
           =5 {
           =5    U16 U16;
           =5    S16 S16;
           =5    U8 U8[2];
           =5    S8 S8[2];
           =5 } UU16;
           =5 
           =5 typedef union UU32
           =5 {
           =5    U32 U32;
           =5    S32 S32;
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 77  

           =5    UU16 UU16[2];
           =5    U16 U16[2];
           =5    S16 S16[2];
           =5    U8 U8[4];
           =5    S8 S8[4];
           =5 } UU32;
           =5 
           =5 
           =5 #define NOP() __no_operation();
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 // Crossware
           =5 // http://www.crossware.com
           =5 
           =5 #elif defined _XC51_VER
           =5 # define SBIT(name, addr, bit)  _sfrbit  name = (addr+bit)
           =5 # define SFR(name, addr)        _sfr     name = addr
           =5 # define SFR16(name, addr)      _sfrword name = addr
           =5 # define SFR16E(name, fulladdr) /* not supported */
           =5 # define SFR32(name, fulladdr)  /* not supported */
           =5 # define SFR32E(name, fulladdr) /* not supported */
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 // Wickenhäuser
           =5 // http://www.wickenhaeuser.de
           =5 
           =5 #elif defined __UC__
           =5 # define SBIT(name, addr, bit)  unsigned char bit  name @ (addr+bit)
           =5 # define SFR(name, addr)        near unsigned char name @ addr
           =5 # define SFR16(name, addr)      /* not supported */
           =5 # define SFR16E(name, fulladdr) /* not supported */
           =5 # define SFR32(name, fulladdr)  /* not supported */
           =5 # define SFR32E(name, fulladdr) /* not supported */
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 // Default
           =5 // Unknown compiler
           =5 
           =5 #else
           =5 # warning unrecognized compiler
           =5 # define SBIT(name, addr, bit)  volatile bool           name
           =5 # define SFR(name, addr)        volatile unsigned char  name
           =5 # define SFRX(name, addr)       volatile unsigned char  name
           =5 # define SFR16(name, addr)      volatile unsigned short name
           =5 # define SFR16E(name, fulladdr) volatile unsigned short name
           =5 # define SFR32(name, fulladdr)  volatile unsigned long  name
           =5 # define SFR32E(name, fulladdr) volatile unsigned long  name
           =5 
           =5 #endif
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 // Header File PreProcessor Directive
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 #endif                                 // #define COMPILER_DEFS_H
 689      =5  
 690      =5  //-----------------------------------------------------------------------------
 691      =5  // End Of File
 692      =5  //-----------------------------------------------------------------------------
   8      =4  #include <C8051F580_defs.h> // SFR declarations
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 78  

   1      =5  //-----------------------------------------------------------------------------
   2      =5  // C8051F580_defs.h
   3      =5  //-----------------------------------------------------------------------------
   4      =5  // Copyright 2008, Silicon Laboratories, Inc.
   5      =5  // http://www.silabs.com
   6      =5  //
   7      =5  // Program Description:
   8      =5  //
   9      =5  // Register/bit definitions for the C8051F58x family.
  10      =5  // **Important Note**: The compiler_defs.h header file should be included
  11      =5  // before including this header file.
  12      =5  //
  13      =5  // Target:         C8051F580/1/2/3/4/5/6/7,8/9-F590/1
  14      =5  // Tool chain:     Generic
  15      =5  // Command Line:   None
  16      =5  //
  17      =5  // Release 0.6 - 20 AUG 2012 (TP)
  18      =5  //    -Added #define for _XPAGE to provide support for SDCC memory paging
  19      =5  //     (pdata)
  20      =5  //
  21      =5  // Release 0.5 - 10 SEP 2011 (GP)
  22      =5  //    - Fixed SFR16 definition for CAN0IF2MC
  23      =5  //
  24      =5  // Release 0.4 - 08 OCT 2010 (TP)
  25      =5  //    - Fixed bit definitions for SCON0
  26      =5  //
  27      =5  // Release 0.3 - 01 APR 2009 (GP)
  28      =5  //    - Added SN0-SN3
  29      =5  //
  30      =5  // Release 0.2 - 29 JUL 2008 (ADT)
  31      =5  //    - Added Timer 4 bit definitions
  32      =5  //
  33      =5  // Release 0.1 - 09 JUL 2008 (GP)
  34      =5  //    - Initial Revision
  35      =5  //
  36      =5  //-----------------------------------------------------------------------------
  37      =5  // Header File Preprocessor Directive
  38      =5  //-----------------------------------------------------------------------------
  39      =5  
  40      =5  #ifndef C8051F580_DEFS_H
           =5 #define C8051F580_DEFS_H
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 // Page 0, Page 1 and Page F Registers
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 SFR (P0, 0x80);                        // Port 0 Latch
           =5 SFR (SP, 0x81);                        // Stack Pointer
           =5 SFR (DPL, 0x82);                       // Data Pointer Low
           =5 SFR (DPH, 0x83);                       // Data Pointer High
           =5 SFR (SFR0CN, 0x84);                    // SFR Page Control
           =5 SFR (SFRNEXT, 0x85);                   // SFR stack next page
           =5 SFR (SFRLAST, 0x86);                   // SFR stack last page
           =5 SFR (PCON, 0x87);                      // Power Control
           =5 SFR (TCON, 0x88);                      // Timer/Counter Control
           =5 SFR (TMOD, 0x89);                      // Timer/Counter Mode
           =5 SFR (TL0, 0x8A);                       // Timer/Counter 0 Low
           =5 SFR (TL1, 0x8B);                       // Timer/Counter 1 Low
           =5 SFR (TH0, 0x8C);                       // Timer/Counter 0 High
           =5 SFR (TH1, 0x8D);                       // Timer/Counter 1 High
           =5 SFR (CKCON, 0x8E);                     // Clock Control
           =5 SFR (PSCTL, 0x8F);                     // Program Store R/W Control
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 79  

           =5 SFR (CLKSEL, 0x8F);                    // System clock select
           =5 SFR (P1, 0x90);                        // Port 1 Latch
           =5 SFR (TMR3CN, 0x91);                    // Timer/Counter 3 Control
           =5 SFR (TMR5CN, 0x91);                    // Timer/Counter 5 Control
           =5 SFR (TMR3RLL, 0x92);                   // Timer/Counter 3 Reload Low
           =5 SFR (TMR5CAPL, 0x92);                  // Timer/Counter 5 Capture Low
           =5 SFR (TMR3RLH, 0x93);                   // Timer/Counter 3 Reload High
           =5 SFR (TMR5CAPH, 0x93);                  // Timer/Counter 5 Capture High
           =5 SFR (TMR3L, 0x94);                     // Timer/Counter 3 Low
           =5 SFR (TMR5L, 0x94);                     // Timer/Counter 5 Low
           =5 SFR (TMR3H, 0x95);                     // Timer/Counter 3 High
           =5 SFR (TMR5H, 0x95);                     // Timer/Counter 5 High
           =5 SFR (TMR5CF, 0x96);                    // Timer/Counter 5 Configuration
           =5 SFR (CLKMUL, 0x97);                    // Clock Multiplier
           =5 SFR (SCON0, 0x98);                     // UART0 Control
           =5 SFR (SCON1, 0x98);                     // UART1 Control
           =5 SFR (SBUF0, 0x99);                     // UART0 Data Buffer
           =5 SFR (SBUF1, 0x99);                     // UART1 Data Buffer
           =5 SFR (CPT0CN, 0x9A);                    // Comparator 0 Control
           =5 SFR (CPT2CN, 0x9A);                    // Comparator 2 Control
           =5 SFR (CPT0MD, 0x9B);                    // Comparator 0 Mode
           =5 SFR (CPT2MD, 0x9B);                    // Comparator 2 Mode
           =5 SFR (CPT0MX, 0x9C);                    // Comparator 0 Mux
           =5 SFR (CPT2MX, 0x9C);                    // Comparator 2 Mux
           =5 SFR (CPT1CN, 0x9D);                    // Comparator 1 Control
           =5 SFR (CPT1MD, 0x9E);                    // Comparator 0 Mode
           =5 SFR (OSCIFIN, 0x9E);                   // Internal Oscillator Fine Control
           =5 SFR (CPT1MX, 0x9F);                    // Comparator 1 Mux
           =5 SFR (OSCXCN, 0x9F);                    // External Oscillator Control
           =5 SFR (P2, 0xA0);                        // Port 2 Latch
           =5 SFR (SPI0CFG, 0xA1);                   // SPI0 Configuration
           =5 SFR (OSCICN, 0xA1);                    // Internal Oscillator Control
           =5 SFR (SPI0CKR, 0xA2);                   // SPI0 Clock rate control
           =5 SFR (OSCICRS, 0xA2);                   // Internal Oscillator Coarse Control
           =5 SFR (SPI0DAT, 0xA3);                   // SPI0 Data Buffer
           =5 SFR (P0MDOUT, 0xA4);                   // Port 0 Output Mode
           =5 SFR (P1MDOUT, 0xA5);                   // Port 1 Output Mode
           =5 SFR (P2MDOUT, 0xA6);                   // Port 2 Output Mode
           =5 SFR (SFRPAGE, 0xA7);                   // SFR Page Select
           =5 SFR (IE, 0xA8);                        // Interrupt Enable
           =5 SFR (SMOD0, 0xA9);                     // Serial Port 0 Control
           =5 SFR (EMI0CN, 0xAA);                    // EMIF Control
           =5 SFR (EMI0TC, 0xAA);                    // EMIF Timing control
           =5 SFR (SBCON0, 0xAB);                    // UART0 Baud Rate Generator Control
           =5 SFR (SBRLL0, 0xAC);                    // UART0 Baud Rate Generator Low
           =5 SFR (SBRLH0, 0xAD);                    // UART0 Baud Rate Generator High
           =5 SFR (P3MAT, 0xAE);                     // Port 3 Match
           =5 SFR (P3MDOUT, 0xAE);                   // Port 3 Mode
           =5 SFR (P3MASK, 0xAF);                    // Port 3 Mask
           =5 SFR (P4MDOUT, 0xAF);                   // Port 4 Mode
           =5 SFR (P3, 0xB0);                        // Port 3 Latch
           =5 SFR (P2MAT, 0xB1);                     // Port 2 Match
           =5 SFR (P2MASK, 0xB2);                    // Port 2 Mask
           =5 SFR (EMI0CF, 0xB2);                    // EMIF Configuration
           =5 SFR (P4, 0xB5);                        // Port 4 Latch
           =5 SFR (FLSCL, 0xB6);                     // Flash Scale
           =5 SFR (FLKEY, 0xB7);                     // Flash access limit
           =5 SFR (IP, 0xB8);                        // Interrupt Priority
           =5 SFR (SMB0ADR, 0xB9);                   // SMBus0 Slave address
           =5 SFR (ADC0TK, 0xBA);                    // ADC0 Tracking Mode Select
           =5 SFR (SMB0ADM, 0xBA);                   // SMBus0 Address Mask
           =5 SFR (ADC0MX, 0xBB);                    // AMUX0 Channel select
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 80  

           =5 SFR (ADC0CF, 0xBC);                    // AMUX0 Channel configuration
           =5 SFR (ADC0L, 0xBD);                     // ADC0 Data Low
           =5 SFR (ADC0H, 0xBE);                     // ADC0 Data High
           =5 SFR (SMB0CN, 0xC0);                    // SMBus0 Control
           =5 SFR (SMB0CF, 0xC1);                    // SMBus0 Configuration
           =5 SFR (SMB0DAT, 0xC2);                   // SMBus0 Data
           =5 SFR (ADC0GTL, 0xC3);                   // ADC0 Greater-Than Compare Low
           =5 SFR (ADC0GTH, 0xC4);                   // ADC0 Greater-Than Compare High
           =5 SFR (ADC0LTL, 0xC5);                   // ADC0 Less-Than Compare Word Low
           =5 SFR (ADC0LTH, 0xC6);                   // ADC0 Less-Than Compare Word High
           =5 SFR (XBR3, 0xC6);                      // Port I/O Crossbar Control 3
           =5 SFR (XBR2, 0xC7);                      // Port I/O Crossbar Control 2
           =5 SFR (TMR2CN, 0xC8);                    // Timer/Counter 2 Control
           =5 SFR (TMR4CN, 0xC8);                    // Timer/Counter 4 Control
           =5 SFR (REG0CN, 0xC9);                    // Regulator Control
           =5 SFR (LIN0CF, 0xC9);                    // LIN 0 Configuration
           =5 SFR (TMR4CF, 0xC9);                    // Timer/Counter 4 Configuration
           =5 SFR (TMR2RLL, 0xCA);                   // Timer/Counter 2 Reload Low
           =5 SFR (TMR4CAPL, 0xCA);                  // Timer/Counter 4 Capture Low
           =5 SFR (TMR2RLH, 0xCB);                   // Timer/Counter 2 Reload High
           =5 SFR (TMR4CAPH, 0xCB);                  // Timer/Counter 4 Capture High
           =5 SFR (TMR2L, 0xCC);                     // Timer/Counter 2 Low
           =5 SFR (TMR4L, 0xCC);                     // Timer/Counter 4 Low
           =5 SFR (TMR2H, 0xCD);                     // Timer/Counter 2 High
           =5 SFR (TMR4H, 0xCD);                     // Timer/Counter 4 High
           =5 SFR (PCA0CPL5, 0xCE);                  // PCA0 Capture 5 Low
           =5 SFR (PCA1CPL11, 0xCE);                 // PCA1 Capture 11 Low
           =5 SFR (PCA0CPH5, 0xCF);                  // PCA0 Capture 5 High
           =5 SFR (PCA1CPH11, 0xCF);                 // PCA1 Capture 11 High
           =5 SFR (PSW, 0xD0);                       // Program Status Word
           =5 SFR (REF0CN, 0xD1);                    // Voltage Reference Control
           =5 SFR (LIN0DAT, 0xD2);                   // LIN0 Data
           =5 SFR (LIN0ADR, 0xD3);                   // LIN0 Address
           =5 SFR (P0SKIP, 0xD4);                    // Port 0 Skip
           =5 SFR (P1SKIP, 0xD5);                    // Port 1 Skip
           =5 SFR (P2SKIP, 0xD6);                    // Port 2 Skip
           =5 SFR (P3SKIP, 0xD7);                    // Port 3 Skip
           =5 SFR (PCA0CN, 0xD8);                    // PCA0 Control
           =5 SFR (PCA1CN, 0xD8);                    // PCA1 Control
           =5 SFR (PCA0MD, 0xD9);                    // PCA0 Mode
           =5 SFR (PCA1MD, 0xD9);                    // PCA1 Mode
           =5 SFR (PCA0PWM, 0xD9);                   // PCA0 PWM Control
           =5 SFR (PCA0CPM0, 0xDA);                  // PCA0 Module 0 Mode
           =5 SFR (PCA1CPM6, 0xDA);                  // PCA1 Module 6 Mode
           =5 SFR (PCA1PWM, 0xDA);                   // PCA1 PWM Control
           =5 SFR (PCA0CPM1, 0xDB);                  // PCA0 Module 1  Mode
           =5 SFR (PCA1CPM7, 0xDB);                  // PCA1 Module 7  Mode
           =5 SFR (PCA0CPM2, 0xDC);                  // PCA0 Module 2  Mode
           =5 SFR (PCA1CPM8, 0xDC);                  // PCA1 Module 8  Mode
           =5 SFR (PCA0CPM3, 0xDD);                  // PCA0 Module 3  Mode
           =5 SFR (PCA1CPM9, 0xDD);                  // PCA1 Module 9  Mode
           =5 SFR (PCA0CPM4, 0xDE);                  // PCA0 Module 4  Mode
           =5 SFR (PCA1CPM10, 0xDE);                  // PCA1 Module 10 Mode
           =5 SFR (PCA0CPM5, 0xDF);                  // PCA0 Module 5  Mode
           =5 SFR (PCA1CPM11, 0xDF);                  // PCA1 Module 11 Mode
           =5 SFR (ACC, 0xE0);                       // Accumulator
           =5 SFR (XBR0, 0xE1);                      // Port I/O Crossbar Control 0
           =5 SFR (XBR1, 0xE2);                      // Port I/O Crossbar Control 1
           =5 SFR (CCH0CN, 0xE3);                    // Cache control
           =5 SFR (IT01CF, 0xE4);                    // INT0/INT1 Configuration
           =5 SFR (EIE1, 0xE6);                      // Extended Interrupt Enable 2
           =5 SFR (EIE2, 0xE7);                      // Extended Interrupt Enable 2
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 81  

           =5 SFR (ADC0CN, 0xE8);                    // ADC0 Control
           =5 SFR (PCA0CPL1, 0xE9);                  // PCA0 Capture 1 Low
           =5 SFR (PCA1CPL1, 0xE9);                  // PCA1 Capture 7 Low
           =5 SFR (PCA0CPH1, 0xEA);                  // PCA0 Capture 1 High
           =5 SFR (PCA1CPH1, 0xEA);                  // PCA1 Capture 7 High
           =5 SFR (PCA0CPL2, 0xEB);                  // PCA0 Capture 2 Low
           =5 SFR (PCA1CPL2, 0xEB);                  // PCA1 Capture 8 Low
           =5 SFR (PCA0CPH2, 0xEC);                  // PCA0 Capture 2 High
           =5 SFR (PCA1CPH2, 0xEC);                  // PCA1 Capture 8 High
           =5 SFR (PCA0CPL3, 0xED);                  // PCA0 Capture 3 Low
           =5 SFR (PCA1CPL3, 0xED);                  // PCA1 Capture 9 Low
           =5 SFR (PCA0CPH3, 0xEE);                  // PCA0 Capture 3 High
           =5 SFR (PCA1CPH3, 0xEE);                  // PCA1 Capture 9 High
           =5 SFR (RSTSRC, 0xEF);                    // Reset Source Configuration/Status
           =5 SFR (B, 0xF0);                         // B Register
           =5 SFR (P0MAT, 0xF1);                     // Port 0 Match
           =5 SFR (P0MDIN, 0xF1);                    // Port 0 Input Mode
           =5 SFR (P0MASK, 0xF2);                    // Port 0 Mask
           =5 SFR (P1MDIN, 0xF2);                    // Port 1 Input Mode
           =5 SFR (P1MAT, 0xF3);                     // Port 1 Match
           =5 SFR (P2MDIN, 0xF3);                    // Port 2 Input Mode
           =5 SFR (P1MASK, 0xF4);                    // Port 1 Mask
           =5 SFR (P3MDIN, 0xF4);                    // Port 3 Input Mode
           =5 SFR (PSBANK, 0xF5);                    // Program Space Bank Select
           =5 SFR (EIP1, 0xF6);                      // External Interrupt Priority 1
           =5 SFR (EIP2, 0xF7);                      // External Interrupt Priority 2
           =5 SFR (SPI0CN, 0xF8);                    // SPI0 Control
           =5 SFR (PCA0L, 0xF9);                     // PCA0 Counter Low
           =5 SFR (PCA1L, 0xF9);                     // PCA1 Counter Low
           =5 SFR (SN0, 0xF9);                       // Serial Number 0
           =5 SFR (PCA0H, 0xFA);                     // PCA0 Counter High
           =5 SFR (PCA1H, 0xFA);                     // PCA1 Counter High
           =5 SFR (SN1, 0xFA);                       // Serial Number 1
           =5 SFR (PCA0CPL0, 0xFB);                  // PCA0 Capture 0 Low
           =5 SFR (PCA1CPL6, 0xFB);                  // PCA1 Capture 6 Low
           =5 SFR (SN2, 0xFB);                       // Serial Number 2
           =5 SFR (PCA0CPH0, 0xFC);                  // PCA0 Capture 0 High
           =5 SFR (PCA1CPH6, 0xFC);                  // PCA1 Capture 6 High
           =5 SFR (SN3, 0xFC);                       // Serial Number 3
           =5 SFR (PCA0CPL4, 0xFD);                  // PCA0 Capture 4 Low
           =5 SFR (PCA1CPL10, 0xFD);                 // PCA1 Capture 10 Low
           =5 SFR (PCA0CPH4, 0xFE);                  // PCA0 Capture 4 High
           =5 SFR (PCA1CPH10, 0xFE);                 // PCA1 Capture 10 High
           =5 SFR (VDM0CN, 0xFF);                    // VDD Monitor Control
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 // Page C (CAN0) Registers
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 SFR (CAN0CFG, 0x92);                   // CAN0 Clock Configuration
           =5 SFR (CAN0STAT, 0x94);                  // Status Register Low Byte
           =5 SFR (CAN0ERRL, 0x96);                  // Error Counter Low Byte
           =5 SFR (CAN0ERRH, 0x97);                  // Error Counter High Byte
           =5 SFR (CAN0BTL, 0x9A);                   // Bit Timing Register Low Byte
           =5 SFR (CAN0BTH, 0x9B);                   // Bit Timing Register High Byte
           =5 SFR (CAN0IIDL, 0x9C);                  // Interrupt Register Low Byte
           =5 SFR (CAN0IIDH, 0x9D);                  // Interrupt Register High Byte
           =5 SFR (CAN0TST, 0x9E);                   // Test Register Low Byte
           =5 SFR (CAN0BRPE, 0xA1);                  // BRP Extension Register Low Byte
           =5 SFR (CAN0TR1L, 0xA2);                  // Transmission Request 1 Low Byte
           =5 SFR (CAN0TR1H, 0xA3);                  // Transmission Request 1 High Byte
           =5 SFR (CAN0TR2L, 0xA4);                  // Transmission Request 2 Low Byte
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 82  

           =5 SFR (CAN0TR2H, 0xA5);                  // Transmission Request 2 High Byte
           =5 SFR (CAN0ND1L, 0xAA);                  // New Data 1 Low Byte
           =5 SFR (CAN0ND1H, 0xAB);                  // New Data 1 High Byte
           =5 SFR (CAN0ND2L, 0xAC);                  // New Data 2 Low Byte
           =5 SFR (CAN0ND2H, 0xAD);                  // New Data 2 High Byte
           =5 SFR (CAN0IP1L, 0xAE);                  // Interrupt Pending 1 Low Byte
           =5 SFR (CAN0IP1H, 0xAF);                  // Interrupt Pending 1 High Byte
           =5 SFR (CAN0IP2L, 0xB2);                  // Interrupt Pending 2 Low Byte
           =5 SFR (CAN0IP2H, 0xB3);                  // Interrupt Pending 2 High Byte
           =5 SFR (CAN0MV1L, 0xBA);                  // Message Valid 1 Low Byte
           =5 SFR (CAN0MV1H, 0xBB);                  // Message Valid 1 High Byte
           =5 SFR (CAN0MV2L, 0xBC);                  // Message Valid 2 Low Byte
           =5 SFR (CAN0MV2H, 0xBD);                  // Message Valid 2 High Byte
           =5 SFR (CAN0IF1CRL, 0xBE);                // IF1 Command Request Low Byte
           =5 SFR (CAN0IF1CRH, 0xBF);                // IF1 Command Request High Byte
           =5 SFR (CAN0CN, 0xC0);                    // CAN Control Register Low Byte
           =5 SFR (CAN0IF1CML, 0xC2);                // IF1 Command Mask Low Byte
           =5 SFR (CAN0IF1CMH, 0xC3);                // IF1 Command Mask High Byte
           =5 SFR (CAN0IF1M1L, 0xC4);                // IF1 Mask 1 Low Byte
           =5 SFR (CAN0IF1M1H, 0xC5);                // IF1 Mask 1 High Byte
           =5 SFR (CAN0IF1M2L, 0xC6);                // IF1 Mask 2 Low Byte
           =5 SFR (CAN0IF1M2H, 0xC7);                // IF1 Mask 2 High Byte
           =5 SFR (CAN0IF1A1L, 0xCA);                // IF1 Arbitration 1 Low Byte
           =5 SFR (CAN0IF1A1H, 0xCB);                // IF1 Arbitration 1 High Byte
           =5 SFR (CAN0IF1A2L, 0xCC);                // IF1 Arbitration 2 Low Byte
           =5 SFR (CAN0IF1A2H, 0xCD);                // IF1 Arbitration 2 High Byte
           =5 SFR (CAN0IF2MCL, 0xCE);                // IF2 Message Control Low Byte
           =5 SFR (CAN0IF2MCH, 0xCF);                // IF2 Message Control High Byte
           =5 SFR (CAN0IF1MCL, 0xD2);                // IF1 Message Control Low Byte
           =5 SFR (CAN0IF1MCH, 0xD3);                // IF1 Message Control High Byte
           =5 SFR (CAN0IF1DA1L, 0xD4);               // IF1 Data A 1 Low Byte
           =5 SFR (CAN0IF1DA1H, 0xD5);               // IF1 Data A 1 High Byte
           =5 SFR (CAN0IF1DA2L, 0xD6);               // IF1 Data A 2 Low Byte
           =5 SFR (CAN0IF1DA2H, 0xD7);               // IF1 Data A 2 High Byte
           =5 SFR (CAN0IF1DB1L, 0xDA);               // IF1 Data B 1 Low Byte
           =5 SFR (CAN0IF1DB1H, 0xDB);               // IF1 Data B 1 High Byte
           =5 SFR (CAN0IF1DB2L, 0xDC);               // IF1 Data B 2 Low Byte
           =5 SFR (CAN0IF1DB2H, 0xDD);               // IF1 Data B 2 High Byte
           =5 SFR (CAN0IF2CRL, 0xDE);                // IF2 Command Request Low Byte
           =5 SFR (CAN0IF2CRH, 0xDF);                // IF2 Command Request High Byte
           =5 SFR (CAN0IF2CML, 0xE2);                // IF2 Command Mask Low Byte
           =5 SFR (CAN0IF2CMH, 0xE3);                // IF2 Command Mask High Byte
           =5 SFR (CAN0IF2M1L, 0xEA);                // IF2 Mask 1 Low Byte
           =5 SFR (CAN0IF2M1H, 0xEB);                // IF2 Mask 1 High Byte
           =5 SFR (CAN0IF2M2L, 0xEC);                // IF2 Mask 2 Low Byte
           =5 SFR (CAN0IF2M2H, 0xED);                // IF2 Mask 2 High Byte
           =5 SFR (CAN0IF2A1L, 0xEE);                // IF2 Arbitration 1 Low Byte
           =5 SFR (CAN0IF2A1H, 0xEF);                // IF2 Arbitration 1 High Byte
           =5 SFR (CAN0IF2A2L, 0xF2);                // IF2 Arbitration 2 Low Byte
           =5 SFR (CAN0IF2A2H, 0xF3);                // IF2 Arbitration 2 High Byte
           =5 SFR (CAN0IF2DA1L, 0xF6);               // IF2 Data A 1 Low Byte
           =5 SFR (CAN0IF2DA1H, 0xF7);               // IF2 Data A 1 High Byte
           =5 SFR (CAN0IF2DA2L, 0xFA);               // IF2 Data A 2 Low Byte
           =5 SFR (CAN0IF2DA2H, 0xFB);               // IF2 Data A 2 High Byte
           =5 SFR (CAN0IF2DB1L, 0xFC);               // IF2 Data B 1 Low Byte
           =5 SFR (CAN0IF2DB1H, 0xFD);               // IF2 Data B 1 High Byte
           =5 SFR (CAN0IF2DB2L, 0xFE);               // IF2 Data B 2 Low Byte
           =5 SFR (CAN0IF2DB2H, 0xFF);               // IF2 Data B 2 High Byte
           =5 
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 // 16-bit Register Definitions (might not be supported by all compilers)
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 83  

           =5 //-----------------------------------------------------------------------------
           =5 
           =5 SFR16 (DP, 0x82);                      // Data Pointer
           =5 SFR16 (TMR3RL, 0x92);                  // Timer 3 Reload
           =5 SFR16 (TMR5CAP, 0x92);                 // Timer 5 Capture
           =5 SFR16 (TMR3, 0x94);                    // Timer 3 Capture / Reload
           =5 SFR16 (TMR5, 0x94);                    // Timer 5
           =5 SFR16 (SBRL0, 0xAC);                   // UART0 Reload
           =5 SFR16 (ADC0, 0xBD);                    // ADC0 data
           =5 SFR16 (ADC0GT, 0xC3);                  // ADC0 Greater Than Window
           =5 SFR16 (ADC0LT, 0xC5);                  // ADC0 Less Than Window
           =5 SFR16 (TMR2RL, 0xCA);                  // Timer 2 Reload
           =5 SFR16 (TMR4CAP, 0xCA);                 // Timer 4 Capture
           =5 SFR16 (TMR2, 0xCC);                    // Timer 2 Capture / Reload
           =5 SFR16 (TMR4, 0xCC);                    // Timer 4
           =5 SFR16 (PCA0CP5, 0xCE);                 // PCA0 Module 5 Capture
           =5 SFR16 (PCA1CP11, 0xCE);                // PCA1 Module 11 Capture
           =5 SFR16 (PCA0CP1, 0xE9);                 // PCA0 Module 1 Capture
           =5 SFR16 (PCA1CP7, 0xE9);                 // PCA1 Module 7 Capture
           =5 SFR16 (PCA0CP2, 0xEB);                 // PCA0 Module 2 Capture
           =5 SFR16 (PCA1CP8, 0xEB);                 // PCA1 Module 8 Capture
           =5 SFR16 (PCA0CP3, 0xED);                 // PCA0 Module 3 Capture
           =5 SFR16 (PCA1CP9, 0xED);                 // PCA1 Module 9 Capture
           =5 SFR16 (PCA0, 0xF9);                    // PCA0 Counter
           =5 SFR16 (PCA1, 0xF9);                    // PCA1 Counter
           =5 SFR16 (PCA0CP0, 0xFB);                 // PCA0 Module 0 Capture
           =5 SFR16 (PCA1CP6, 0xFB);                 // PCA1 Module 6 Capture
           =5 SFR16 (PCA0CP4, 0xFD);                 // PCA0 Module 4 Capture
           =5 SFR16 (PCA1CP10, 0xFD);                 // PCA1 Module 10 Capture
           =5 
           =5 SFR16 (CAN0ERR, 0x96);                 // Error Counter
           =5 SFR16 (CAN0BT, 0x9A);                  // Bit Timing Register
           =5 SFR16 (CAN0IID, 0x9C);                 // Interrupt Register
           =5 SFR16 (CAN0TR1, 0xA2);                 // Transmission Request 1
           =5 SFR16 (CAN0TR2, 0xA4);                 // Transmission Request 2
           =5 SFR16 (CAN0ND1, 0xAA);                 // New Data 1
           =5 SFR16 (CAN0ND2, 0xAC);                 // New Data 2
           =5 SFR16 (CAN0IP1, 0xAE);                 // Interrupt Pending 1
           =5 SFR16 (CAN0IP2, 0xB2);                 // Interrupt Pending 2
           =5 SFR16 (CAN0MV1, 0xBA);                 // Message Valid 1
           =5 SFR16 (CAN0MV2, 0xBC);                 // Message Valid 2
           =5 SFR16 (CAN0IF1CR, 0xBE);               // IF1 Command Request
           =5 SFR16 (CAN0IF1CM, 0xC2);               // IF1 Command Mask
           =5 SFR16 (CAN0IF1M1, 0xC4);               // IF1 Mask 1
           =5 SFR16 (CAN0IF1M2, 0xC6);               // IF1 Mask 2
           =5 SFR16 (CAN0IF1A1, 0xCA);               // IF1 Arbitration 1
           =5 SFR16 (CAN0IF1A2, 0xCC);               // IF1 Arbitration 2
           =5 SFR16 (CAN0IF1MC, 0xD2);               // IF1 Message Control
           =5 SFR16 (CAN0IF1DA1, 0xD4);              // IF1 Data A 1
           =5 SFR16 (CAN0IF1DA2, 0xD6);              // IF1 Data A 2
           =5 SFR16 (CAN0IF1DB1, 0xDA);              // IF1 Data B 1
           =5 SFR16 (CAN0IF1DB2, 0xDC);              // IF1 Data B 2
           =5 SFR16 (CAN0IF2CR, 0xDE);               // IF2 Command Request
           =5 SFR16 (CAN0IF2CM, 0xE2);               // IF2 Command Mask
           =5 SFR16 (CAN0IF2M1, 0xEA);               // IF2 Mask 1
           =5 SFR16 (CAN0IF2M2, 0xEC);               // IF2 Mask 2
           =5 SFR16 (CAN0IF2A1, 0xEE);               // IF2 Arbitration 1
           =5 SFR16 (CAN0IF2A2, 0xF2);               // IF2 Arbitration 2
           =5 SFR16 (CAN0IF2MC, 0xCE);               // IF2 Message Control
           =5 SFR16 (CAN0IF2DA1, 0xF6);              // IF2 Data A 1
           =5 SFR16 (CAN0IF2DA2, 0xFA);              // IF2 Data A 2
           =5 SFR16 (CAN0IF2DB1, 0xFC);              // IF2 Data B 1
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 84  

           =5 SFR16 (CAN0IF2DB2, 0xFE);              // IF2 Data B 2
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 // LIN0 Indirect Registers
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 #define  LIN0DT1   0x00                // LIN0 Data Byte 1
           =5 #define  LIN0DT2   0x01                // LIN0 Data Byte 2
           =5 #define  LIN0DT3   0x02                // LIN0 Data Byte 3
           =5 #define  LIN0DT4   0x03                // LIN0 Data Byte 4
           =5 #define  LIN0DT5   0x04                // LIN0 Data Byte 5
           =5 #define  LIN0DT6   0x05                // LIN0 Data Byte 6
           =5 #define  LIN0DT7   0x06                // LIN0 Data Byte 7
           =5 #define  LIN0DT8   0x07                // LIN0 Data Byte 8
           =5 #define  LIN0CTRL  0x08                // LIN0 Control
           =5 #define  LIN0ST    0x09                // LIN0 Status
           =5 #define  LIN0ERR   0x0A                // LIN0 Error
           =5 #define  LIN0SIZE  0x0B                // LIN0 Message Size
           =5 #define  LIN0DIV   0x0C                // LIN0 Divider
           =5 #define  LIN0MUL   0x0D                // LIN0 Multiplier
           =5 #define  LIN0ID    0x0E                // LIN0 Identifier
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 // Address Definitions for Bit-addressable Registers
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 #define SFR_P0       0x80
           =5 #define SFR_TCON     0x88
           =5 #define SFR_P1       0x90
           =5 #define SFR_SCON0    0x98
           =5 #define SFR_SCON1    0x98
           =5 #define SFR_P2       0xA0
           =5 #define SFR_IE       0xA8
           =5 #define SFR_P3       0xB0
           =5 #define SFR_IP       0xB8
           =5 #define SFR_SMB0CN   0xC0
           =5 #define SFR_TMR2CN   0xC8
           =5 #define SFR_TMR4CN   0xC8
           =5 #define SFR_PSW      0xD0
           =5 #define SFR_PCA0CN   0xD8
           =5 #define SFR_PCA1CN   0xD8
           =5 #define SFR_ACC      0xE0
           =5 #define SFR_ADC0CN   0xE8
           =5 #define SFR_B        0xF0
           =5 #define SFR_SPI0CN   0xF8
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 // Bit Definitions
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 // TCON 0x88
           =5 SBIT (TF1, SFR_TCON, 7);               // Timer 1 Overflow Flag
           =5 SBIT (TR1, SFR_TCON, 6);               // Timer 1 On/Off Control
           =5 SBIT (TF0, SFR_TCON, 5);               // Timer 0 Overflow Flag
           =5 SBIT (TR0, SFR_TCON, 4);               // Timer 0 On/Off Control
           =5 SBIT (IE1, SFR_TCON, 3);               // Ext. Interrupt 1 Edge Flag
           =5 SBIT (IT1, SFR_TCON, 2);               // Ext. Interrupt 1 Type
           =5 SBIT (IE0, SFR_TCON, 1);               // Ext. Interrupt 0 Edge Flag
           =5 SBIT (IT0, SFR_TCON, 0);               // Ext. Interrupt 0 Type
           =5 
           =5 // SCON0 0x98
           =5 SBIT (OVR0, SFR_SCON0, 7);             // UART0 Receive FIFO Overrun Flag
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 85  

           =5 SBIT (PERR0, SFR_SCON0, 6);            // UART0 Parity Error Flag
           =5 SBIT (THRE0, SFR_SCON0, 5);            // UART0 Transmit Register Empty Flag
           =5 SBIT (REN0, SFR_SCON0, 4);             // UART0 RX Enable
           =5 SBIT (TBX0, SFR_SCON0, 3);             // UART0 Extra Transmission Bit
           =5 SBIT (RBX0, SFR_SCON0, 2);             // UART0 Extra Receive Bit
           =5 SBIT (TI0, SFR_SCON0, 1);              // UART0 TX Interrupt Flag
           =5 SBIT (RI0, SFR_SCON0, 0);              // UART0 RX Interrupt Flag
           =5 
           =5 // SCON1 0x98
           =5 SBIT (S1MODE, SFR_SCON1, 7);           // UART1 Mode 0
           =5                                        // Bit 6 UNUSED
           =5 SBIT (MCE1, SFR_SCON1, 5);             // UART1 Multiprocessor enable
           =5 SBIT (REN1, SFR_SCON1, 4);             // UART1 RX Enable
           =5 SBIT (TB81, SFR_SCON1, 3);             // UART1 TX Bit 8
           =5 SBIT (RB81, SFR_SCON1, 2);             // UART1 RX Bit 8
           =5 SBIT (TI1, SFR_SCON1, 1);              // UART1 TX Interrupt Flag
           =5 SBIT (RI1, SFR_SCON1, 0);              // UART1 RX Interrupt Flag
           =5 
           =5 // IE 0xA8
           =5 SBIT (EA, SFR_IE, 7);                  // Global Interrupt Enable
           =5 SBIT (ESPI0, SFR_IE, 6);               // SPI0 Interrupt Enable
           =5 SBIT (ET2, SFR_IE, 5);                 // Timer 2 Interrupt Enable
           =5 SBIT (ES0, SFR_IE, 4);                 // UART0 Interrupt Enable
           =5 SBIT (ET1, SFR_IE, 3);                 // Timer 1 Interrupt Enable
           =5 SBIT (EX1, SFR_IE, 2);                 // External Interrupt 1 Enable
           =5 SBIT (ET0, SFR_IE, 1);                 // Timer 0 Interrupt Enable
           =5 SBIT (EX0, SFR_IE, 0);                 // External Interrupt 0 Enable
           =5 
           =5 // IP 0xB8
           =5                                        // Bit 7 unused
           =5 SBIT (PSPI0, SFR_IP, 6);               // SPI0 Interrupt Priority
           =5 SBIT (PT2, SFR_IP, 5);                 // Timer 2 Priority
           =5 SBIT (PS0, SFR_IP, 4);                 // UART0 Priority
           =5 SBIT (PS, SFR_IP, 4);                  // UART0 Priority
           =5 SBIT (PT1, SFR_IP, 3);                 // Timer 1 Priority
           =5 SBIT (PX1, SFR_IP, 2);                 // External Interrupt 1 Priority
           =5 SBIT (PT0, SFR_IP, 1);                 // Timer 0 Priority
           =5 SBIT (PX0, SFR_IP, 0);                 // External Interrupt 0 Priority
           =5 
           =5 // SMB0CN 0xC0
           =5 SBIT (MASTER, SFR_SMB0CN, 7);          // SMBus0 Master/Slave Indicator
           =5 SBIT (TXMODE, SFR_SMB0CN, 6);          // SMBus0 Transmit Mode Indicator
           =5 SBIT (STA, SFR_SMB0CN, 5);             // SMBus0 Start Flag
           =5 SBIT (STO, SFR_SMB0CN, 4);             // SMBus0 Stop Flag
           =5 SBIT (ACKRQ, SFR_SMB0CN, 3);           // SMBus0 Acknowledge Request
           =5 SBIT (ARBLOST, SFR_SMB0CN, 2);         // SMBus0 Arbitration Lost Indicator
           =5 SBIT (ACK, SFR_SMB0CN, 1);             // SMBus0 Acknowledge
           =5 SBIT (SI, SFR_SMB0CN, 0);              // SMBus0 Interrupt Flag
           =5 
           =5 // TMR2CN 0xC8
           =5 SBIT (TF2H, SFR_TMR2CN, 7);            // Timer 2 High-Byte Overflow Flag
           =5 SBIT (TF2L, SFR_TMR2CN, 6);            // Timer 2 Low-Byte  Overflow Flag
           =5 SBIT (TF2LEN, SFR_TMR2CN, 5);          // Timer 2 Low-Byte Flag Enable
           =5 SBIT (TF2CEN, SFR_TMR2CN, 4);          // Timer 2 Capture Enable
           =5 SBIT (T2SPLIT, SFR_TMR2CN, 3);         // Timer 2 Split-Mode Enable
           =5 SBIT (TR2, SFR_TMR2CN, 2);             // Timer 2 Run Enable
           =5 SBIT (T2RCLK, SFR_TMR2CN, 1);          // Timer 2 Xclk/Rclk Select
           =5 SBIT (T2XCLK, SFR_TMR2CN, 0);          // Timer 2 Clk/8 Clock Source
           =5 
           =5 // TMR4CN 0xC8
           =5 SBIT (TF4, SFR_TMR4CN, 7);             // Timer 4 Overflow/Underflow Flag
           =5 SBIT (EXF4, SFR_TMR4CN, 6);            // Timer 4 External Flag
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 86  

           =5                                        // Bit 5 unused
           =5                                        // Bit 4 unused
           =5 SBIT (EXE4, SFR_TMR4CN, 3);            // Timer 4 External Enable
           =5 SBIT (TR4, SFR_TMR4CN, 2);             // Timer 4 Run Enable
           =5 SBIT (CT4, SFR_TMR4CN, 1);             // Timer 4 Counter/Timer Select
           =5 SBIT (CPRL4, SFR_TMR4CN, 0);           // Timer 4 Capture/Reload Select
           =5 
           =5 // PSW 0xD0
           =5 SBIT (CY, SFR_PSW, 7);                 // Carry Flag
           =5 SBIT (AC, SFR_PSW, 6);                 // Auxiliary Carry Flag
           =5 SBIT (F0, SFR_PSW, 5);                 // User Flag 0
           =5 SBIT (RS1, SFR_PSW, 4);                // Register Bank Select 1
           =5 SBIT (RS0, SFR_PSW, 3);                // Register Bank Select 0
           =5 SBIT (OV, SFR_PSW, 2);                 // Overflow Flag
           =5 SBIT (F1, SFR_PSW, 1);                 // User Flag 1
           =5 SBIT (P, SFR_PSW, 0);                  // Accumulator Parity Flag
           =5 
           =5 // PCA0CN 0xD8
           =5 SBIT (CF, SFR_PCA0CN, 7);              // PCA0 Counter Overflow Flag
           =5 SBIT (CR, SFR_PCA0CN, 6);              // PCA0 Counter Run Control Bit
           =5 SBIT (CCF5, SFR_PCA0CN, 5);            // PCA0 Module 5 Interrupt Flag
           =5 SBIT (CCF4, SFR_PCA0CN, 4);            // PCA0 Module 4 Interrupt Flag
           =5 SBIT (CCF3, SFR_PCA0CN, 3);            // PCA0 Module 3 Interrupt Flag
           =5 SBIT (CCF2, SFR_PCA0CN, 2);            // PCA0 Module 2 Interrupt Flag
           =5 SBIT (CCF1, SFR_PCA0CN, 1);            // PCA0 Module 1 Interrupt Flag
           =5 SBIT (CCF0, SFR_PCA0CN, 0);            // PCA0 Module 0 Interrupt Flag
           =5 
           =5 // PCA1CN 0xD8
           =5 SBIT (CF1, SFR_PCA1CN, 7);             // PCA1 Counter Overflow Flag
           =5 SBIT (CR1, SFR_PCA1CN, 6);             // PCA1 Counter Run Control Bit
           =5 SBIT (CCF11, SFR_PCA1CN, 5);           // PCA1 Module 11 Interrupt Flag
           =5 SBIT (CCF10, SFR_PCA1CN, 4);           // PCA1 Module 10 Interrupt Flag
           =5 SBIT (CCF9, SFR_PCA1CN, 3);            // PCA1 Module 9 Interrupt Flag
           =5 SBIT (CCF8, SFR_PCA1CN, 2);            // PCA1 Module 8 Interrupt Flag
           =5 SBIT (CCF7, SFR_PCA1CN, 1);            // PCA1 Module 7 Interrupt Flag
           =5 SBIT (CCF6, SFR_PCA1CN, 0);            // PCA1 Module 6 Interrupt Flag
           =5 
           =5 // ADC0CN 0xE8
           =5 SBIT (AD0EN, SFR_ADC0CN, 7);           // ADC0 Enable
           =5 SBIT (BURSTEN, SFR_ADC0CN, 6);         // ADC0 Burst Enable
           =5 SBIT (AD0INT, SFR_ADC0CN, 5);          // ADC0 EOC Interrupt Flag
           =5 SBIT (AD0BUSY, SFR_ADC0CN, 4);         // ADC0 Busy Flag
           =5 SBIT (AD0WINT, SFR_ADC0CN, 3);         // ADC0 Window Compare Interrupt Flag
           =5 SBIT (AD0LJST, SFR_ADC0CN, 2);         // ADC0 Left Justified
           =5 SBIT (AD0CM1, SFR_ADC0CN, 1);          // ADC0 Start Of Conversion Mode Bit 1
           =5 SBIT (AD0CM0, SFR_ADC0CN, 0);          // ADC0 Start Of Conversion Mode Bit 0
           =5 
           =5 // SPI0CN 0xF8
           =5 SBIT (SPIF, SFR_SPI0CN, 7);            // SPI0 Interrupt Flag
           =5 SBIT (WCOL, SFR_SPI0CN, 6);            // SPI0 Write Collision Flag
           =5 SBIT (MODF, SFR_SPI0CN, 5);            // SPI0 Mode Fault Flag
           =5 SBIT (RXOVRN, SFR_SPI0CN, 4);          // SPI0 RX Overrun Flag
           =5 SBIT (NSSMD1, SFR_SPI0CN, 3);          // SPI0 Slave Select Mode 1
           =5 SBIT (NSSMD0, SFR_SPI0CN, 2);          // SPI0 Slave Select Mode 0
           =5 SBIT (TXBMT, SFR_SPI0CN, 1);           // SPI0 TX Buffer Empty Flag
           =5 SBIT (SPIEN, SFR_SPI0CN, 0);           // SPI0 Enable
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 // Interrupt Priorities
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 #define INTERRUPT_INT0             0   // External Interrupt 0
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 87  

           =5 #define INTERRUPT_TIMER0           1   // Timer 0 Overflow
           =5 #define INTERRUPT_INT1             2   // External Interrupt 1
           =5 #define INTERRUPT_TIMER1           3   // Timer 1 Overflow
           =5 #define INTERRUPT_UART0            4   // UART0
           =5 #define INTERRUPT_TIMER2           5   // Timer 2 Overflow
           =5 #define INTERRUPT_SPI0             6   // SPI0
           =5 #define INTERRUPT_SMBUS0           7   // SMBus0 Interface
           =5 #define INTERRUPT_ADC0_WINDOW      8   // ADC0 Window Comparison
           =5 #define INTERRUPT_ADC0_EOC         9   // ADC0 End Of Conversion
           =5 #define INTERRUPT_PCA0            10   // PCA0 Peripheral
           =5 #define INTERRUPT_COMPARATOR0     11   // Comparator 0 Comparison
           =5 #define INTERRUPT_COMPARATOR1     12   // Comparator 1 Comparison
           =5 #define INTERRUPT_TIMER3          13   // Timer 3 Overflow
           =5 #define INTERRUPT_LIN0            14   // LIN Bus Interrupt
           =5 #define INTERRUPT_VREG            15   // Voltage Regulator
           =5 #define INTERRUPT_CAN0            16   // CAN Bus Interrupt
           =5 #define INTERRUPT_PORT_MATCH      17   // Port Match
           =5 #define INTERRUPT_UART1           18   // UART1
           =5 #define INTERRUPT_PCA1            19   // PCA1 Peripheral
           =5 #define INTERRUPT_COMPARATOR2     20   // Comparator 2 Comparison
           =5 #define INTERRUPT_TIMER4          21   // Timer 4 Overflow
           =5 #define INTERRUPT_TIMER5          22   // Timer 5 Overflow
           =5 
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 // SFR Page Definitions
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 #define  CONFIG_PAGE       0x0F        // System and Port Configuration Page
           =5 #define  ACTIVE_PAGE       0x00        // Active Use Page
           =5 #define  ACTIVE2_PAGE      0x10        // Active Use Page 2
           =5 #define  CAN0_PAGE         0x0C        // CAN0 Registers
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 // SDCC PDATA External Memory Paging Support
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 #if defined SDCC
           =5 
           =5 SFR(_XPAGE, 0xAA); // Point to the EMI0CN register
           =5 
           =5 #endif
           =5 
           =5 //-----------------------------------------------------------------------------
           =5 // Header File PreProcessor Directive
           =5 //-----------------------------------------------------------------------------
           =5 
           =5 #endif                                 // #define C8051F580_DEFS_H
 607      =5  
 608      =5  //-----------------------------------------------------------------------------
 609      =5  // End Of File
 610      =5  //-----------------------------------------------------------------------------
   9      =4  void UART1_Init(U32 sysclk, U32 baudrate);
  10      =4  #endif
  12      =3  
  13      =3  void MCU_init(void);
  14      =3  void Polling(void);
  15      =3  #endif
   9      =2  #include "Os_config.h"
   1      =3  /*
   2      =3   *  Created on: Apr 21, 2025
   3      =3   *      Author: Hoangtd2000
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 88  

   4      =3   */
   5      =3  #ifndef _OS_CONFIG_H_
   6      =3  #define _OS_CONFIG_H_
   7      =3  #include <stdio.h>
   1      =4  /*--------------------------------------------------------------------------
   2      =4  STDIO.H
   3      =4  
   4      =4  Prototypes for standard I/O functions.
   5      =4  Copyright (c) 1988-2002 Keil Elektronik GmbH and Keil Software, Inc.
   6      =4  All rights reserved.
   7      =4  --------------------------------------------------------------------------*/
   8      =4  
   9      =4  #ifndef __STDIO_H__
  10      =4  #define __STDIO_H__
  11      =4  
  12      =4  #ifndef EOF
  13      =4   #define EOF -1
  14      =4  #endif
  15      =4  
  16      =4  #ifndef NULL
  17      =4   #define NULL ((void *) 0)
  18      =4  #endif
  19      =4  
  20      =4  #ifndef _SIZE_T
  21      =4   #define _SIZE_T
  22      =4   typedef unsigned int size_t;
  23      =4  #endif
  24      =4  
  25      =4  #pragma SAVE
  26      =4  #pragma REGPARMS
  27      =4  extern char _getkey (void);
  28      =4  extern char getchar (void);
  29      =4  extern char ungetchar (char);
  30      =4  extern char putchar (char);
  31      =4  extern int printf   (const char *, ...);
  32      =4  extern int sprintf  (char *, const char *, ...);
  33      =4  extern int vprintf  (const char *, char *);
  34      =4  extern int vsprintf (char *, const char *, char *);
  35      =4  extern char *gets (char *, int n);
  36      =4  extern int scanf (const char *, ...);
  37      =4  extern int sscanf (char *, const char *, ...);
  38      =4  extern int puts (const char *);
  39      =4  
  40      =4  #pragma RESTORE
  41      =4  
  42      =4  #endif
  43      =4  
   8      =3  #include "Service.h"
   1      =4  /*
   2      =4   *  Created on: Apr 21, 2025
   3      =4   *      Author: Hoangtd2000
   4      =4   */
   5      =4  #ifndef _SERVICE_H_
           =4 #define _SERVICE_H_
           =4 #include "Dio.h"
           =4 #include "GPT.h"
           =4 #include "Dio.h"
           =4 #include "Timer.h"
           =4 #include "Uart.h"
           =4 
           =4 void MCU_init(void);
           =4 void Polling(void);
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 89  

           =4 #endif
   9      =3  #include <compiler_defs.h>
   1      =4  //-----------------------------------------------------------------------------
   2      =4  // compiler_defs.h
   3      =4  //-----------------------------------------------------------------------------
   4      =4  // Portions of this file are copyright Maarten Brock
   5      =4  // http://sdcc.sourceforge.net
   6      =4  // Portions of this file are copyright 2010, Silicon Laboratories, Inc.
   7      =4  // http://www.silabs.com
   8      =4  //
   9      =4  // GNU LGPL boilerplate:
  10      =4  /** This library is free software; you can redistribute it and/or
  11      =4    * modify it under the terms of the GNU Lesser General Public
  12      =4    * License as published by the Free Software Foundation; either
  13      =4    * version 2.1 of the License, or (at your option) any later version.
  14      =4    *
  15      =4    * This library is distributed in the hope that it will be useful,
  16      =4    * but WITHOUT ANY WARRANTY; without even the implied warranty of
  17      =4    * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  18      =4    * Lesser General Public License for more details.
  19      =4    *
  20      =4    * You should have received a copy of the GNU Lesser General Public
  21      =4    * License along with this library; if not, write to the Free Software
  22      =4    * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  23      =4    *
  24      =4    * In other words, you are welcome to use, share and improve this program.
  25      =4    * You are forbidden to forbid anyone else to use, share and improve
  26      =4    * what you give them. Help stamp out software-hoarding!
  27      =4  **/
  28      =4  // Program Description:
  29      =4  //
  30      =4  // **Important Note**: This header file should be included before including
  31      =4  // a device-specific header file such as C8051F300_defs.h.
  32      =4  //
  33      =4  // Macro definitions to accomodate 8051 compiler differences in specifying
  34      =4  // special function registers and other 8051-specific features such as NOP
  35      =4  // generation, and locating variables in memory-specific segments.  The
  36      =4  // compilers are identified by their unique predefined macros. See also:
  37      =4  // http://predef.sourceforge.net/precomp.html
  38      =4  //
  39      =4  // SBIT and SFR define special bit and special function registers at the given
  40      =4  // address. SFR16 and SFR32 define sfr combinations at adjacent addresses in
  41      =4  // little-endian format. SFR16E and SFR32E define sfr combinations without
  42      =4  // prerequisite byte order or adjacency. None of these multi-byte sfr
  43      =4  // combinations will guarantee the order in which they are accessed when read
  44      =4  // or written.
  45      =4  //
  46      =4  // SFR16X and SFR32X for 16 bit and 32 bit xdata registers are not defined
  47      =4  // to avoid portability issues because of compiler endianness.
  48      =4  //
  49      =4  // Example:
  50      =4  // // my_mcu.c: main 'c' file for my mcu
  51      =4  // #include <compiler_defs.h>  // this file
  52      =4  // #include <C8051xxxx_defs.h> // SFR definitions for specific MCU target
  53      =4  //
  54      =4  // SBIT  (P0_1, 0x80, 1);      // Port 0 pin 1
  55      =4  // SFR   (P0, 0x80);           // Port 0
  56      =4  // SFRX  (CPUCS, 0xE600);      // Cypress FX2 Control and Status register in
  57      =4  //                             // xdata memory at 0xE600
  58      =4  // SFR16 (TMR2, 0xCC);         // Timer 2, lsb at 0xCC, msb at 0xCD
  59      =4  // SFR16E(TMR0, 0x8C8A);       // Timer 0, lsb at 0x8A, msb at 0x8C
  60      =4  // SFR32 (MAC0ACC, 0x93);      // SiLabs C8051F120 32 bits MAC0 Accumulator,
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 90  

  61      =4  //                             // lsb at 0x93, msb at 0x96
  62      =4  // SFR32E(SUMR, 0xE5E4E3E2);   // TI MSC1210 SUMR 32 bits Summation register,
  63      =4  //                             // lsb at 0xE2, msb at 0xE5
  64      =4  //
  65      =4  // Target:         C8051xxxx
  66      =4  // Tool chain:     Generic
  67      =4  // Command Line:   None
  68      =4  // 
  69      =4  // Release 2.6 - 14 DEC 2012 (GO)
  70      =4  //        -Added define for deprecated SDCC keyword 'at'
  71      =4  // Release 2.5 - 12 SEP 2012 (TP)
  72      =4  //    -Added defines for deprecated SDCC keywords bit and code
  73      =4  // Release 2.4 - 27 AUG 2012 (TP)
  74      =4  //    -Added defines for deprecated SDCC keywords interrupt, _asm, and _endasm
  75      =4  // Release 2.3 - 27 MAY 2010 (DM)
  76      =4  //    -Removed 'LOCATED_VARIABLE' pragma from Keil because it is not supported
  77      =4  // Release 2.2 - 06 APR 2010 (ES)
  78      =4  //    -Removed 'PATHINCLUDE' pragma from Raisonance section
  79      =4  // Release 2.1 - 16 JUL 2009 (ES)
  80      =4  //    -Added SEGMENT_POINTER macro definitions for SDCC, Keil, and Raisonance
  81      =4  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for Raisonance
  82      =4  // Release 2.0 - 19 MAY 2009 (ES)
  83      =4  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for SDCC and Keil
  84      =4  // Release 1.9 - 23 OCT 2008 (ES)
  85      =4  //    -Updated Hi-Tech INTERRUPT and INTERRUPT_USING macro definitions
  86      =4  //    -Added SFR16 macro defintion for Hi-Tech
  87      =4  // Release 1.8 - 31 JUL 2008 (ES)
  88      =4  //    -Added INTERRUPT_USING and FUNCTION_USING macro's
  89      =4  //    -Added macro's for IAR
  90      =4  //    -Corrected Union definitions for Hi-Tech and added SFR16 macro defintion
  91      =4  // Release 1.7 - 11 SEP 2007 (BW)
  92      =4  //    -Added support for Raisonance EVAL 03.03.42 and Tasking Eval 7.2r1
  93      =4  // Release 1.6 - 27 AUG 2007 (BW)
  94      =4  //    -Updated copyright notice per agreement with Maartin Brock
  95      =4  //    -Added SDCC 2.7.0 "compiler.h" bug fixes
  96      =4  //    -Added memory segment defines (SEG_XDATA, for example)
  97      =4  // Release 1.5 - 24 AUG 2007 (BW)
  98      =4  //    -Added support for NOP () macro
  99      =4  //    -Added support for Hi-Tech ver 9.01
 100      =4  // Release 1.4 - 07 AUG 2007 (PKC)
 101      =4  //    -Removed FID and fixed formatting.
 102      =4  // Release 1.3 - 30 SEP 2007 (TP)
 103      =4  //    -Added INTERRUPT_PROTO_USING to properly support ISR context switching
 104      =4  //     under SDCC.
 105      =4  // Release 1.2 - (BW)
 106      =4  //    -Added support for U8,U16,U32,S8,S16,S32,UU16,UU32 data types
 107      =4  // Release 1.1 - (BW)
 108      =4  //    -Added support for INTERRUPT, INTERRUPT_USING, INTERRUPT_PROTO,
 109      =4  //     SEGMENT_VARIABLE, VARIABLE_SEGMENT_POINTER,
 110      =4  //     SEGMENT_VARIABLE_SEGMENT_POINTER, and LOCATED_VARIABLE
 111      =4  // Release 1.0 - 29 SEP 2006 (PKC)
 112      =4  //    -Initial revision
 113      =4  
 114      =4  //-----------------------------------------------------------------------------
 115      =4  // Header File Preprocessor Directive
 116      =4  //-----------------------------------------------------------------------------
 117      =4  
 118      =4  #ifndef COMPILER_DEFS_H
           =4 #define COMPILER_DEFS_H
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Macro definitions
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 91  

           =4 //-----------------------------------------------------------------------------
           =4 
           =4 // SDCC - Small Device C Compiler
           =4 // http://sdcc.sourceforge.net
           =4 
           =4 #if defined SDCC
           =4 
           =4 #if (SDCC >= 300)
           =4 
           =4 #define interrupt __interrupt
           =4 #define _asm __asm
           =4 #define _endasm __endasm
           =4 #define bit __bit
           =4 #define code __code
           =4 #define at __at
           =4 
           =4 #endif
           =4 
           =4 # define SEG_GENERIC
           =4 # define SEG_FAR   __xdata
           =4 # define SEG_DATA  __data
           =4 # define SEG_NEAR  __data
           =4 # define SEG_IDATA __idata
           =4 # define SEG_XDATA __xdata
           =4 # define SEG_PDATA __pdata
           =4 # define SEG_CODE  __code
           =4 # define SEG_BDATA __bdata
           =4 
           =4 # define SBIT(name, addr, bit)  __sbit  __at(addr+bit)                  name
           =4 # define SFR(name, addr)        __sfr   __at(addr)                      name
           =4 # define SFRX(name, addr)       xdata volatile unsigned char __at(addr) name
           =4 # define SFR16(name, addr)      __sfr16 __at(((addr+1U)<<8) | addr)     name
           =4 # define SFR16E(name, fulladdr) __sfr16 __at(fulladdr)                  name
           =4 # define SFR32(name, addr)      __sfr32 __at(((addr+3UL)<<24) | ((addr+2UL)<<16) | ((addr+1UL)<<8) | addr)
             - name
           =4 # define SFR32E(name, fulladdr) __sfr32 __at(fulladdr)                  name
           =4 
           =4 # define INTERRUPT(name, vector) void name (void) interrupt (vector)
           =4 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =4 # define INTERRUPT_PROTO(name, vector) void name (void) interrupt (vector)
           =4 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =4 
           =4 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using (regnum
             -)
           =4 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter) using (
             -regnum)
           =4 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =4 
           =4 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =4 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =4 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =4 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =4 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment at (addr) vartype name = init
           =4 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) locsegment at (addr) vartype name
           =4 
           =4 // used with UU16
           =4 # define LSB 0
           =4 # define MSB 1
           =4 
           =4 // used with UU32 (b0 is least-significant byte)
           =4 # define b0 0
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 92  

           =4 # define b1 1
           =4 # define b2 2
           =4 # define b3 3
           =4 
           =4 typedef unsigned char U8;
           =4 typedef unsigned int U16;
           =4 typedef unsigned long U32;
           =4 
           =4 typedef signed char S8;
           =4 typedef signed int S16;
           =4 typedef signed long S32;
           =4 
           =4 typedef union UU16
           =4 {
           =4    U16 U16;
           =4    S16 S16;
           =4    U8 U8[2];
           =4    S8 S8[2];
           =4 } UU16;
           =4 
           =4 typedef union UU32
           =4 {
           =4    U32 U32;
           =4    S32 S32;
           =4    UU16 UU16[2];
           =4    U16 U16[2];
           =4    S16 S16[2];
           =4    U8 U8[4];
           =4    S8 S8[4];
           =4 } UU32;
           =4 
           =4 // NOP () macro support
           =4 #define NOP() _asm NOP _endasm
           =4 
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 // Raisonance (must be placed before Keil C51)
           =4 // http://www.raisonance.com
           =4 
           =4 #elif defined __RC51__
           =4 
           =4 //#error Raisonance C51 detected.
           =4 
           =4 # define SEG_GENERIC generic     //SEG_GENERIC only applies to pointers in Raisonance, not variables.
           =4 # define SEG_FAR   xdata
           =4 # define SEG_DATA  data
           =4 # define SEG_NEAR  data
           =4 # define SEG_IDATA idata
           =4 # define SEG_XDATA xdata
           =4 # define SEG_PDATA pdata
           =4 # define SEG_CODE  code
           =4 # define SEG_BDATA bdata
           =4 
           =4 # define SBIT(name, addr, bit)  at (addr+bit) sbit         name
           =4 # define SFR(name, addr)        sfr at addr                name
           =4 # define SFR16(name, addr)      sfr16 at addr              name
           =4 # define SFR16E(name, fulladdr) /* not supported */
           =4 # define SFR32(name, fulladdr)  /* not supported */
           =4 # define SFR32E(name, fulladdr) /* not supported */
           =4 
           =4 # define INTERRUPT(name, vector) void name (void) interrupt vector
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 93  

           =4 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =4 # define INTERRUPT_PROTO(name, vector) void name (void)
           =4 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =4 
           =4 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
           =4 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =4 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =4 
           =4 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =4 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =4 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =4 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =4 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) at addr locsegment vartype name
           =4 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) at addr locsegment vartype name
           =4 
           =4 
           =4 // used with UU16
           =4 # define LSB 1
           =4 # define MSB 0
           =4 
           =4 // used with UU32 (b0 is least-significant byte)
           =4 # define b0 3
           =4 # define b1 2
           =4 # define b2 1
           =4 # define b3 0
           =4 
           =4 typedef unsigned char U8;
           =4 typedef unsigned int U16;
           =4 typedef unsigned long U32;
           =4 
           =4 typedef signed char S8;
           =4 typedef signed int S16;
           =4 typedef signed long S32;
           =4 
           =4 typedef union UU16
           =4 {
           =4    U16 U16;
           =4    S16 S16;
           =4    U8 U8[2];
           =4    S8 S8[2];
           =4 } UU16;
           =4 
           =4 typedef union UU32
           =4 {
           =4    U32 U32;
           =4    S32 S32;
           =4    UU16 UU16[2];
           =4    U16 U16[2];
           =4    S16 S16[2];
           =4    U8 U8[4];
           =4    S8 S8[4];
           =4 } UU32;
           =4 
           =4 // NOP () macro support -- NOP is opcode 0x00
           =4 #define NOP() asm { 0x00 }
           =4 
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 
           =4 // Keil C51
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 94  

           =4 // http://www.keil.com
           =4 
           =4 #elif defined __C51__
           =4 
           =4 //#error Keil C51 detected.
           =4 
           =4 # define SEG_GENERIC
           =4 # define SEG_FAR   xdata
           =4 # define SEG_DATA  data
           =4 # define SEG_NEAR  data
           =4 # define SEG_IDATA idata
           =4 # define SEG_XDATA xdata
           =4 # define SEG_PDATA pdata
           =4 # define SEG_CODE  code
           =4 # define SEG_BDATA bdata
           =4 
           =4 # define SBIT(name, addr, bit)  sbit  name = addr^bit
           =4 # define SFR(name, addr)        sfr   name = addr
           =4 # define SFR16(name, addr)      sfr16 name = addr
           =4 # define SFR16E(name, fulladdr) /* not supported */
           =4 # define SFR32(name, fulladdr)  /* not supported */
           =4 # define SFR32E(name, fulladdr) /* not supported */
           =4 
           =4 # define INTERRUPT(name, vector) void name (void) interrupt vector
           =4 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =4 # define INTERRUPT_PROTO(name, vector) void name (void)
           =4 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =4 
           =4 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
           =4 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =4 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =4 
           =4 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =4 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =4 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =4 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =4 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) vartype locsegment name _at_ addr
           =4 
           =4 // used with UU16
           =4 # define LSB 1
           =4 # define MSB 0
           =4 
           =4 // used with UU32 (b0 is least-significant byte)
           =4 # define b0 3
           =4 # define b1 2
           =4 # define b2 1
           =4 # define b3 0
           =4 
           =4 typedef unsigned char U8;
           =4 typedef unsigned int U16;
           =4 typedef unsigned long U32;
           =4 
           =4 typedef signed char S8;
           =4 typedef signed int S16;
           =4 typedef signed long S32;
           =4 
           =4 typedef union UU16
           =4 {
           =4    U16 U16;
           =4    S16 S16;
           =4    U8 U8[2];
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 95  

           =4    S8 S8[2];
           =4 } UU16;
           =4 
           =4 typedef union UU32
           =4 {
           =4    U32 U32;
           =4    S32 S32;
           =4    UU16 UU16[2];
           =4    U16 U16[2];
           =4    S16 S16[2];
           =4    U8 U8[4];
           =4    S8 S8[4];
           =4 } UU32;
           =4 
           =4 // NOP () macro support
           =4 extern void _nop_ (void);
           =4 #define NOP() _nop_()
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 // Hi-Tech 8051
           =4 // http://www.htsoft.com
           =4 
           =4 #elif defined HI_TECH_C
           =4 
           =4 # define SEG_GENERIC
           =4 # define SEG_FAR   far
           =4 # define SEG_DATA  data
           =4 # define SEG_NEAR  near
           =4 # define SEG_IDATA idata
           =4 # define SEG_XDATA xdata
           =4 # define SEG_PDATA pdata
           =4 # define SEG_CODE  code
           =4 # define SEG_BDATA bdata
           =4 
           =4 
           =4 # define SBIT(name, addr, thebit) static volatile bit name @ (addr + thebit)
           =4 # define SFR(name, addr)          static volatile unsigned char name @ addr
           =4 # define SFR16(name, addr)        static volatile unsigned int name @ addr
           =4 # define SFR16E(name, fulladdr) /* not supported */
           =4 # define SFR32(name, fulladdr)  /* not supported */
           =4 # define SFR32E(name, fulladdr) /* not supported */
           =4 
           =4 # define INTERRUPT(name, vector)       void name (void) interrupt vector
           =4 # define INTERRUPT_PROTO(name, vector)
           =4 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =4 # define INTERRUPT_PROTO_USING(name, vector, regnum)
           =4 
           =4 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =4 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =4 // Note: Hi-Tech does not support functions using different register banks. Register
           =4 //       banks can only be specified in interrupts. If a function is called from
           =4 //       inside an interrupt, it will use the same register bank as the interrupt.
           =4 
           =4 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =4 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =4 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =4 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment vartype name @ addr
           =4 
           =4 // used with UU16
           =4 # define LSB 0
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 96  

           =4 # define MSB 1
           =4 
           =4 // used with UU32 (b0 is least-significant byte)
           =4 # define b0 0
           =4 # define b1 1
           =4 # define b2 2
           =4 # define b3 3
           =4 
           =4 typedef unsigned char U8;
           =4 typedef unsigned int U16;
           =4 typedef unsigned long U32;
           =4 
           =4 typedef signed char S8;
           =4 typedef signed int S16;
           =4 typedef signed long S32;
           =4 
           =4 typedef union UU16
           =4 {
           =4    U16 U16;
           =4    S16 S16;
           =4    U8 U8[2];
           =4    S8 S8[2];
           =4 } UU16;
           =4 
           =4 typedef union UU32
           =4 {
           =4    U32 U32;
           =4    S32 S32;
           =4    UU16 UU16[2];
           =4    U16 U16[2];
           =4    S16 S16[2];
           =4    U8 U8[4];
           =4    S8 S8[4];
           =4 } UU32;
           =4 
           =4 // NOP () macro support
           =4 #define NOP() asm(" nop ")
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 // Tasking / Altium
           =4 // http://www.altium.com/tasking
           =4 
           =4 
           =4 #elif defined _CC51
           =4 
           =4 # define SEG_GENERIC
           =4 # define SEG_FAR   _xdat
           =4 # define SEG_DATA  _data
           =4 # define SEG_NEAR  _data
           =4 # define SEG_IDATA _idat
           =4 # define SEG_XDATA _xdat
           =4 # define SEG_PDATA _pdat
           =4 # define SEG_CODE  _rom
           =4 # define SEG_BDATA _bdat
           =4 
           =4 # define SBIT(name, addr, bit)  _sfrbit  name _at(addr+bit)
           =4 # define SFR(name, addr)        _sfrbyte name _at(addr)
           =4 # define SFRX(name, addr)       _xdat volatile unsigned char name _at(addr)
           =4 #if _CC51 > 71
           =4 # define SFR16(name, addr)      _sfrword _little name _at(addr)
           =4 #else
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 97  

           =4 # define SFR16(name, addr)      /* not supported */
           =4 #endif
           =4 # define SFR16E(name, fulladdr) /* not supported */
           =4 # define SFR32(name, fulladdr)  /* not supported */
           =4 # define SFR32E(name, fulladdr) /* not supported */
           =4 
           =4 # define INTERRUPT(name, vector) _interrupt (vector) void name (void)
           =4 # define INTERRUPT_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =4 # define INTERRUPT_PROTO(name, vector) _interrupt (vector) void name (void)
           =4 # define INTERRUPT_PROTO_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =4 
           =4 // When calling FUNCTION_USING in Tasking, the function must be called from an interrupt or Main which
           =4 // is also using the same register bank. If not, the compiler will generate an error.
           =4 # define FUNCTION_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (parameter
             -)
           =4 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (par
             -ameter)
           =4 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =4 
           =4 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =4 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =4 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =4 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) vartype locsegment name _at( addr )
           =4 
           =4 // used with UU16
           =4 # define LSB 1
           =4 # define MSB 0
           =4 
           =4 // used with UU32 (b0 is least-significant byte)
           =4 # define b0 3
           =4 # define b1 2
           =4 # define b2 1
           =4 # define b3 0
           =4 
           =4 typedef unsigned char U8;
           =4 typedef unsigned int U16;
           =4 typedef unsigned long U32;
           =4 
           =4 typedef signed char S8;
           =4 typedef signed int S16;
           =4 typedef signed long S32;
           =4 
           =4 typedef union UU16
           =4 {
           =4    U16 U16;
           =4    S16 S16;
           =4    U8 U8[2];
           =4    S8 S8[2];
           =4 } UU16;
           =4 
           =4 typedef union UU32
           =4 {
           =4    U32 U32;
           =4    S32 S32;
           =4    UU16 UU16[2];
           =4    U16 U16[2];
           =4    S16 S16[2];
           =4    U8 U8[4];
           =4    S8 S8[4];
           =4 } UU32;
           =4 
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 98  

           =4 // NOP () macro support
           =4 extern void _nop (void);
           =4 #define NOP() _nop()
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 
           =4 // IAR 8051
           =4 // http://www.iar.com
           =4 
           =4 #elif defined __ICC8051__
           =4 
           =4 #include <stdbool.h>
           =4 #include <intrinsics.h>
           =4 
           =4 # define SBIT(name, addr, bit)  __bit __no_init volatile bool name @ (addr+bit)
           =4 # define SFR(name, addr)        __sfr __no_init volatile unsigned char name @ addr
           =4 # define SFRX(name, addr)       __xdata __no_init volatile unsigned char name @ addr
           =4 # define SFR16(name, addr)      __sfr __no_init volatile unsigned int  name @ addr
           =4 # define SFR16E(name, fulladdr) /* not supported */
           =4 # define SFR32(name, fulladdr) /* not supported */
           =4 # define SFR32E(name, fulladdr) /* not supported */
           =4 
           =4 # define SEG_GENERIC __generic
           =4 # define SEG_FAR  __xdata
           =4 # define SEG_DATA __data
           =4 # define SEG_NEAR __data
           =4 # define SEG_IDATA __idata
           =4 # define SEG_XDATA __xdata
           =4 # define SEG_PDATA __pdata
           =4 # define SEG_CODE  __code
           =4 # define SEG_BDATA __bdata
           =4 
           =4 #define bit bool
           =4 
           =4 # define _PPTOSTR_(x) #x
           =4 # define _PPARAM_(address) _PPTOSTR_(vector=address * 8 + 3)
           =4 # define _PPARAM2_(regbank) _PPTOSTR_(register_bank=regbank)
           =4 # define INTERRUPT(name, vector) _Pragma(_PPARAM_(vector)) __interrupt void name(void)
           =4 # define INTERRUPT_PROTO(name, vector)  __interrupt void name(void)
           =4 # define INTERRUPT_USING(name, vector, regnum) _Pragma(_PPARAM2_(regnum)) _Pragma(_PPARAM_(vector)) __inte
             -rrupt void name(void)
           =4 # define INTERRUPT_PROTO_USING(name, vector, regnum) __interrupt void name(void)
           =4 
           =4 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =4 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =4 // Note: IAR does not support functions using different register banks. Register
           =4 //       banks can only be specified in interrupts. If a function is called from
           =4 //       inside an interrupt, it will use the same register bank as the interrupt.
           =4 
           =4 # define SEGMENT_VARIABLE(name, vartype, locsegment)  locsegment vartype name
           =4 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment  * name
           =4 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =4 
           =4 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment __no_init vartype name @ addr
           =4 
           =4 // used with UU16
           =4 # define LSB 0
           =4 # define MSB 1
           =4 
           =4 // used with UU32 (b0 is least-significant byte)
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 99  

           =4 # define b0 0
           =4 # define b1 1
           =4 # define b2 2
           =4 # define b3 3
           =4 
           =4 typedef unsigned char U8;
           =4 typedef unsigned int U16;
           =4 typedef unsigned long U32;
           =4 
           =4 typedef signed char S8;
           =4 typedef signed int S16;
           =4 typedef signed long S32;
           =4 
           =4 typedef union UU16
           =4 {
           =4    U16 U16;
           =4    S16 S16;
           =4    U8 U8[2];
           =4    S8 S8[2];
           =4 } UU16;
           =4 
           =4 typedef union UU32
           =4 {
           =4    U32 U32;
           =4    S32 S32;
           =4    UU16 UU16[2];
           =4    U16 U16[2];
           =4    S16 S16[2];
           =4    U8 U8[4];
           =4    S8 S8[4];
           =4 } UU32;
           =4 
           =4 
           =4 #define NOP() __no_operation();
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 // Crossware
           =4 // http://www.crossware.com
           =4 
           =4 #elif defined _XC51_VER
           =4 # define SBIT(name, addr, bit)  _sfrbit  name = (addr+bit)
           =4 # define SFR(name, addr)        _sfr     name = addr
           =4 # define SFR16(name, addr)      _sfrword name = addr
           =4 # define SFR16E(name, fulladdr) /* not supported */
           =4 # define SFR32(name, fulladdr)  /* not supported */
           =4 # define SFR32E(name, fulladdr) /* not supported */
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 // Wickenhäuser
           =4 // http://www.wickenhaeuser.de
           =4 
           =4 #elif defined __UC__
           =4 # define SBIT(name, addr, bit)  unsigned char bit  name @ (addr+bit)
           =4 # define SFR(name, addr)        near unsigned char name @ addr
           =4 # define SFR16(name, addr)      /* not supported */
           =4 # define SFR16E(name, fulladdr) /* not supported */
           =4 # define SFR32(name, fulladdr)  /* not supported */
           =4 # define SFR32E(name, fulladdr) /* not supported */
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 100 

           =4 // Default
           =4 // Unknown compiler
           =4 
           =4 #else
           =4 # warning unrecognized compiler
           =4 # define SBIT(name, addr, bit)  volatile bool           name
           =4 # define SFR(name, addr)        volatile unsigned char  name
           =4 # define SFRX(name, addr)       volatile unsigned char  name
           =4 # define SFR16(name, addr)      volatile unsigned short name
           =4 # define SFR16E(name, fulladdr) volatile unsigned short name
           =4 # define SFR32(name, fulladdr)  volatile unsigned long  name
           =4 # define SFR32E(name, fulladdr) volatile unsigned long  name
           =4 
           =4 #endif
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Header File PreProcessor Directive
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 #endif                                 // #define COMPILER_DEFS_H
 689      =4  
 690      =4  //-----------------------------------------------------------------------------
 691      =4  // End Of File
 692      =4  //-----------------------------------------------------------------------------
  10      =3  #include <C8051F580_defs.h> // SFR declarations
   1      =4  //-----------------------------------------------------------------------------
   2      =4  // C8051F580_defs.h
   3      =4  //-----------------------------------------------------------------------------
   4      =4  // Copyright 2008, Silicon Laboratories, Inc.
   5      =4  // http://www.silabs.com
   6      =4  //
   7      =4  // Program Description:
   8      =4  //
   9      =4  // Register/bit definitions for the C8051F58x family.
  10      =4  // **Important Note**: The compiler_defs.h header file should be included
  11      =4  // before including this header file.
  12      =4  //
  13      =4  // Target:         C8051F580/1/2/3/4/5/6/7,8/9-F590/1
  14      =4  // Tool chain:     Generic
  15      =4  // Command Line:   None
  16      =4  //
  17      =4  // Release 0.6 - 20 AUG 2012 (TP)
  18      =4  //    -Added #define for _XPAGE to provide support for SDCC memory paging
  19      =4  //     (pdata)
  20      =4  //
  21      =4  // Release 0.5 - 10 SEP 2011 (GP)
  22      =4  //    - Fixed SFR16 definition for CAN0IF2MC
  23      =4  //
  24      =4  // Release 0.4 - 08 OCT 2010 (TP)
  25      =4  //    - Fixed bit definitions for SCON0
  26      =4  //
  27      =4  // Release 0.3 - 01 APR 2009 (GP)
  28      =4  //    - Added SN0-SN3
  29      =4  //
  30      =4  // Release 0.2 - 29 JUL 2008 (ADT)
  31      =4  //    - Added Timer 4 bit definitions
  32      =4  //
  33      =4  // Release 0.1 - 09 JUL 2008 (GP)
  34      =4  //    - Initial Revision
  35      =4  //
  36      =4  //-----------------------------------------------------------------------------
  37      =4  // Header File Preprocessor Directive
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 101 

  38      =4  //-----------------------------------------------------------------------------
  39      =4  
  40      =4  #ifndef C8051F580_DEFS_H
           =4 #define C8051F580_DEFS_H
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Page 0, Page 1 and Page F Registers
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 SFR (P0, 0x80);                        // Port 0 Latch
           =4 SFR (SP, 0x81);                        // Stack Pointer
           =4 SFR (DPL, 0x82);                       // Data Pointer Low
           =4 SFR (DPH, 0x83);                       // Data Pointer High
           =4 SFR (SFR0CN, 0x84);                    // SFR Page Control
           =4 SFR (SFRNEXT, 0x85);                   // SFR stack next page
           =4 SFR (SFRLAST, 0x86);                   // SFR stack last page
           =4 SFR (PCON, 0x87);                      // Power Control
           =4 SFR (TCON, 0x88);                      // Timer/Counter Control
           =4 SFR (TMOD, 0x89);                      // Timer/Counter Mode
           =4 SFR (TL0, 0x8A);                       // Timer/Counter 0 Low
           =4 SFR (TL1, 0x8B);                       // Timer/Counter 1 Low
           =4 SFR (TH0, 0x8C);                       // Timer/Counter 0 High
           =4 SFR (TH1, 0x8D);                       // Timer/Counter 1 High
           =4 SFR (CKCON, 0x8E);                     // Clock Control
           =4 SFR (PSCTL, 0x8F);                     // Program Store R/W Control
           =4 SFR (CLKSEL, 0x8F);                    // System clock select
           =4 SFR (P1, 0x90);                        // Port 1 Latch
           =4 SFR (TMR3CN, 0x91);                    // Timer/Counter 3 Control
           =4 SFR (TMR5CN, 0x91);                    // Timer/Counter 5 Control
           =4 SFR (TMR3RLL, 0x92);                   // Timer/Counter 3 Reload Low
           =4 SFR (TMR5CAPL, 0x92);                  // Timer/Counter 5 Capture Low
           =4 SFR (TMR3RLH, 0x93);                   // Timer/Counter 3 Reload High
           =4 SFR (TMR5CAPH, 0x93);                  // Timer/Counter 5 Capture High
           =4 SFR (TMR3L, 0x94);                     // Timer/Counter 3 Low
           =4 SFR (TMR5L, 0x94);                     // Timer/Counter 5 Low
           =4 SFR (TMR3H, 0x95);                     // Timer/Counter 3 High
           =4 SFR (TMR5H, 0x95);                     // Timer/Counter 5 High
           =4 SFR (TMR5CF, 0x96);                    // Timer/Counter 5 Configuration
           =4 SFR (CLKMUL, 0x97);                    // Clock Multiplier
           =4 SFR (SCON0, 0x98);                     // UART0 Control
           =4 SFR (SCON1, 0x98);                     // UART1 Control
           =4 SFR (SBUF0, 0x99);                     // UART0 Data Buffer
           =4 SFR (SBUF1, 0x99);                     // UART1 Data Buffer
           =4 SFR (CPT0CN, 0x9A);                    // Comparator 0 Control
           =4 SFR (CPT2CN, 0x9A);                    // Comparator 2 Control
           =4 SFR (CPT0MD, 0x9B);                    // Comparator 0 Mode
           =4 SFR (CPT2MD, 0x9B);                    // Comparator 2 Mode
           =4 SFR (CPT0MX, 0x9C);                    // Comparator 0 Mux
           =4 SFR (CPT2MX, 0x9C);                    // Comparator 2 Mux
           =4 SFR (CPT1CN, 0x9D);                    // Comparator 1 Control
           =4 SFR (CPT1MD, 0x9E);                    // Comparator 0 Mode
           =4 SFR (OSCIFIN, 0x9E);                   // Internal Oscillator Fine Control
           =4 SFR (CPT1MX, 0x9F);                    // Comparator 1 Mux
           =4 SFR (OSCXCN, 0x9F);                    // External Oscillator Control
           =4 SFR (P2, 0xA0);                        // Port 2 Latch
           =4 SFR (SPI0CFG, 0xA1);                   // SPI0 Configuration
           =4 SFR (OSCICN, 0xA1);                    // Internal Oscillator Control
           =4 SFR (SPI0CKR, 0xA2);                   // SPI0 Clock rate control
           =4 SFR (OSCICRS, 0xA2);                   // Internal Oscillator Coarse Control
           =4 SFR (SPI0DAT, 0xA3);                   // SPI0 Data Buffer
           =4 SFR (P0MDOUT, 0xA4);                   // Port 0 Output Mode
           =4 SFR (P1MDOUT, 0xA5);                   // Port 1 Output Mode
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 102 

           =4 SFR (P2MDOUT, 0xA6);                   // Port 2 Output Mode
           =4 SFR (SFRPAGE, 0xA7);                   // SFR Page Select
           =4 SFR (IE, 0xA8);                        // Interrupt Enable
           =4 SFR (SMOD0, 0xA9);                     // Serial Port 0 Control
           =4 SFR (EMI0CN, 0xAA);                    // EMIF Control
           =4 SFR (EMI0TC, 0xAA);                    // EMIF Timing control
           =4 SFR (SBCON0, 0xAB);                    // UART0 Baud Rate Generator Control
           =4 SFR (SBRLL0, 0xAC);                    // UART0 Baud Rate Generator Low
           =4 SFR (SBRLH0, 0xAD);                    // UART0 Baud Rate Generator High
           =4 SFR (P3MAT, 0xAE);                     // Port 3 Match
           =4 SFR (P3MDOUT, 0xAE);                   // Port 3 Mode
           =4 SFR (P3MASK, 0xAF);                    // Port 3 Mask
           =4 SFR (P4MDOUT, 0xAF);                   // Port 4 Mode
           =4 SFR (P3, 0xB0);                        // Port 3 Latch
           =4 SFR (P2MAT, 0xB1);                     // Port 2 Match
           =4 SFR (P2MASK, 0xB2);                    // Port 2 Mask
           =4 SFR (EMI0CF, 0xB2);                    // EMIF Configuration
           =4 SFR (P4, 0xB5);                        // Port 4 Latch
           =4 SFR (FLSCL, 0xB6);                     // Flash Scale
           =4 SFR (FLKEY, 0xB7);                     // Flash access limit
           =4 SFR (IP, 0xB8);                        // Interrupt Priority
           =4 SFR (SMB0ADR, 0xB9);                   // SMBus0 Slave address
           =4 SFR (ADC0TK, 0xBA);                    // ADC0 Tracking Mode Select
           =4 SFR (SMB0ADM, 0xBA);                   // SMBus0 Address Mask
           =4 SFR (ADC0MX, 0xBB);                    // AMUX0 Channel select
           =4 SFR (ADC0CF, 0xBC);                    // AMUX0 Channel configuration
           =4 SFR (ADC0L, 0xBD);                     // ADC0 Data Low
           =4 SFR (ADC0H, 0xBE);                     // ADC0 Data High
           =4 SFR (SMB0CN, 0xC0);                    // SMBus0 Control
           =4 SFR (SMB0CF, 0xC1);                    // SMBus0 Configuration
           =4 SFR (SMB0DAT, 0xC2);                   // SMBus0 Data
           =4 SFR (ADC0GTL, 0xC3);                   // ADC0 Greater-Than Compare Low
           =4 SFR (ADC0GTH, 0xC4);                   // ADC0 Greater-Than Compare High
           =4 SFR (ADC0LTL, 0xC5);                   // ADC0 Less-Than Compare Word Low
           =4 SFR (ADC0LTH, 0xC6);                   // ADC0 Less-Than Compare Word High
           =4 SFR (XBR3, 0xC6);                      // Port I/O Crossbar Control 3
           =4 SFR (XBR2, 0xC7);                      // Port I/O Crossbar Control 2
           =4 SFR (TMR2CN, 0xC8);                    // Timer/Counter 2 Control
           =4 SFR (TMR4CN, 0xC8);                    // Timer/Counter 4 Control
           =4 SFR (REG0CN, 0xC9);                    // Regulator Control
           =4 SFR (LIN0CF, 0xC9);                    // LIN 0 Configuration
           =4 SFR (TMR4CF, 0xC9);                    // Timer/Counter 4 Configuration
           =4 SFR (TMR2RLL, 0xCA);                   // Timer/Counter 2 Reload Low
           =4 SFR (TMR4CAPL, 0xCA);                  // Timer/Counter 4 Capture Low
           =4 SFR (TMR2RLH, 0xCB);                   // Timer/Counter 2 Reload High
           =4 SFR (TMR4CAPH, 0xCB);                  // Timer/Counter 4 Capture High
           =4 SFR (TMR2L, 0xCC);                     // Timer/Counter 2 Low
           =4 SFR (TMR4L, 0xCC);                     // Timer/Counter 4 Low
           =4 SFR (TMR2H, 0xCD);                     // Timer/Counter 2 High
           =4 SFR (TMR4H, 0xCD);                     // Timer/Counter 4 High
           =4 SFR (PCA0CPL5, 0xCE);                  // PCA0 Capture 5 Low
           =4 SFR (PCA1CPL11, 0xCE);                 // PCA1 Capture 11 Low
           =4 SFR (PCA0CPH5, 0xCF);                  // PCA0 Capture 5 High
           =4 SFR (PCA1CPH11, 0xCF);                 // PCA1 Capture 11 High
           =4 SFR (PSW, 0xD0);                       // Program Status Word
           =4 SFR (REF0CN, 0xD1);                    // Voltage Reference Control
           =4 SFR (LIN0DAT, 0xD2);                   // LIN0 Data
           =4 SFR (LIN0ADR, 0xD3);                   // LIN0 Address
           =4 SFR (P0SKIP, 0xD4);                    // Port 0 Skip
           =4 SFR (P1SKIP, 0xD5);                    // Port 1 Skip
           =4 SFR (P2SKIP, 0xD6);                    // Port 2 Skip
           =4 SFR (P3SKIP, 0xD7);                    // Port 3 Skip
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 103 

           =4 SFR (PCA0CN, 0xD8);                    // PCA0 Control
           =4 SFR (PCA1CN, 0xD8);                    // PCA1 Control
           =4 SFR (PCA0MD, 0xD9);                    // PCA0 Mode
           =4 SFR (PCA1MD, 0xD9);                    // PCA1 Mode
           =4 SFR (PCA0PWM, 0xD9);                   // PCA0 PWM Control
           =4 SFR (PCA0CPM0, 0xDA);                  // PCA0 Module 0 Mode
           =4 SFR (PCA1CPM6, 0xDA);                  // PCA1 Module 6 Mode
           =4 SFR (PCA1PWM, 0xDA);                   // PCA1 PWM Control
           =4 SFR (PCA0CPM1, 0xDB);                  // PCA0 Module 1  Mode
           =4 SFR (PCA1CPM7, 0xDB);                  // PCA1 Module 7  Mode
           =4 SFR (PCA0CPM2, 0xDC);                  // PCA0 Module 2  Mode
           =4 SFR (PCA1CPM8, 0xDC);                  // PCA1 Module 8  Mode
           =4 SFR (PCA0CPM3, 0xDD);                  // PCA0 Module 3  Mode
           =4 SFR (PCA1CPM9, 0xDD);                  // PCA1 Module 9  Mode
           =4 SFR (PCA0CPM4, 0xDE);                  // PCA0 Module 4  Mode
           =4 SFR (PCA1CPM10, 0xDE);                  // PCA1 Module 10 Mode
           =4 SFR (PCA0CPM5, 0xDF);                  // PCA0 Module 5  Mode
           =4 SFR (PCA1CPM11, 0xDF);                  // PCA1 Module 11 Mode
           =4 SFR (ACC, 0xE0);                       // Accumulator
           =4 SFR (XBR0, 0xE1);                      // Port I/O Crossbar Control 0
           =4 SFR (XBR1, 0xE2);                      // Port I/O Crossbar Control 1
           =4 SFR (CCH0CN, 0xE3);                    // Cache control
           =4 SFR (IT01CF, 0xE4);                    // INT0/INT1 Configuration
           =4 SFR (EIE1, 0xE6);                      // Extended Interrupt Enable 2
           =4 SFR (EIE2, 0xE7);                      // Extended Interrupt Enable 2
           =4 SFR (ADC0CN, 0xE8);                    // ADC0 Control
           =4 SFR (PCA0CPL1, 0xE9);                  // PCA0 Capture 1 Low
           =4 SFR (PCA1CPL1, 0xE9);                  // PCA1 Capture 7 Low
           =4 SFR (PCA0CPH1, 0xEA);                  // PCA0 Capture 1 High
           =4 SFR (PCA1CPH1, 0xEA);                  // PCA1 Capture 7 High
           =4 SFR (PCA0CPL2, 0xEB);                  // PCA0 Capture 2 Low
           =4 SFR (PCA1CPL2, 0xEB);                  // PCA1 Capture 8 Low
           =4 SFR (PCA0CPH2, 0xEC);                  // PCA0 Capture 2 High
           =4 SFR (PCA1CPH2, 0xEC);                  // PCA1 Capture 8 High
           =4 SFR (PCA0CPL3, 0xED);                  // PCA0 Capture 3 Low
           =4 SFR (PCA1CPL3, 0xED);                  // PCA1 Capture 9 Low
           =4 SFR (PCA0CPH3, 0xEE);                  // PCA0 Capture 3 High
           =4 SFR (PCA1CPH3, 0xEE);                  // PCA1 Capture 9 High
           =4 SFR (RSTSRC, 0xEF);                    // Reset Source Configuration/Status
           =4 SFR (B, 0xF0);                         // B Register
           =4 SFR (P0MAT, 0xF1);                     // Port 0 Match
           =4 SFR (P0MDIN, 0xF1);                    // Port 0 Input Mode
           =4 SFR (P0MASK, 0xF2);                    // Port 0 Mask
           =4 SFR (P1MDIN, 0xF2);                    // Port 1 Input Mode
           =4 SFR (P1MAT, 0xF3);                     // Port 1 Match
           =4 SFR (P2MDIN, 0xF3);                    // Port 2 Input Mode
           =4 SFR (P1MASK, 0xF4);                    // Port 1 Mask
           =4 SFR (P3MDIN, 0xF4);                    // Port 3 Input Mode
           =4 SFR (PSBANK, 0xF5);                    // Program Space Bank Select
           =4 SFR (EIP1, 0xF6);                      // External Interrupt Priority 1
           =4 SFR (EIP2, 0xF7);                      // External Interrupt Priority 2
           =4 SFR (SPI0CN, 0xF8);                    // SPI0 Control
           =4 SFR (PCA0L, 0xF9);                     // PCA0 Counter Low
           =4 SFR (PCA1L, 0xF9);                     // PCA1 Counter Low
           =4 SFR (SN0, 0xF9);                       // Serial Number 0
           =4 SFR (PCA0H, 0xFA);                     // PCA0 Counter High
           =4 SFR (PCA1H, 0xFA);                     // PCA1 Counter High
           =4 SFR (SN1, 0xFA);                       // Serial Number 1
           =4 SFR (PCA0CPL0, 0xFB);                  // PCA0 Capture 0 Low
           =4 SFR (PCA1CPL6, 0xFB);                  // PCA1 Capture 6 Low
           =4 SFR (SN2, 0xFB);                       // Serial Number 2
           =4 SFR (PCA0CPH0, 0xFC);                  // PCA0 Capture 0 High
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 104 

           =4 SFR (PCA1CPH6, 0xFC);                  // PCA1 Capture 6 High
           =4 SFR (SN3, 0xFC);                       // Serial Number 3
           =4 SFR (PCA0CPL4, 0xFD);                  // PCA0 Capture 4 Low
           =4 SFR (PCA1CPL10, 0xFD);                 // PCA1 Capture 10 Low
           =4 SFR (PCA0CPH4, 0xFE);                  // PCA0 Capture 4 High
           =4 SFR (PCA1CPH10, 0xFE);                 // PCA1 Capture 10 High
           =4 SFR (VDM0CN, 0xFF);                    // VDD Monitor Control
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Page C (CAN0) Registers
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 SFR (CAN0CFG, 0x92);                   // CAN0 Clock Configuration
           =4 SFR (CAN0STAT, 0x94);                  // Status Register Low Byte
           =4 SFR (CAN0ERRL, 0x96);                  // Error Counter Low Byte
           =4 SFR (CAN0ERRH, 0x97);                  // Error Counter High Byte
           =4 SFR (CAN0BTL, 0x9A);                   // Bit Timing Register Low Byte
           =4 SFR (CAN0BTH, 0x9B);                   // Bit Timing Register High Byte
           =4 SFR (CAN0IIDL, 0x9C);                  // Interrupt Register Low Byte
           =4 SFR (CAN0IIDH, 0x9D);                  // Interrupt Register High Byte
           =4 SFR (CAN0TST, 0x9E);                   // Test Register Low Byte
           =4 SFR (CAN0BRPE, 0xA1);                  // BRP Extension Register Low Byte
           =4 SFR (CAN0TR1L, 0xA2);                  // Transmission Request 1 Low Byte
           =4 SFR (CAN0TR1H, 0xA3);                  // Transmission Request 1 High Byte
           =4 SFR (CAN0TR2L, 0xA4);                  // Transmission Request 2 Low Byte
           =4 SFR (CAN0TR2H, 0xA5);                  // Transmission Request 2 High Byte
           =4 SFR (CAN0ND1L, 0xAA);                  // New Data 1 Low Byte
           =4 SFR (CAN0ND1H, 0xAB);                  // New Data 1 High Byte
           =4 SFR (CAN0ND2L, 0xAC);                  // New Data 2 Low Byte
           =4 SFR (CAN0ND2H, 0xAD);                  // New Data 2 High Byte
           =4 SFR (CAN0IP1L, 0xAE);                  // Interrupt Pending 1 Low Byte
           =4 SFR (CAN0IP1H, 0xAF);                  // Interrupt Pending 1 High Byte
           =4 SFR (CAN0IP2L, 0xB2);                  // Interrupt Pending 2 Low Byte
           =4 SFR (CAN0IP2H, 0xB3);                  // Interrupt Pending 2 High Byte
           =4 SFR (CAN0MV1L, 0xBA);                  // Message Valid 1 Low Byte
           =4 SFR (CAN0MV1H, 0xBB);                  // Message Valid 1 High Byte
           =4 SFR (CAN0MV2L, 0xBC);                  // Message Valid 2 Low Byte
           =4 SFR (CAN0MV2H, 0xBD);                  // Message Valid 2 High Byte
           =4 SFR (CAN0IF1CRL, 0xBE);                // IF1 Command Request Low Byte
           =4 SFR (CAN0IF1CRH, 0xBF);                // IF1 Command Request High Byte
           =4 SFR (CAN0CN, 0xC0);                    // CAN Control Register Low Byte
           =4 SFR (CAN0IF1CML, 0xC2);                // IF1 Command Mask Low Byte
           =4 SFR (CAN0IF1CMH, 0xC3);                // IF1 Command Mask High Byte
           =4 SFR (CAN0IF1M1L, 0xC4);                // IF1 Mask 1 Low Byte
           =4 SFR (CAN0IF1M1H, 0xC5);                // IF1 Mask 1 High Byte
           =4 SFR (CAN0IF1M2L, 0xC6);                // IF1 Mask 2 Low Byte
           =4 SFR (CAN0IF1M2H, 0xC7);                // IF1 Mask 2 High Byte
           =4 SFR (CAN0IF1A1L, 0xCA);                // IF1 Arbitration 1 Low Byte
           =4 SFR (CAN0IF1A1H, 0xCB);                // IF1 Arbitration 1 High Byte
           =4 SFR (CAN0IF1A2L, 0xCC);                // IF1 Arbitration 2 Low Byte
           =4 SFR (CAN0IF1A2H, 0xCD);                // IF1 Arbitration 2 High Byte
           =4 SFR (CAN0IF2MCL, 0xCE);                // IF2 Message Control Low Byte
           =4 SFR (CAN0IF2MCH, 0xCF);                // IF2 Message Control High Byte
           =4 SFR (CAN0IF1MCL, 0xD2);                // IF1 Message Control Low Byte
           =4 SFR (CAN0IF1MCH, 0xD3);                // IF1 Message Control High Byte
           =4 SFR (CAN0IF1DA1L, 0xD4);               // IF1 Data A 1 Low Byte
           =4 SFR (CAN0IF1DA1H, 0xD5);               // IF1 Data A 1 High Byte
           =4 SFR (CAN0IF1DA2L, 0xD6);               // IF1 Data A 2 Low Byte
           =4 SFR (CAN0IF1DA2H, 0xD7);               // IF1 Data A 2 High Byte
           =4 SFR (CAN0IF1DB1L, 0xDA);               // IF1 Data B 1 Low Byte
           =4 SFR (CAN0IF1DB1H, 0xDB);               // IF1 Data B 1 High Byte
           =4 SFR (CAN0IF1DB2L, 0xDC);               // IF1 Data B 2 Low Byte
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 105 

           =4 SFR (CAN0IF1DB2H, 0xDD);               // IF1 Data B 2 High Byte
           =4 SFR (CAN0IF2CRL, 0xDE);                // IF2 Command Request Low Byte
           =4 SFR (CAN0IF2CRH, 0xDF);                // IF2 Command Request High Byte
           =4 SFR (CAN0IF2CML, 0xE2);                // IF2 Command Mask Low Byte
           =4 SFR (CAN0IF2CMH, 0xE3);                // IF2 Command Mask High Byte
           =4 SFR (CAN0IF2M1L, 0xEA);                // IF2 Mask 1 Low Byte
           =4 SFR (CAN0IF2M1H, 0xEB);                // IF2 Mask 1 High Byte
           =4 SFR (CAN0IF2M2L, 0xEC);                // IF2 Mask 2 Low Byte
           =4 SFR (CAN0IF2M2H, 0xED);                // IF2 Mask 2 High Byte
           =4 SFR (CAN0IF2A1L, 0xEE);                // IF2 Arbitration 1 Low Byte
           =4 SFR (CAN0IF2A1H, 0xEF);                // IF2 Arbitration 1 High Byte
           =4 SFR (CAN0IF2A2L, 0xF2);                // IF2 Arbitration 2 Low Byte
           =4 SFR (CAN0IF2A2H, 0xF3);                // IF2 Arbitration 2 High Byte
           =4 SFR (CAN0IF2DA1L, 0xF6);               // IF2 Data A 1 Low Byte
           =4 SFR (CAN0IF2DA1H, 0xF7);               // IF2 Data A 1 High Byte
           =4 SFR (CAN0IF2DA2L, 0xFA);               // IF2 Data A 2 Low Byte
           =4 SFR (CAN0IF2DA2H, 0xFB);               // IF2 Data A 2 High Byte
           =4 SFR (CAN0IF2DB1L, 0xFC);               // IF2 Data B 1 Low Byte
           =4 SFR (CAN0IF2DB1H, 0xFD);               // IF2 Data B 1 High Byte
           =4 SFR (CAN0IF2DB2L, 0xFE);               // IF2 Data B 2 Low Byte
           =4 SFR (CAN0IF2DB2H, 0xFF);               // IF2 Data B 2 High Byte
           =4 
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // 16-bit Register Definitions (might not be supported by all compilers)
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 SFR16 (DP, 0x82);                      // Data Pointer
           =4 SFR16 (TMR3RL, 0x92);                  // Timer 3 Reload
           =4 SFR16 (TMR5CAP, 0x92);                 // Timer 5 Capture
           =4 SFR16 (TMR3, 0x94);                    // Timer 3 Capture / Reload
           =4 SFR16 (TMR5, 0x94);                    // Timer 5
           =4 SFR16 (SBRL0, 0xAC);                   // UART0 Reload
           =4 SFR16 (ADC0, 0xBD);                    // ADC0 data
           =4 SFR16 (ADC0GT, 0xC3);                  // ADC0 Greater Than Window
           =4 SFR16 (ADC0LT, 0xC5);                  // ADC0 Less Than Window
           =4 SFR16 (TMR2RL, 0xCA);                  // Timer 2 Reload
           =4 SFR16 (TMR4CAP, 0xCA);                 // Timer 4 Capture
           =4 SFR16 (TMR2, 0xCC);                    // Timer 2 Capture / Reload
           =4 SFR16 (TMR4, 0xCC);                    // Timer 4
           =4 SFR16 (PCA0CP5, 0xCE);                 // PCA0 Module 5 Capture
           =4 SFR16 (PCA1CP11, 0xCE);                // PCA1 Module 11 Capture
           =4 SFR16 (PCA0CP1, 0xE9);                 // PCA0 Module 1 Capture
           =4 SFR16 (PCA1CP7, 0xE9);                 // PCA1 Module 7 Capture
           =4 SFR16 (PCA0CP2, 0xEB);                 // PCA0 Module 2 Capture
           =4 SFR16 (PCA1CP8, 0xEB);                 // PCA1 Module 8 Capture
           =4 SFR16 (PCA0CP3, 0xED);                 // PCA0 Module 3 Capture
           =4 SFR16 (PCA1CP9, 0xED);                 // PCA1 Module 9 Capture
           =4 SFR16 (PCA0, 0xF9);                    // PCA0 Counter
           =4 SFR16 (PCA1, 0xF9);                    // PCA1 Counter
           =4 SFR16 (PCA0CP0, 0xFB);                 // PCA0 Module 0 Capture
           =4 SFR16 (PCA1CP6, 0xFB);                 // PCA1 Module 6 Capture
           =4 SFR16 (PCA0CP4, 0xFD);                 // PCA0 Module 4 Capture
           =4 SFR16 (PCA1CP10, 0xFD);                 // PCA1 Module 10 Capture
           =4 
           =4 SFR16 (CAN0ERR, 0x96);                 // Error Counter
           =4 SFR16 (CAN0BT, 0x9A);                  // Bit Timing Register
           =4 SFR16 (CAN0IID, 0x9C);                 // Interrupt Register
           =4 SFR16 (CAN0TR1, 0xA2);                 // Transmission Request 1
           =4 SFR16 (CAN0TR2, 0xA4);                 // Transmission Request 2
           =4 SFR16 (CAN0ND1, 0xAA);                 // New Data 1
           =4 SFR16 (CAN0ND2, 0xAC);                 // New Data 2
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 106 

           =4 SFR16 (CAN0IP1, 0xAE);                 // Interrupt Pending 1
           =4 SFR16 (CAN0IP2, 0xB2);                 // Interrupt Pending 2
           =4 SFR16 (CAN0MV1, 0xBA);                 // Message Valid 1
           =4 SFR16 (CAN0MV2, 0xBC);                 // Message Valid 2
           =4 SFR16 (CAN0IF1CR, 0xBE);               // IF1 Command Request
           =4 SFR16 (CAN0IF1CM, 0xC2);               // IF1 Command Mask
           =4 SFR16 (CAN0IF1M1, 0xC4);               // IF1 Mask 1
           =4 SFR16 (CAN0IF1M2, 0xC6);               // IF1 Mask 2
           =4 SFR16 (CAN0IF1A1, 0xCA);               // IF1 Arbitration 1
           =4 SFR16 (CAN0IF1A2, 0xCC);               // IF1 Arbitration 2
           =4 SFR16 (CAN0IF1MC, 0xD2);               // IF1 Message Control
           =4 SFR16 (CAN0IF1DA1, 0xD4);              // IF1 Data A 1
           =4 SFR16 (CAN0IF1DA2, 0xD6);              // IF1 Data A 2
           =4 SFR16 (CAN0IF1DB1, 0xDA);              // IF1 Data B 1
           =4 SFR16 (CAN0IF1DB2, 0xDC);              // IF1 Data B 2
           =4 SFR16 (CAN0IF2CR, 0xDE);               // IF2 Command Request
           =4 SFR16 (CAN0IF2CM, 0xE2);               // IF2 Command Mask
           =4 SFR16 (CAN0IF2M1, 0xEA);               // IF2 Mask 1
           =4 SFR16 (CAN0IF2M2, 0xEC);               // IF2 Mask 2
           =4 SFR16 (CAN0IF2A1, 0xEE);               // IF2 Arbitration 1
           =4 SFR16 (CAN0IF2A2, 0xF2);               // IF2 Arbitration 2
           =4 SFR16 (CAN0IF2MC, 0xCE);               // IF2 Message Control
           =4 SFR16 (CAN0IF2DA1, 0xF6);              // IF2 Data A 1
           =4 SFR16 (CAN0IF2DA2, 0xFA);              // IF2 Data A 2
           =4 SFR16 (CAN0IF2DB1, 0xFC);              // IF2 Data B 1
           =4 SFR16 (CAN0IF2DB2, 0xFE);              // IF2 Data B 2
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // LIN0 Indirect Registers
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 #define  LIN0DT1   0x00                // LIN0 Data Byte 1
           =4 #define  LIN0DT2   0x01                // LIN0 Data Byte 2
           =4 #define  LIN0DT3   0x02                // LIN0 Data Byte 3
           =4 #define  LIN0DT4   0x03                // LIN0 Data Byte 4
           =4 #define  LIN0DT5   0x04                // LIN0 Data Byte 5
           =4 #define  LIN0DT6   0x05                // LIN0 Data Byte 6
           =4 #define  LIN0DT7   0x06                // LIN0 Data Byte 7
           =4 #define  LIN0DT8   0x07                // LIN0 Data Byte 8
           =4 #define  LIN0CTRL  0x08                // LIN0 Control
           =4 #define  LIN0ST    0x09                // LIN0 Status
           =4 #define  LIN0ERR   0x0A                // LIN0 Error
           =4 #define  LIN0SIZE  0x0B                // LIN0 Message Size
           =4 #define  LIN0DIV   0x0C                // LIN0 Divider
           =4 #define  LIN0MUL   0x0D                // LIN0 Multiplier
           =4 #define  LIN0ID    0x0E                // LIN0 Identifier
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Address Definitions for Bit-addressable Registers
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 #define SFR_P0       0x80
           =4 #define SFR_TCON     0x88
           =4 #define SFR_P1       0x90
           =4 #define SFR_SCON0    0x98
           =4 #define SFR_SCON1    0x98
           =4 #define SFR_P2       0xA0
           =4 #define SFR_IE       0xA8
           =4 #define SFR_P3       0xB0
           =4 #define SFR_IP       0xB8
           =4 #define SFR_SMB0CN   0xC0
           =4 #define SFR_TMR2CN   0xC8
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 107 

           =4 #define SFR_TMR4CN   0xC8
           =4 #define SFR_PSW      0xD0
           =4 #define SFR_PCA0CN   0xD8
           =4 #define SFR_PCA1CN   0xD8
           =4 #define SFR_ACC      0xE0
           =4 #define SFR_ADC0CN   0xE8
           =4 #define SFR_B        0xF0
           =4 #define SFR_SPI0CN   0xF8
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Bit Definitions
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 // TCON 0x88
           =4 SBIT (TF1, SFR_TCON, 7);               // Timer 1 Overflow Flag
           =4 SBIT (TR1, SFR_TCON, 6);               // Timer 1 On/Off Control
           =4 SBIT (TF0, SFR_TCON, 5);               // Timer 0 Overflow Flag
           =4 SBIT (TR0, SFR_TCON, 4);               // Timer 0 On/Off Control
           =4 SBIT (IE1, SFR_TCON, 3);               // Ext. Interrupt 1 Edge Flag
           =4 SBIT (IT1, SFR_TCON, 2);               // Ext. Interrupt 1 Type
           =4 SBIT (IE0, SFR_TCON, 1);               // Ext. Interrupt 0 Edge Flag
           =4 SBIT (IT0, SFR_TCON, 0);               // Ext. Interrupt 0 Type
           =4 
           =4 // SCON0 0x98
           =4 SBIT (OVR0, SFR_SCON0, 7);             // UART0 Receive FIFO Overrun Flag
           =4 SBIT (PERR0, SFR_SCON0, 6);            // UART0 Parity Error Flag
           =4 SBIT (THRE0, SFR_SCON0, 5);            // UART0 Transmit Register Empty Flag
           =4 SBIT (REN0, SFR_SCON0, 4);             // UART0 RX Enable
           =4 SBIT (TBX0, SFR_SCON0, 3);             // UART0 Extra Transmission Bit
           =4 SBIT (RBX0, SFR_SCON0, 2);             // UART0 Extra Receive Bit
           =4 SBIT (TI0, SFR_SCON0, 1);              // UART0 TX Interrupt Flag
           =4 SBIT (RI0, SFR_SCON0, 0);              // UART0 RX Interrupt Flag
           =4 
           =4 // SCON1 0x98
           =4 SBIT (S1MODE, SFR_SCON1, 7);           // UART1 Mode 0
           =4                                        // Bit 6 UNUSED
           =4 SBIT (MCE1, SFR_SCON1, 5);             // UART1 Multiprocessor enable
           =4 SBIT (REN1, SFR_SCON1, 4);             // UART1 RX Enable
           =4 SBIT (TB81, SFR_SCON1, 3);             // UART1 TX Bit 8
           =4 SBIT (RB81, SFR_SCON1, 2);             // UART1 RX Bit 8
           =4 SBIT (TI1, SFR_SCON1, 1);              // UART1 TX Interrupt Flag
           =4 SBIT (RI1, SFR_SCON1, 0);              // UART1 RX Interrupt Flag
           =4 
           =4 // IE 0xA8
           =4 SBIT (EA, SFR_IE, 7);                  // Global Interrupt Enable
           =4 SBIT (ESPI0, SFR_IE, 6);               // SPI0 Interrupt Enable
           =4 SBIT (ET2, SFR_IE, 5);                 // Timer 2 Interrupt Enable
           =4 SBIT (ES0, SFR_IE, 4);                 // UART0 Interrupt Enable
           =4 SBIT (ET1, SFR_IE, 3);                 // Timer 1 Interrupt Enable
           =4 SBIT (EX1, SFR_IE, 2);                 // External Interrupt 1 Enable
           =4 SBIT (ET0, SFR_IE, 1);                 // Timer 0 Interrupt Enable
           =4 SBIT (EX0, SFR_IE, 0);                 // External Interrupt 0 Enable
           =4 
           =4 // IP 0xB8
           =4                                        // Bit 7 unused
           =4 SBIT (PSPI0, SFR_IP, 6);               // SPI0 Interrupt Priority
           =4 SBIT (PT2, SFR_IP, 5);                 // Timer 2 Priority
           =4 SBIT (PS0, SFR_IP, 4);                 // UART0 Priority
           =4 SBIT (PS, SFR_IP, 4);                  // UART0 Priority
           =4 SBIT (PT1, SFR_IP, 3);                 // Timer 1 Priority
           =4 SBIT (PX1, SFR_IP, 2);                 // External Interrupt 1 Priority
           =4 SBIT (PT0, SFR_IP, 1);                 // Timer 0 Priority
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 108 

           =4 SBIT (PX0, SFR_IP, 0);                 // External Interrupt 0 Priority
           =4 
           =4 // SMB0CN 0xC0
           =4 SBIT (MASTER, SFR_SMB0CN, 7);          // SMBus0 Master/Slave Indicator
           =4 SBIT (TXMODE, SFR_SMB0CN, 6);          // SMBus0 Transmit Mode Indicator
           =4 SBIT (STA, SFR_SMB0CN, 5);             // SMBus0 Start Flag
           =4 SBIT (STO, SFR_SMB0CN, 4);             // SMBus0 Stop Flag
           =4 SBIT (ACKRQ, SFR_SMB0CN, 3);           // SMBus0 Acknowledge Request
           =4 SBIT (ARBLOST, SFR_SMB0CN, 2);         // SMBus0 Arbitration Lost Indicator
           =4 SBIT (ACK, SFR_SMB0CN, 1);             // SMBus0 Acknowledge
           =4 SBIT (SI, SFR_SMB0CN, 0);              // SMBus0 Interrupt Flag
           =4 
           =4 // TMR2CN 0xC8
           =4 SBIT (TF2H, SFR_TMR2CN, 7);            // Timer 2 High-Byte Overflow Flag
           =4 SBIT (TF2L, SFR_TMR2CN, 6);            // Timer 2 Low-Byte  Overflow Flag
           =4 SBIT (TF2LEN, SFR_TMR2CN, 5);          // Timer 2 Low-Byte Flag Enable
           =4 SBIT (TF2CEN, SFR_TMR2CN, 4);          // Timer 2 Capture Enable
           =4 SBIT (T2SPLIT, SFR_TMR2CN, 3);         // Timer 2 Split-Mode Enable
           =4 SBIT (TR2, SFR_TMR2CN, 2);             // Timer 2 Run Enable
           =4 SBIT (T2RCLK, SFR_TMR2CN, 1);          // Timer 2 Xclk/Rclk Select
           =4 SBIT (T2XCLK, SFR_TMR2CN, 0);          // Timer 2 Clk/8 Clock Source
           =4 
           =4 // TMR4CN 0xC8
           =4 SBIT (TF4, SFR_TMR4CN, 7);             // Timer 4 Overflow/Underflow Flag
           =4 SBIT (EXF4, SFR_TMR4CN, 6);            // Timer 4 External Flag
           =4                                        // Bit 5 unused
           =4                                        // Bit 4 unused
           =4 SBIT (EXE4, SFR_TMR4CN, 3);            // Timer 4 External Enable
           =4 SBIT (TR4, SFR_TMR4CN, 2);             // Timer 4 Run Enable
           =4 SBIT (CT4, SFR_TMR4CN, 1);             // Timer 4 Counter/Timer Select
           =4 SBIT (CPRL4, SFR_TMR4CN, 0);           // Timer 4 Capture/Reload Select
           =4 
           =4 // PSW 0xD0
           =4 SBIT (CY, SFR_PSW, 7);                 // Carry Flag
           =4 SBIT (AC, SFR_PSW, 6);                 // Auxiliary Carry Flag
           =4 SBIT (F0, SFR_PSW, 5);                 // User Flag 0
           =4 SBIT (RS1, SFR_PSW, 4);                // Register Bank Select 1
           =4 SBIT (RS0, SFR_PSW, 3);                // Register Bank Select 0
           =4 SBIT (OV, SFR_PSW, 2);                 // Overflow Flag
           =4 SBIT (F1, SFR_PSW, 1);                 // User Flag 1
           =4 SBIT (P, SFR_PSW, 0);                  // Accumulator Parity Flag
           =4 
           =4 // PCA0CN 0xD8
           =4 SBIT (CF, SFR_PCA0CN, 7);              // PCA0 Counter Overflow Flag
           =4 SBIT (CR, SFR_PCA0CN, 6);              // PCA0 Counter Run Control Bit
           =4 SBIT (CCF5, SFR_PCA0CN, 5);            // PCA0 Module 5 Interrupt Flag
           =4 SBIT (CCF4, SFR_PCA0CN, 4);            // PCA0 Module 4 Interrupt Flag
           =4 SBIT (CCF3, SFR_PCA0CN, 3);            // PCA0 Module 3 Interrupt Flag
           =4 SBIT (CCF2, SFR_PCA0CN, 2);            // PCA0 Module 2 Interrupt Flag
           =4 SBIT (CCF1, SFR_PCA0CN, 1);            // PCA0 Module 1 Interrupt Flag
           =4 SBIT (CCF0, SFR_PCA0CN, 0);            // PCA0 Module 0 Interrupt Flag
           =4 
           =4 // PCA1CN 0xD8
           =4 SBIT (CF1, SFR_PCA1CN, 7);             // PCA1 Counter Overflow Flag
           =4 SBIT (CR1, SFR_PCA1CN, 6);             // PCA1 Counter Run Control Bit
           =4 SBIT (CCF11, SFR_PCA1CN, 5);           // PCA1 Module 11 Interrupt Flag
           =4 SBIT (CCF10, SFR_PCA1CN, 4);           // PCA1 Module 10 Interrupt Flag
           =4 SBIT (CCF9, SFR_PCA1CN, 3);            // PCA1 Module 9 Interrupt Flag
           =4 SBIT (CCF8, SFR_PCA1CN, 2);            // PCA1 Module 8 Interrupt Flag
           =4 SBIT (CCF7, SFR_PCA1CN, 1);            // PCA1 Module 7 Interrupt Flag
           =4 SBIT (CCF6, SFR_PCA1CN, 0);            // PCA1 Module 6 Interrupt Flag
           =4 
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 109 

           =4 // ADC0CN 0xE8
           =4 SBIT (AD0EN, SFR_ADC0CN, 7);           // ADC0 Enable
           =4 SBIT (BURSTEN, SFR_ADC0CN, 6);         // ADC0 Burst Enable
           =4 SBIT (AD0INT, SFR_ADC0CN, 5);          // ADC0 EOC Interrupt Flag
           =4 SBIT (AD0BUSY, SFR_ADC0CN, 4);         // ADC0 Busy Flag
           =4 SBIT (AD0WINT, SFR_ADC0CN, 3);         // ADC0 Window Compare Interrupt Flag
           =4 SBIT (AD0LJST, SFR_ADC0CN, 2);         // ADC0 Left Justified
           =4 SBIT (AD0CM1, SFR_ADC0CN, 1);          // ADC0 Start Of Conversion Mode Bit 1
           =4 SBIT (AD0CM0, SFR_ADC0CN, 0);          // ADC0 Start Of Conversion Mode Bit 0
           =4 
           =4 // SPI0CN 0xF8
           =4 SBIT (SPIF, SFR_SPI0CN, 7);            // SPI0 Interrupt Flag
           =4 SBIT (WCOL, SFR_SPI0CN, 6);            // SPI0 Write Collision Flag
           =4 SBIT (MODF, SFR_SPI0CN, 5);            // SPI0 Mode Fault Flag
           =4 SBIT (RXOVRN, SFR_SPI0CN, 4);          // SPI0 RX Overrun Flag
           =4 SBIT (NSSMD1, SFR_SPI0CN, 3);          // SPI0 Slave Select Mode 1
           =4 SBIT (NSSMD0, SFR_SPI0CN, 2);          // SPI0 Slave Select Mode 0
           =4 SBIT (TXBMT, SFR_SPI0CN, 1);           // SPI0 TX Buffer Empty Flag
           =4 SBIT (SPIEN, SFR_SPI0CN, 0);           // SPI0 Enable
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Interrupt Priorities
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 #define INTERRUPT_INT0             0   // External Interrupt 0
           =4 #define INTERRUPT_TIMER0           1   // Timer 0 Overflow
           =4 #define INTERRUPT_INT1             2   // External Interrupt 1
           =4 #define INTERRUPT_TIMER1           3   // Timer 1 Overflow
           =4 #define INTERRUPT_UART0            4   // UART0
           =4 #define INTERRUPT_TIMER2           5   // Timer 2 Overflow
           =4 #define INTERRUPT_SPI0             6   // SPI0
           =4 #define INTERRUPT_SMBUS0           7   // SMBus0 Interface
           =4 #define INTERRUPT_ADC0_WINDOW      8   // ADC0 Window Comparison
           =4 #define INTERRUPT_ADC0_EOC         9   // ADC0 End Of Conversion
           =4 #define INTERRUPT_PCA0            10   // PCA0 Peripheral
           =4 #define INTERRUPT_COMPARATOR0     11   // Comparator 0 Comparison
           =4 #define INTERRUPT_COMPARATOR1     12   // Comparator 1 Comparison
           =4 #define INTERRUPT_TIMER3          13   // Timer 3 Overflow
           =4 #define INTERRUPT_LIN0            14   // LIN Bus Interrupt
           =4 #define INTERRUPT_VREG            15   // Voltage Regulator
           =4 #define INTERRUPT_CAN0            16   // CAN Bus Interrupt
           =4 #define INTERRUPT_PORT_MATCH      17   // Port Match
           =4 #define INTERRUPT_UART1           18   // UART1
           =4 #define INTERRUPT_PCA1            19   // PCA1 Peripheral
           =4 #define INTERRUPT_COMPARATOR2     20   // Comparator 2 Comparison
           =4 #define INTERRUPT_TIMER4          21   // Timer 4 Overflow
           =4 #define INTERRUPT_TIMER5          22   // Timer 5 Overflow
           =4 
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // SFR Page Definitions
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 #define  CONFIG_PAGE       0x0F        // System and Port Configuration Page
           =4 #define  ACTIVE_PAGE       0x00        // Active Use Page
           =4 #define  ACTIVE2_PAGE      0x10        // Active Use Page 2
           =4 #define  CAN0_PAGE         0x0C        // CAN0 Registers
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // SDCC PDATA External Memory Paging Support
           =4 //-----------------------------------------------------------------------------
           =4 
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 110 

           =4 #if defined SDCC
           =4 
           =4 SFR(_XPAGE, 0xAA); // Point to the EMI0CN register
           =4 
           =4 #endif
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Header File PreProcessor Directive
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 #endif                                 // #define C8051F580_DEFS_H
 607      =4  
 608      =4  //-----------------------------------------------------------------------------
 609      =4  // End Of File
 610      =4  //-----------------------------------------------------------------------------
  11      =3  
  12      =3  #define MAX_TASK 4U
  13      =3  
  14      =3  #define TASK_RUNNING_STATE      0
  15      =3  #define TASK_BLOCKED_STATE      1
  16      =3  #define TASK_READY_STATE        2
  17      =3  
  18      =3  #endif
  10      =2  #include "Os_task.h"
   1      =3  /*
   2      =3   *  Created on: Apr 21, 2025
   3      =3   *      Author: Hoangtd2000
   4      =3   */
   5      =3  #ifndef _OS_TASK_H_
   6      =3  #define _OS_TASK_H_
   7      =3  #include "Service.h"
   1      =4  /*
   2      =4   *  Created on: Apr 21, 2025
   3      =4   *      Author: Hoangtd2000
   4      =4   */
   5      =4  #ifndef _SERVICE_H_
           =4 #define _SERVICE_H_
           =4 #include "Dio.h"
           =4 #include "GPT.h"
           =4 #include "Dio.h"
           =4 #include "Timer.h"
           =4 #include "Uart.h"
           =4 
           =4 void MCU_init(void);
           =4 void Polling(void);
           =4 #endif
   8      =3  #include "Os_config.h"
   1      =4  /*
   2      =4   *  Created on: Apr 21, 2025
   3      =4   *      Author: Hoangtd2000
   4      =4   */
   5      =4  #ifndef _OS_CONFIG_H_
           =4 #define _OS_CONFIG_H_
           =4 #include <stdio.h>
           =4 #include "Service.h"
           =4 #include <compiler_defs.h>
           =4 #include <C8051F580_defs.h> // SFR declarations
           =4 
           =4 #define MAX_TASK 4U
           =4 
           =4 #define TASK_RUNNING_STATE      0
           =4 #define TASK_BLOCKED_STATE      1
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 111 

           =4 #define TASK_READY_STATE        2
           =4 
           =4 #endif
   9      =3  
  10      =3  typedef struct{
  11      =3          U32 block_count;
  12      =3          U8 current_state;
  13      =3          void (*task_handler)(void);
  14      =3  } TCB_t;
  15      =3  
  16      =3  void Create_task(U8 id , void(*task_handler)(void));
  17      =3  void Unblock_task(void);
  18      =3  void Os_delay(U32 time);
  19      =3  #endif
  11      =2  void Os_scheduler(void);
  12      =2  
  13      =2  #endif
   9      =1  #include "Os_config.h"
   1      =2  /*
   2      =2   *  Created on: Apr 21, 2025
   3      =2   *      Author: Hoangtd2000
   4      =2   */
   5      =2  #ifndef _OS_CONFIG_H_
           =2 #define _OS_CONFIG_H_
           =2 #include <stdio.h>
           =2 #include "Service.h"
           =2 #include <compiler_defs.h>
           =2 #include <C8051F580_defs.h> // SFR declarations
           =2 
           =2 #define MAX_TASK 4U
           =2 
           =2 #define TASK_RUNNING_STATE      0
           =2 #define TASK_BLOCKED_STATE      1
           =2 #define TASK_READY_STATE        2
           =2 
           =2 #endif
  10      =1  #include "Os_task.h"
   1      =2  /*
   2      =2   *  Created on: Apr 21, 2025
   3      =2   *      Author: Hoangtd2000
   4      =2   */
   5      =2  #ifndef _OS_TASK_H_
           =2 #define _OS_TASK_H_
           =2 #include "Service.h"
           =2 #include "Os_config.h"
           =2 
           =2 typedef struct{
           =2         U32 block_count;
           =2         U8 current_state;
           =2         void (*task_handler)(void);
           =2 } TCB_t;
           =2 
           =2 void Create_task(U8 id , void(*task_handler)(void));
           =2 void Unblock_task(void);
           =2 void Os_delay(U32 time);
           =2 #endif
  11      =1  #include "Service.h"
   1      =2  /*
   2      =2   *  Created on: Apr 21, 2025
   3      =2   *      Author: Hoangtd2000
   4      =2   */
   5      =2  #ifndef _SERVICE_H_
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 112 

           =2 #define _SERVICE_H_
           =2 #include "Dio.h"
           =2 #include "GPT.h"
           =2 #include "Dio.h"
           =2 #include "Timer.h"
           =2 #include "Uart.h"
           =2 
           =2 void MCU_init(void);
           =2 void Polling(void);
           =2 #endif
  12      =1  #include <compiler_defs.h>
   1      =2  //-----------------------------------------------------------------------------
   2      =2  // compiler_defs.h
   3      =2  //-----------------------------------------------------------------------------
   4      =2  // Portions of this file are copyright Maarten Brock
   5      =2  // http://sdcc.sourceforge.net
   6      =2  // Portions of this file are copyright 2010, Silicon Laboratories, Inc.
   7      =2  // http://www.silabs.com
   8      =2  //
   9      =2  // GNU LGPL boilerplate:
  10      =2  /** This library is free software; you can redistribute it and/or
  11      =2    * modify it under the terms of the GNU Lesser General Public
  12      =2    * License as published by the Free Software Foundation; either
  13      =2    * version 2.1 of the License, or (at your option) any later version.
  14      =2    *
  15      =2    * This library is distributed in the hope that it will be useful,
  16      =2    * but WITHOUT ANY WARRANTY; without even the implied warranty of
  17      =2    * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  18      =2    * Lesser General Public License for more details.
  19      =2    *
  20      =2    * You should have received a copy of the GNU Lesser General Public
  21      =2    * License along with this library; if not, write to the Free Software
  22      =2    * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  23      =2    *
  24      =2    * In other words, you are welcome to use, share and improve this program.
  25      =2    * You are forbidden to forbid anyone else to use, share and improve
  26      =2    * what you give them. Help stamp out software-hoarding!
  27      =2  **/
  28      =2  // Program Description:
  29      =2  //
  30      =2  // **Important Note**: This header file should be included before including
  31      =2  // a device-specific header file such as C8051F300_defs.h.
  32      =2  //
  33      =2  // Macro definitions to accomodate 8051 compiler differences in specifying
  34      =2  // special function registers and other 8051-specific features such as NOP
  35      =2  // generation, and locating variables in memory-specific segments.  The
  36      =2  // compilers are identified by their unique predefined macros. See also:
  37      =2  // http://predef.sourceforge.net/precomp.html
  38      =2  //
  39      =2  // SBIT and SFR define special bit and special function registers at the given
  40      =2  // address. SFR16 and SFR32 define sfr combinations at adjacent addresses in
  41      =2  // little-endian format. SFR16E and SFR32E define sfr combinations without
  42      =2  // prerequisite byte order or adjacency. None of these multi-byte sfr
  43      =2  // combinations will guarantee the order in which they are accessed when read
  44      =2  // or written.
  45      =2  //
  46      =2  // SFR16X and SFR32X for 16 bit and 32 bit xdata registers are not defined
  47      =2  // to avoid portability issues because of compiler endianness.
  48      =2  //
  49      =2  // Example:
  50      =2  // // my_mcu.c: main 'c' file for my mcu
  51      =2  // #include <compiler_defs.h>  // this file
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 113 

  52      =2  // #include <C8051xxxx_defs.h> // SFR definitions for specific MCU target
  53      =2  //
  54      =2  // SBIT  (P0_1, 0x80, 1);      // Port 0 pin 1
  55      =2  // SFR   (P0, 0x80);           // Port 0
  56      =2  // SFRX  (CPUCS, 0xE600);      // Cypress FX2 Control and Status register in
  57      =2  //                             // xdata memory at 0xE600
  58      =2  // SFR16 (TMR2, 0xCC);         // Timer 2, lsb at 0xCC, msb at 0xCD
  59      =2  // SFR16E(TMR0, 0x8C8A);       // Timer 0, lsb at 0x8A, msb at 0x8C
  60      =2  // SFR32 (MAC0ACC, 0x93);      // SiLabs C8051F120 32 bits MAC0 Accumulator,
  61      =2  //                             // lsb at 0x93, msb at 0x96
  62      =2  // SFR32E(SUMR, 0xE5E4E3E2);   // TI MSC1210 SUMR 32 bits Summation register,
  63      =2  //                             // lsb at 0xE2, msb at 0xE5
  64      =2  //
  65      =2  // Target:         C8051xxxx
  66      =2  // Tool chain:     Generic
  67      =2  // Command Line:   None
  68      =2  // 
  69      =2  // Release 2.6 - 14 DEC 2012 (GO)
  70      =2  //        -Added define for deprecated SDCC keyword 'at'
  71      =2  // Release 2.5 - 12 SEP 2012 (TP)
  72      =2  //    -Added defines for deprecated SDCC keywords bit and code
  73      =2  // Release 2.4 - 27 AUG 2012 (TP)
  74      =2  //    -Added defines for deprecated SDCC keywords interrupt, _asm, and _endasm
  75      =2  // Release 2.3 - 27 MAY 2010 (DM)
  76      =2  //    -Removed 'LOCATED_VARIABLE' pragma from Keil because it is not supported
  77      =2  // Release 2.2 - 06 APR 2010 (ES)
  78      =2  //    -Removed 'PATHINCLUDE' pragma from Raisonance section
  79      =2  // Release 2.1 - 16 JUL 2009 (ES)
  80      =2  //    -Added SEGMENT_POINTER macro definitions for SDCC, Keil, and Raisonance
  81      =2  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for Raisonance
  82      =2  // Release 2.0 - 19 MAY 2009 (ES)
  83      =2  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for SDCC and Keil
  84      =2  // Release 1.9 - 23 OCT 2008 (ES)
  85      =2  //    -Updated Hi-Tech INTERRUPT and INTERRUPT_USING macro definitions
  86      =2  //    -Added SFR16 macro defintion for Hi-Tech
  87      =2  // Release 1.8 - 31 JUL 2008 (ES)
  88      =2  //    -Added INTERRUPT_USING and FUNCTION_USING macro's
  89      =2  //    -Added macro's for IAR
  90      =2  //    -Corrected Union definitions for Hi-Tech and added SFR16 macro defintion
  91      =2  // Release 1.7 - 11 SEP 2007 (BW)
  92      =2  //    -Added support for Raisonance EVAL 03.03.42 and Tasking Eval 7.2r1
  93      =2  // Release 1.6 - 27 AUG 2007 (BW)
  94      =2  //    -Updated copyright notice per agreement with Maartin Brock
  95      =2  //    -Added SDCC 2.7.0 "compiler.h" bug fixes
  96      =2  //    -Added memory segment defines (SEG_XDATA, for example)
  97      =2  // Release 1.5 - 24 AUG 2007 (BW)
  98      =2  //    -Added support for NOP () macro
  99      =2  //    -Added support for Hi-Tech ver 9.01
 100      =2  // Release 1.4 - 07 AUG 2007 (PKC)
 101      =2  //    -Removed FID and fixed formatting.
 102      =2  // Release 1.3 - 30 SEP 2007 (TP)
 103      =2  //    -Added INTERRUPT_PROTO_USING to properly support ISR context switching
 104      =2  //     under SDCC.
 105      =2  // Release 1.2 - (BW)
 106      =2  //    -Added support for U8,U16,U32,S8,S16,S32,UU16,UU32 data types
 107      =2  // Release 1.1 - (BW)
 108      =2  //    -Added support for INTERRUPT, INTERRUPT_USING, INTERRUPT_PROTO,
 109      =2  //     SEGMENT_VARIABLE, VARIABLE_SEGMENT_POINTER,
 110      =2  //     SEGMENT_VARIABLE_SEGMENT_POINTER, and LOCATED_VARIABLE
 111      =2  // Release 1.0 - 29 SEP 2006 (PKC)
 112      =2  //    -Initial revision
 113      =2  
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 114 

 114      =2  //-----------------------------------------------------------------------------
 115      =2  // Header File Preprocessor Directive
 116      =2  //-----------------------------------------------------------------------------
 117      =2  
 118      =2  #ifndef COMPILER_DEFS_H
           =2 #define COMPILER_DEFS_H
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // Macro definitions
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // SDCC - Small Device C Compiler
           =2 // http://sdcc.sourceforge.net
           =2 
           =2 #if defined SDCC
           =2 
           =2 #if (SDCC >= 300)
           =2 
           =2 #define interrupt __interrupt
           =2 #define _asm __asm
           =2 #define _endasm __endasm
           =2 #define bit __bit
           =2 #define code __code
           =2 #define at __at
           =2 
           =2 #endif
           =2 
           =2 # define SEG_GENERIC
           =2 # define SEG_FAR   __xdata
           =2 # define SEG_DATA  __data
           =2 # define SEG_NEAR  __data
           =2 # define SEG_IDATA __idata
           =2 # define SEG_XDATA __xdata
           =2 # define SEG_PDATA __pdata
           =2 # define SEG_CODE  __code
           =2 # define SEG_BDATA __bdata
           =2 
           =2 # define SBIT(name, addr, bit)  __sbit  __at(addr+bit)                  name
           =2 # define SFR(name, addr)        __sfr   __at(addr)                      name
           =2 # define SFRX(name, addr)       xdata volatile unsigned char __at(addr) name
           =2 # define SFR16(name, addr)      __sfr16 __at(((addr+1U)<<8) | addr)     name
           =2 # define SFR16E(name, fulladdr) __sfr16 __at(fulladdr)                  name
           =2 # define SFR32(name, addr)      __sfr32 __at(((addr+3UL)<<24) | ((addr+2UL)<<16) | ((addr+1UL)<<8) | addr)
             - name
           =2 # define SFR32E(name, fulladdr) __sfr32 __at(fulladdr)                  name
           =2 
           =2 # define INTERRUPT(name, vector) void name (void) interrupt (vector)
           =2 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =2 # define INTERRUPT_PROTO(name, vector) void name (void) interrupt (vector)
           =2 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =2 
           =2 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using (regnum
             -)
           =2 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter) using (
             -regnum)
           =2 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =2 
           =2 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =2 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =2 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =2 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 115 

           =2 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment at (addr) vartype name = init
           =2 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) locsegment at (addr) vartype name
           =2 
           =2 // used with UU16
           =2 # define LSB 0
           =2 # define MSB 1
           =2 
           =2 // used with UU32 (b0 is least-significant byte)
           =2 # define b0 0
           =2 # define b1 1
           =2 # define b2 2
           =2 # define b3 3
           =2 
           =2 typedef unsigned char U8;
           =2 typedef unsigned int U16;
           =2 typedef unsigned long U32;
           =2 
           =2 typedef signed char S8;
           =2 typedef signed int S16;
           =2 typedef signed long S32;
           =2 
           =2 typedef union UU16
           =2 {
           =2    U16 U16;
           =2    S16 S16;
           =2    U8 U8[2];
           =2    S8 S8[2];
           =2 } UU16;
           =2 
           =2 typedef union UU32
           =2 {
           =2    U32 U32;
           =2    S32 S32;
           =2    UU16 UU16[2];
           =2    U16 U16[2];
           =2    S16 S16[2];
           =2    U8 U8[4];
           =2    S8 S8[4];
           =2 } UU32;
           =2 
           =2 // NOP () macro support
           =2 #define NOP() _asm NOP _endasm
           =2 
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // Raisonance (must be placed before Keil C51)
           =2 // http://www.raisonance.com
           =2 
           =2 #elif defined __RC51__
           =2 
           =2 //#error Raisonance C51 detected.
           =2 
           =2 # define SEG_GENERIC generic     //SEG_GENERIC only applies to pointers in Raisonance, not variables.
           =2 # define SEG_FAR   xdata
           =2 # define SEG_DATA  data
           =2 # define SEG_NEAR  data
           =2 # define SEG_IDATA idata
           =2 # define SEG_XDATA xdata
           =2 # define SEG_PDATA pdata
           =2 # define SEG_CODE  code
           =2 # define SEG_BDATA bdata
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 116 

           =2 
           =2 # define SBIT(name, addr, bit)  at (addr+bit) sbit         name
           =2 # define SFR(name, addr)        sfr at addr                name
           =2 # define SFR16(name, addr)      sfr16 at addr              name
           =2 # define SFR16E(name, fulladdr) /* not supported */
           =2 # define SFR32(name, fulladdr)  /* not supported */
           =2 # define SFR32E(name, fulladdr) /* not supported */
           =2 
           =2 # define INTERRUPT(name, vector) void name (void) interrupt vector
           =2 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =2 # define INTERRUPT_PROTO(name, vector) void name (void)
           =2 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =2 
           =2 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
           =2 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =2 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =2 
           =2 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =2 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =2 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =2 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =2 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) at addr locsegment vartype name
           =2 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) at addr locsegment vartype name
           =2 
           =2 
           =2 // used with UU16
           =2 # define LSB 1
           =2 # define MSB 0
           =2 
           =2 // used with UU32 (b0 is least-significant byte)
           =2 # define b0 3
           =2 # define b1 2
           =2 # define b2 1
           =2 # define b3 0
           =2 
           =2 typedef unsigned char U8;
           =2 typedef unsigned int U16;
           =2 typedef unsigned long U32;
           =2 
           =2 typedef signed char S8;
           =2 typedef signed int S16;
           =2 typedef signed long S32;
           =2 
           =2 typedef union UU16
           =2 {
           =2    U16 U16;
           =2    S16 S16;
           =2    U8 U8[2];
           =2    S8 S8[2];
           =2 } UU16;
           =2 
           =2 typedef union UU32
           =2 {
           =2    U32 U32;
           =2    S32 S32;
           =2    UU16 UU16[2];
           =2    U16 U16[2];
           =2    S16 S16[2];
           =2    U8 U8[4];
           =2    S8 S8[4];
           =2 } UU32;
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 117 

           =2 
           =2 // NOP () macro support -- NOP is opcode 0x00
           =2 #define NOP() asm { 0x00 }
           =2 
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 
           =2 // Keil C51
           =2 // http://www.keil.com
           =2 
           =2 #elif defined __C51__
           =2 
           =2 //#error Keil C51 detected.
           =2 
           =2 # define SEG_GENERIC
           =2 # define SEG_FAR   xdata
           =2 # define SEG_DATA  data
           =2 # define SEG_NEAR  data
           =2 # define SEG_IDATA idata
           =2 # define SEG_XDATA xdata
           =2 # define SEG_PDATA pdata
           =2 # define SEG_CODE  code
           =2 # define SEG_BDATA bdata
           =2 
           =2 # define SBIT(name, addr, bit)  sbit  name = addr^bit
           =2 # define SFR(name, addr)        sfr   name = addr
           =2 # define SFR16(name, addr)      sfr16 name = addr
           =2 # define SFR16E(name, fulladdr) /* not supported */
           =2 # define SFR32(name, fulladdr)  /* not supported */
           =2 # define SFR32E(name, fulladdr) /* not supported */
           =2 
           =2 # define INTERRUPT(name, vector) void name (void) interrupt vector
           =2 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =2 # define INTERRUPT_PROTO(name, vector) void name (void)
           =2 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =2 
           =2 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
           =2 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =2 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =2 
           =2 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =2 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =2 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =2 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =2 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) vartype locsegment name _at_ addr
           =2 
           =2 // used with UU16
           =2 # define LSB 1
           =2 # define MSB 0
           =2 
           =2 // used with UU32 (b0 is least-significant byte)
           =2 # define b0 3
           =2 # define b1 2
           =2 # define b2 1
           =2 # define b3 0
           =2 
           =2 typedef unsigned char U8;
           =2 typedef unsigned int U16;
           =2 typedef unsigned long U32;
           =2 
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 118 

           =2 typedef signed char S8;
           =2 typedef signed int S16;
           =2 typedef signed long S32;
           =2 
           =2 typedef union UU16
           =2 {
           =2    U16 U16;
           =2    S16 S16;
           =2    U8 U8[2];
           =2    S8 S8[2];
           =2 } UU16;
           =2 
           =2 typedef union UU32
           =2 {
           =2    U32 U32;
           =2    S32 S32;
           =2    UU16 UU16[2];
           =2    U16 U16[2];
           =2    S16 S16[2];
           =2    U8 U8[4];
           =2    S8 S8[4];
           =2 } UU32;
           =2 
           =2 // NOP () macro support
           =2 extern void _nop_ (void);
           =2 #define NOP() _nop_()
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // Hi-Tech 8051
           =2 // http://www.htsoft.com
           =2 
           =2 #elif defined HI_TECH_C
           =2 
           =2 # define SEG_GENERIC
           =2 # define SEG_FAR   far
           =2 # define SEG_DATA  data
           =2 # define SEG_NEAR  near
           =2 # define SEG_IDATA idata
           =2 # define SEG_XDATA xdata
           =2 # define SEG_PDATA pdata
           =2 # define SEG_CODE  code
           =2 # define SEG_BDATA bdata
           =2 
           =2 
           =2 # define SBIT(name, addr, thebit) static volatile bit name @ (addr + thebit)
           =2 # define SFR(name, addr)          static volatile unsigned char name @ addr
           =2 # define SFR16(name, addr)        static volatile unsigned int name @ addr
           =2 # define SFR16E(name, fulladdr) /* not supported */
           =2 # define SFR32(name, fulladdr)  /* not supported */
           =2 # define SFR32E(name, fulladdr) /* not supported */
           =2 
           =2 # define INTERRUPT(name, vector)       void name (void) interrupt vector
           =2 # define INTERRUPT_PROTO(name, vector)
           =2 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =2 # define INTERRUPT_PROTO_USING(name, vector, regnum)
           =2 
           =2 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =2 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =2 // Note: Hi-Tech does not support functions using different register banks. Register
           =2 //       banks can only be specified in interrupts. If a function is called from
           =2 //       inside an interrupt, it will use the same register bank as the interrupt.
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 119 

           =2 
           =2 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =2 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =2 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =2 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment vartype name @ addr
           =2 
           =2 // used with UU16
           =2 # define LSB 0
           =2 # define MSB 1
           =2 
           =2 // used with UU32 (b0 is least-significant byte)
           =2 # define b0 0
           =2 # define b1 1
           =2 # define b2 2
           =2 # define b3 3
           =2 
           =2 typedef unsigned char U8;
           =2 typedef unsigned int U16;
           =2 typedef unsigned long U32;
           =2 
           =2 typedef signed char S8;
           =2 typedef signed int S16;
           =2 typedef signed long S32;
           =2 
           =2 typedef union UU16
           =2 {
           =2    U16 U16;
           =2    S16 S16;
           =2    U8 U8[2];
           =2    S8 S8[2];
           =2 } UU16;
           =2 
           =2 typedef union UU32
           =2 {
           =2    U32 U32;
           =2    S32 S32;
           =2    UU16 UU16[2];
           =2    U16 U16[2];
           =2    S16 S16[2];
           =2    U8 U8[4];
           =2    S8 S8[4];
           =2 } UU32;
           =2 
           =2 // NOP () macro support
           =2 #define NOP() asm(" nop ")
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // Tasking / Altium
           =2 // http://www.altium.com/tasking
           =2 
           =2 
           =2 #elif defined _CC51
           =2 
           =2 # define SEG_GENERIC
           =2 # define SEG_FAR   _xdat
           =2 # define SEG_DATA  _data
           =2 # define SEG_NEAR  _data
           =2 # define SEG_IDATA _idat
           =2 # define SEG_XDATA _xdat
           =2 # define SEG_PDATA _pdat
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 120 

           =2 # define SEG_CODE  _rom
           =2 # define SEG_BDATA _bdat
           =2 
           =2 # define SBIT(name, addr, bit)  _sfrbit  name _at(addr+bit)
           =2 # define SFR(name, addr)        _sfrbyte name _at(addr)
           =2 # define SFRX(name, addr)       _xdat volatile unsigned char name _at(addr)
           =2 #if _CC51 > 71
           =2 # define SFR16(name, addr)      _sfrword _little name _at(addr)
           =2 #else
           =2 # define SFR16(name, addr)      /* not supported */
           =2 #endif
           =2 # define SFR16E(name, fulladdr) /* not supported */
           =2 # define SFR32(name, fulladdr)  /* not supported */
           =2 # define SFR32E(name, fulladdr) /* not supported */
           =2 
           =2 # define INTERRUPT(name, vector) _interrupt (vector) void name (void)
           =2 # define INTERRUPT_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =2 # define INTERRUPT_PROTO(name, vector) _interrupt (vector) void name (void)
           =2 # define INTERRUPT_PROTO_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =2 
           =2 // When calling FUNCTION_USING in Tasking, the function must be called from an interrupt or Main which
           =2 // is also using the same register bank. If not, the compiler will generate an error.
           =2 # define FUNCTION_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (parameter
             -)
           =2 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (par
             -ameter)
           =2 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =2 
           =2 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =2 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =2 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =2 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) vartype locsegment name _at( addr )
           =2 
           =2 // used with UU16
           =2 # define LSB 1
           =2 # define MSB 0
           =2 
           =2 // used with UU32 (b0 is least-significant byte)
           =2 # define b0 3
           =2 # define b1 2
           =2 # define b2 1
           =2 # define b3 0
           =2 
           =2 typedef unsigned char U8;
           =2 typedef unsigned int U16;
           =2 typedef unsigned long U32;
           =2 
           =2 typedef signed char S8;
           =2 typedef signed int S16;
           =2 typedef signed long S32;
           =2 
           =2 typedef union UU16
           =2 {
           =2    U16 U16;
           =2    S16 S16;
           =2    U8 U8[2];
           =2    S8 S8[2];
           =2 } UU16;
           =2 
           =2 typedef union UU32
           =2 {
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 121 

           =2    U32 U32;
           =2    S32 S32;
           =2    UU16 UU16[2];
           =2    U16 U16[2];
           =2    S16 S16[2];
           =2    U8 U8[4];
           =2    S8 S8[4];
           =2 } UU32;
           =2 
           =2 // NOP () macro support
           =2 extern void _nop (void);
           =2 #define NOP() _nop()
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 
           =2 // IAR 8051
           =2 // http://www.iar.com
           =2 
           =2 #elif defined __ICC8051__
           =2 
           =2 #include <stdbool.h>
           =2 #include <intrinsics.h>
           =2 
           =2 # define SBIT(name, addr, bit)  __bit __no_init volatile bool name @ (addr+bit)
           =2 # define SFR(name, addr)        __sfr __no_init volatile unsigned char name @ addr
           =2 # define SFRX(name, addr)       __xdata __no_init volatile unsigned char name @ addr
           =2 # define SFR16(name, addr)      __sfr __no_init volatile unsigned int  name @ addr
           =2 # define SFR16E(name, fulladdr) /* not supported */
           =2 # define SFR32(name, fulladdr) /* not supported */
           =2 # define SFR32E(name, fulladdr) /* not supported */
           =2 
           =2 # define SEG_GENERIC __generic
           =2 # define SEG_FAR  __xdata
           =2 # define SEG_DATA __data
           =2 # define SEG_NEAR __data
           =2 # define SEG_IDATA __idata
           =2 # define SEG_XDATA __xdata
           =2 # define SEG_PDATA __pdata
           =2 # define SEG_CODE  __code
           =2 # define SEG_BDATA __bdata
           =2 
           =2 #define bit bool
           =2 
           =2 # define _PPTOSTR_(x) #x
           =2 # define _PPARAM_(address) _PPTOSTR_(vector=address * 8 + 3)
           =2 # define _PPARAM2_(regbank) _PPTOSTR_(register_bank=regbank)
           =2 # define INTERRUPT(name, vector) _Pragma(_PPARAM_(vector)) __interrupt void name(void)
           =2 # define INTERRUPT_PROTO(name, vector)  __interrupt void name(void)
           =2 # define INTERRUPT_USING(name, vector, regnum) _Pragma(_PPARAM2_(regnum)) _Pragma(_PPARAM_(vector)) __inte
             -rrupt void name(void)
           =2 # define INTERRUPT_PROTO_USING(name, vector, regnum) __interrupt void name(void)
           =2 
           =2 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =2 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =2 // Note: IAR does not support functions using different register banks. Register
           =2 //       banks can only be specified in interrupts. If a function is called from
           =2 //       inside an interrupt, it will use the same register bank as the interrupt.
           =2 
           =2 # define SEGMENT_VARIABLE(name, vartype, locsegment)  locsegment vartype name
           =2 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment  * name
           =2 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 122 

             -csegment name
           =2 
           =2 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment __no_init vartype name @ addr
           =2 
           =2 // used with UU16
           =2 # define LSB 0
           =2 # define MSB 1
           =2 
           =2 // used with UU32 (b0 is least-significant byte)
           =2 # define b0 0
           =2 # define b1 1
           =2 # define b2 2
           =2 # define b3 3
           =2 
           =2 typedef unsigned char U8;
           =2 typedef unsigned int U16;
           =2 typedef unsigned long U32;
           =2 
           =2 typedef signed char S8;
           =2 typedef signed int S16;
           =2 typedef signed long S32;
           =2 
           =2 typedef union UU16
           =2 {
           =2    U16 U16;
           =2    S16 S16;
           =2    U8 U8[2];
           =2    S8 S8[2];
           =2 } UU16;
           =2 
           =2 typedef union UU32
           =2 {
           =2    U32 U32;
           =2    S32 S32;
           =2    UU16 UU16[2];
           =2    U16 U16[2];
           =2    S16 S16[2];
           =2    U8 U8[4];
           =2    S8 S8[4];
           =2 } UU32;
           =2 
           =2 
           =2 #define NOP() __no_operation();
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // Crossware
           =2 // http://www.crossware.com
           =2 
           =2 #elif defined _XC51_VER
           =2 # define SBIT(name, addr, bit)  _sfrbit  name = (addr+bit)
           =2 # define SFR(name, addr)        _sfr     name = addr
           =2 # define SFR16(name, addr)      _sfrword name = addr
           =2 # define SFR16E(name, fulladdr) /* not supported */
           =2 # define SFR32(name, fulladdr)  /* not supported */
           =2 # define SFR32E(name, fulladdr) /* not supported */
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // Wickenhäuser
           =2 // http://www.wickenhaeuser.de
           =2 
           =2 #elif defined __UC__
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 123 

           =2 # define SBIT(name, addr, bit)  unsigned char bit  name @ (addr+bit)
           =2 # define SFR(name, addr)        near unsigned char name @ addr
           =2 # define SFR16(name, addr)      /* not supported */
           =2 # define SFR16E(name, fulladdr) /* not supported */
           =2 # define SFR32(name, fulladdr)  /* not supported */
           =2 # define SFR32E(name, fulladdr) /* not supported */
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // Default
           =2 // Unknown compiler
           =2 
           =2 #else
           =2 # warning unrecognized compiler
           =2 # define SBIT(name, addr, bit)  volatile bool           name
           =2 # define SFR(name, addr)        volatile unsigned char  name
           =2 # define SFRX(name, addr)       volatile unsigned char  name
           =2 # define SFR16(name, addr)      volatile unsigned short name
           =2 # define SFR16E(name, fulladdr) volatile unsigned short name
           =2 # define SFR32(name, fulladdr)  volatile unsigned long  name
           =2 # define SFR32E(name, fulladdr) volatile unsigned long  name
           =2 
           =2 #endif
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // Header File PreProcessor Directive
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 #endif                                 // #define COMPILER_DEFS_H
 689      =2  
 690      =2  //-----------------------------------------------------------------------------
 691      =2  // End Of File
 692      =2  //-----------------------------------------------------------------------------
  13      =1  #include <C8051F580_defs.h> // SFR declarations
   1      =2  //-----------------------------------------------------------------------------
   2      =2  // C8051F580_defs.h
   3      =2  //-----------------------------------------------------------------------------
   4      =2  // Copyright 2008, Silicon Laboratories, Inc.
   5      =2  // http://www.silabs.com
   6      =2  //
   7      =2  // Program Description:
   8      =2  //
   9      =2  // Register/bit definitions for the C8051F58x family.
  10      =2  // **Important Note**: The compiler_defs.h header file should be included
  11      =2  // before including this header file.
  12      =2  //
  13      =2  // Target:         C8051F580/1/2/3/4/5/6/7,8/9-F590/1
  14      =2  // Tool chain:     Generic
  15      =2  // Command Line:   None
  16      =2  //
  17      =2  // Release 0.6 - 20 AUG 2012 (TP)
  18      =2  //    -Added #define for _XPAGE to provide support for SDCC memory paging
  19      =2  //     (pdata)
  20      =2  //
  21      =2  // Release 0.5 - 10 SEP 2011 (GP)
  22      =2  //    - Fixed SFR16 definition for CAN0IF2MC
  23      =2  //
  24      =2  // Release 0.4 - 08 OCT 2010 (TP)
  25      =2  //    - Fixed bit definitions for SCON0
  26      =2  //
  27      =2  // Release 0.3 - 01 APR 2009 (GP)
  28      =2  //    - Added SN0-SN3
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 124 

  29      =2  //
  30      =2  // Release 0.2 - 29 JUL 2008 (ADT)
  31      =2  //    - Added Timer 4 bit definitions
  32      =2  //
  33      =2  // Release 0.1 - 09 JUL 2008 (GP)
  34      =2  //    - Initial Revision
  35      =2  //
  36      =2  //-----------------------------------------------------------------------------
  37      =2  // Header File Preprocessor Directive
  38      =2  //-----------------------------------------------------------------------------
  39      =2  
  40      =2  #ifndef C8051F580_DEFS_H
           =2 #define C8051F580_DEFS_H
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // Page 0, Page 1 and Page F Registers
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 SFR (P0, 0x80);                        // Port 0 Latch
           =2 SFR (SP, 0x81);                        // Stack Pointer
           =2 SFR (DPL, 0x82);                       // Data Pointer Low
           =2 SFR (DPH, 0x83);                       // Data Pointer High
           =2 SFR (SFR0CN, 0x84);                    // SFR Page Control
           =2 SFR (SFRNEXT, 0x85);                   // SFR stack next page
           =2 SFR (SFRLAST, 0x86);                   // SFR stack last page
           =2 SFR (PCON, 0x87);                      // Power Control
           =2 SFR (TCON, 0x88);                      // Timer/Counter Control
           =2 SFR (TMOD, 0x89);                      // Timer/Counter Mode
           =2 SFR (TL0, 0x8A);                       // Timer/Counter 0 Low
           =2 SFR (TL1, 0x8B);                       // Timer/Counter 1 Low
           =2 SFR (TH0, 0x8C);                       // Timer/Counter 0 High
           =2 SFR (TH1, 0x8D);                       // Timer/Counter 1 High
           =2 SFR (CKCON, 0x8E);                     // Clock Control
           =2 SFR (PSCTL, 0x8F);                     // Program Store R/W Control
           =2 SFR (CLKSEL, 0x8F);                    // System clock select
           =2 SFR (P1, 0x90);                        // Port 1 Latch
           =2 SFR (TMR3CN, 0x91);                    // Timer/Counter 3 Control
           =2 SFR (TMR5CN, 0x91);                    // Timer/Counter 5 Control
           =2 SFR (TMR3RLL, 0x92);                   // Timer/Counter 3 Reload Low
           =2 SFR (TMR5CAPL, 0x92);                  // Timer/Counter 5 Capture Low
           =2 SFR (TMR3RLH, 0x93);                   // Timer/Counter 3 Reload High
           =2 SFR (TMR5CAPH, 0x93);                  // Timer/Counter 5 Capture High
           =2 SFR (TMR3L, 0x94);                     // Timer/Counter 3 Low
           =2 SFR (TMR5L, 0x94);                     // Timer/Counter 5 Low
           =2 SFR (TMR3H, 0x95);                     // Timer/Counter 3 High
           =2 SFR (TMR5H, 0x95);                     // Timer/Counter 5 High
           =2 SFR (TMR5CF, 0x96);                    // Timer/Counter 5 Configuration
           =2 SFR (CLKMUL, 0x97);                    // Clock Multiplier
           =2 SFR (SCON0, 0x98);                     // UART0 Control
           =2 SFR (SCON1, 0x98);                     // UART1 Control
           =2 SFR (SBUF0, 0x99);                     // UART0 Data Buffer
           =2 SFR (SBUF1, 0x99);                     // UART1 Data Buffer
           =2 SFR (CPT0CN, 0x9A);                    // Comparator 0 Control
           =2 SFR (CPT2CN, 0x9A);                    // Comparator 2 Control
           =2 SFR (CPT0MD, 0x9B);                    // Comparator 0 Mode
           =2 SFR (CPT2MD, 0x9B);                    // Comparator 2 Mode
           =2 SFR (CPT0MX, 0x9C);                    // Comparator 0 Mux
           =2 SFR (CPT2MX, 0x9C);                    // Comparator 2 Mux
           =2 SFR (CPT1CN, 0x9D);                    // Comparator 1 Control
           =2 SFR (CPT1MD, 0x9E);                    // Comparator 0 Mode
           =2 SFR (OSCIFIN, 0x9E);                   // Internal Oscillator Fine Control
           =2 SFR (CPT1MX, 0x9F);                    // Comparator 1 Mux
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 125 

           =2 SFR (OSCXCN, 0x9F);                    // External Oscillator Control
           =2 SFR (P2, 0xA0);                        // Port 2 Latch
           =2 SFR (SPI0CFG, 0xA1);                   // SPI0 Configuration
           =2 SFR (OSCICN, 0xA1);                    // Internal Oscillator Control
           =2 SFR (SPI0CKR, 0xA2);                   // SPI0 Clock rate control
           =2 SFR (OSCICRS, 0xA2);                   // Internal Oscillator Coarse Control
           =2 SFR (SPI0DAT, 0xA3);                   // SPI0 Data Buffer
           =2 SFR (P0MDOUT, 0xA4);                   // Port 0 Output Mode
           =2 SFR (P1MDOUT, 0xA5);                   // Port 1 Output Mode
           =2 SFR (P2MDOUT, 0xA6);                   // Port 2 Output Mode
           =2 SFR (SFRPAGE, 0xA7);                   // SFR Page Select
           =2 SFR (IE, 0xA8);                        // Interrupt Enable
           =2 SFR (SMOD0, 0xA9);                     // Serial Port 0 Control
           =2 SFR (EMI0CN, 0xAA);                    // EMIF Control
           =2 SFR (EMI0TC, 0xAA);                    // EMIF Timing control
           =2 SFR (SBCON0, 0xAB);                    // UART0 Baud Rate Generator Control
           =2 SFR (SBRLL0, 0xAC);                    // UART0 Baud Rate Generator Low
           =2 SFR (SBRLH0, 0xAD);                    // UART0 Baud Rate Generator High
           =2 SFR (P3MAT, 0xAE);                     // Port 3 Match
           =2 SFR (P3MDOUT, 0xAE);                   // Port 3 Mode
           =2 SFR (P3MASK, 0xAF);                    // Port 3 Mask
           =2 SFR (P4MDOUT, 0xAF);                   // Port 4 Mode
           =2 SFR (P3, 0xB0);                        // Port 3 Latch
           =2 SFR (P2MAT, 0xB1);                     // Port 2 Match
           =2 SFR (P2MASK, 0xB2);                    // Port 2 Mask
           =2 SFR (EMI0CF, 0xB2);                    // EMIF Configuration
           =2 SFR (P4, 0xB5);                        // Port 4 Latch
           =2 SFR (FLSCL, 0xB6);                     // Flash Scale
           =2 SFR (FLKEY, 0xB7);                     // Flash access limit
           =2 SFR (IP, 0xB8);                        // Interrupt Priority
           =2 SFR (SMB0ADR, 0xB9);                   // SMBus0 Slave address
           =2 SFR (ADC0TK, 0xBA);                    // ADC0 Tracking Mode Select
           =2 SFR (SMB0ADM, 0xBA);                   // SMBus0 Address Mask
           =2 SFR (ADC0MX, 0xBB);                    // AMUX0 Channel select
           =2 SFR (ADC0CF, 0xBC);                    // AMUX0 Channel configuration
           =2 SFR (ADC0L, 0xBD);                     // ADC0 Data Low
           =2 SFR (ADC0H, 0xBE);                     // ADC0 Data High
           =2 SFR (SMB0CN, 0xC0);                    // SMBus0 Control
           =2 SFR (SMB0CF, 0xC1);                    // SMBus0 Configuration
           =2 SFR (SMB0DAT, 0xC2);                   // SMBus0 Data
           =2 SFR (ADC0GTL, 0xC3);                   // ADC0 Greater-Than Compare Low
           =2 SFR (ADC0GTH, 0xC4);                   // ADC0 Greater-Than Compare High
           =2 SFR (ADC0LTL, 0xC5);                   // ADC0 Less-Than Compare Word Low
           =2 SFR (ADC0LTH, 0xC6);                   // ADC0 Less-Than Compare Word High
           =2 SFR (XBR3, 0xC6);                      // Port I/O Crossbar Control 3
           =2 SFR (XBR2, 0xC7);                      // Port I/O Crossbar Control 2
           =2 SFR (TMR2CN, 0xC8);                    // Timer/Counter 2 Control
           =2 SFR (TMR4CN, 0xC8);                    // Timer/Counter 4 Control
           =2 SFR (REG0CN, 0xC9);                    // Regulator Control
           =2 SFR (LIN0CF, 0xC9);                    // LIN 0 Configuration
           =2 SFR (TMR4CF, 0xC9);                    // Timer/Counter 4 Configuration
           =2 SFR (TMR2RLL, 0xCA);                   // Timer/Counter 2 Reload Low
           =2 SFR (TMR4CAPL, 0xCA);                  // Timer/Counter 4 Capture Low
           =2 SFR (TMR2RLH, 0xCB);                   // Timer/Counter 2 Reload High
           =2 SFR (TMR4CAPH, 0xCB);                  // Timer/Counter 4 Capture High
           =2 SFR (TMR2L, 0xCC);                     // Timer/Counter 2 Low
           =2 SFR (TMR4L, 0xCC);                     // Timer/Counter 4 Low
           =2 SFR (TMR2H, 0xCD);                     // Timer/Counter 2 High
           =2 SFR (TMR4H, 0xCD);                     // Timer/Counter 4 High
           =2 SFR (PCA0CPL5, 0xCE);                  // PCA0 Capture 5 Low
           =2 SFR (PCA1CPL11, 0xCE);                 // PCA1 Capture 11 Low
           =2 SFR (PCA0CPH5, 0xCF);                  // PCA0 Capture 5 High
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 126 

           =2 SFR (PCA1CPH11, 0xCF);                 // PCA1 Capture 11 High
           =2 SFR (PSW, 0xD0);                       // Program Status Word
           =2 SFR (REF0CN, 0xD1);                    // Voltage Reference Control
           =2 SFR (LIN0DAT, 0xD2);                   // LIN0 Data
           =2 SFR (LIN0ADR, 0xD3);                   // LIN0 Address
           =2 SFR (P0SKIP, 0xD4);                    // Port 0 Skip
           =2 SFR (P1SKIP, 0xD5);                    // Port 1 Skip
           =2 SFR (P2SKIP, 0xD6);                    // Port 2 Skip
           =2 SFR (P3SKIP, 0xD7);                    // Port 3 Skip
           =2 SFR (PCA0CN, 0xD8);                    // PCA0 Control
           =2 SFR (PCA1CN, 0xD8);                    // PCA1 Control
           =2 SFR (PCA0MD, 0xD9);                    // PCA0 Mode
           =2 SFR (PCA1MD, 0xD9);                    // PCA1 Mode
           =2 SFR (PCA0PWM, 0xD9);                   // PCA0 PWM Control
           =2 SFR (PCA0CPM0, 0xDA);                  // PCA0 Module 0 Mode
           =2 SFR (PCA1CPM6, 0xDA);                  // PCA1 Module 6 Mode
           =2 SFR (PCA1PWM, 0xDA);                   // PCA1 PWM Control
           =2 SFR (PCA0CPM1, 0xDB);                  // PCA0 Module 1  Mode
           =2 SFR (PCA1CPM7, 0xDB);                  // PCA1 Module 7  Mode
           =2 SFR (PCA0CPM2, 0xDC);                  // PCA0 Module 2  Mode
           =2 SFR (PCA1CPM8, 0xDC);                  // PCA1 Module 8  Mode
           =2 SFR (PCA0CPM3, 0xDD);                  // PCA0 Module 3  Mode
           =2 SFR (PCA1CPM9, 0xDD);                  // PCA1 Module 9  Mode
           =2 SFR (PCA0CPM4, 0xDE);                  // PCA0 Module 4  Mode
           =2 SFR (PCA1CPM10, 0xDE);                  // PCA1 Module 10 Mode
           =2 SFR (PCA0CPM5, 0xDF);                  // PCA0 Module 5  Mode
           =2 SFR (PCA1CPM11, 0xDF);                  // PCA1 Module 11 Mode
           =2 SFR (ACC, 0xE0);                       // Accumulator
           =2 SFR (XBR0, 0xE1);                      // Port I/O Crossbar Control 0
           =2 SFR (XBR1, 0xE2);                      // Port I/O Crossbar Control 1
           =2 SFR (CCH0CN, 0xE3);                    // Cache control
           =2 SFR (IT01CF, 0xE4);                    // INT0/INT1 Configuration
           =2 SFR (EIE1, 0xE6);                      // Extended Interrupt Enable 2
           =2 SFR (EIE2, 0xE7);                      // Extended Interrupt Enable 2
           =2 SFR (ADC0CN, 0xE8);                    // ADC0 Control
           =2 SFR (PCA0CPL1, 0xE9);                  // PCA0 Capture 1 Low
           =2 SFR (PCA1CPL1, 0xE9);                  // PCA1 Capture 7 Low
           =2 SFR (PCA0CPH1, 0xEA);                  // PCA0 Capture 1 High
           =2 SFR (PCA1CPH1, 0xEA);                  // PCA1 Capture 7 High
           =2 SFR (PCA0CPL2, 0xEB);                  // PCA0 Capture 2 Low
           =2 SFR (PCA1CPL2, 0xEB);                  // PCA1 Capture 8 Low
           =2 SFR (PCA0CPH2, 0xEC);                  // PCA0 Capture 2 High
           =2 SFR (PCA1CPH2, 0xEC);                  // PCA1 Capture 8 High
           =2 SFR (PCA0CPL3, 0xED);                  // PCA0 Capture 3 Low
           =2 SFR (PCA1CPL3, 0xED);                  // PCA1 Capture 9 Low
           =2 SFR (PCA0CPH3, 0xEE);                  // PCA0 Capture 3 High
           =2 SFR (PCA1CPH3, 0xEE);                  // PCA1 Capture 9 High
           =2 SFR (RSTSRC, 0xEF);                    // Reset Source Configuration/Status
           =2 SFR (B, 0xF0);                         // B Register
           =2 SFR (P0MAT, 0xF1);                     // Port 0 Match
           =2 SFR (P0MDIN, 0xF1);                    // Port 0 Input Mode
           =2 SFR (P0MASK, 0xF2);                    // Port 0 Mask
           =2 SFR (P1MDIN, 0xF2);                    // Port 1 Input Mode
           =2 SFR (P1MAT, 0xF3);                     // Port 1 Match
           =2 SFR (P2MDIN, 0xF3);                    // Port 2 Input Mode
           =2 SFR (P1MASK, 0xF4);                    // Port 1 Mask
           =2 SFR (P3MDIN, 0xF4);                    // Port 3 Input Mode
           =2 SFR (PSBANK, 0xF5);                    // Program Space Bank Select
           =2 SFR (EIP1, 0xF6);                      // External Interrupt Priority 1
           =2 SFR (EIP2, 0xF7);                      // External Interrupt Priority 2
           =2 SFR (SPI0CN, 0xF8);                    // SPI0 Control
           =2 SFR (PCA0L, 0xF9);                     // PCA0 Counter Low
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 127 

           =2 SFR (PCA1L, 0xF9);                     // PCA1 Counter Low
           =2 SFR (SN0, 0xF9);                       // Serial Number 0
           =2 SFR (PCA0H, 0xFA);                     // PCA0 Counter High
           =2 SFR (PCA1H, 0xFA);                     // PCA1 Counter High
           =2 SFR (SN1, 0xFA);                       // Serial Number 1
           =2 SFR (PCA0CPL0, 0xFB);                  // PCA0 Capture 0 Low
           =2 SFR (PCA1CPL6, 0xFB);                  // PCA1 Capture 6 Low
           =2 SFR (SN2, 0xFB);                       // Serial Number 2
           =2 SFR (PCA0CPH0, 0xFC);                  // PCA0 Capture 0 High
           =2 SFR (PCA1CPH6, 0xFC);                  // PCA1 Capture 6 High
           =2 SFR (SN3, 0xFC);                       // Serial Number 3
           =2 SFR (PCA0CPL4, 0xFD);                  // PCA0 Capture 4 Low
           =2 SFR (PCA1CPL10, 0xFD);                 // PCA1 Capture 10 Low
           =2 SFR (PCA0CPH4, 0xFE);                  // PCA0 Capture 4 High
           =2 SFR (PCA1CPH10, 0xFE);                 // PCA1 Capture 10 High
           =2 SFR (VDM0CN, 0xFF);                    // VDD Monitor Control
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // Page C (CAN0) Registers
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 SFR (CAN0CFG, 0x92);                   // CAN0 Clock Configuration
           =2 SFR (CAN0STAT, 0x94);                  // Status Register Low Byte
           =2 SFR (CAN0ERRL, 0x96);                  // Error Counter Low Byte
           =2 SFR (CAN0ERRH, 0x97);                  // Error Counter High Byte
           =2 SFR (CAN0BTL, 0x9A);                   // Bit Timing Register Low Byte
           =2 SFR (CAN0BTH, 0x9B);                   // Bit Timing Register High Byte
           =2 SFR (CAN0IIDL, 0x9C);                  // Interrupt Register Low Byte
           =2 SFR (CAN0IIDH, 0x9D);                  // Interrupt Register High Byte
           =2 SFR (CAN0TST, 0x9E);                   // Test Register Low Byte
           =2 SFR (CAN0BRPE, 0xA1);                  // BRP Extension Register Low Byte
           =2 SFR (CAN0TR1L, 0xA2);                  // Transmission Request 1 Low Byte
           =2 SFR (CAN0TR1H, 0xA3);                  // Transmission Request 1 High Byte
           =2 SFR (CAN0TR2L, 0xA4);                  // Transmission Request 2 Low Byte
           =2 SFR (CAN0TR2H, 0xA5);                  // Transmission Request 2 High Byte
           =2 SFR (CAN0ND1L, 0xAA);                  // New Data 1 Low Byte
           =2 SFR (CAN0ND1H, 0xAB);                  // New Data 1 High Byte
           =2 SFR (CAN0ND2L, 0xAC);                  // New Data 2 Low Byte
           =2 SFR (CAN0ND2H, 0xAD);                  // New Data 2 High Byte
           =2 SFR (CAN0IP1L, 0xAE);                  // Interrupt Pending 1 Low Byte
           =2 SFR (CAN0IP1H, 0xAF);                  // Interrupt Pending 1 High Byte
           =2 SFR (CAN0IP2L, 0xB2);                  // Interrupt Pending 2 Low Byte
           =2 SFR (CAN0IP2H, 0xB3);                  // Interrupt Pending 2 High Byte
           =2 SFR (CAN0MV1L, 0xBA);                  // Message Valid 1 Low Byte
           =2 SFR (CAN0MV1H, 0xBB);                  // Message Valid 1 High Byte
           =2 SFR (CAN0MV2L, 0xBC);                  // Message Valid 2 Low Byte
           =2 SFR (CAN0MV2H, 0xBD);                  // Message Valid 2 High Byte
           =2 SFR (CAN0IF1CRL, 0xBE);                // IF1 Command Request Low Byte
           =2 SFR (CAN0IF1CRH, 0xBF);                // IF1 Command Request High Byte
           =2 SFR (CAN0CN, 0xC0);                    // CAN Control Register Low Byte
           =2 SFR (CAN0IF1CML, 0xC2);                // IF1 Command Mask Low Byte
           =2 SFR (CAN0IF1CMH, 0xC3);                // IF1 Command Mask High Byte
           =2 SFR (CAN0IF1M1L, 0xC4);                // IF1 Mask 1 Low Byte
           =2 SFR (CAN0IF1M1H, 0xC5);                // IF1 Mask 1 High Byte
           =2 SFR (CAN0IF1M2L, 0xC6);                // IF1 Mask 2 Low Byte
           =2 SFR (CAN0IF1M2H, 0xC7);                // IF1 Mask 2 High Byte
           =2 SFR (CAN0IF1A1L, 0xCA);                // IF1 Arbitration 1 Low Byte
           =2 SFR (CAN0IF1A1H, 0xCB);                // IF1 Arbitration 1 High Byte
           =2 SFR (CAN0IF1A2L, 0xCC);                // IF1 Arbitration 2 Low Byte
           =2 SFR (CAN0IF1A2H, 0xCD);                // IF1 Arbitration 2 High Byte
           =2 SFR (CAN0IF2MCL, 0xCE);                // IF2 Message Control Low Byte
           =2 SFR (CAN0IF2MCH, 0xCF);                // IF2 Message Control High Byte
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 128 

           =2 SFR (CAN0IF1MCL, 0xD2);                // IF1 Message Control Low Byte
           =2 SFR (CAN0IF1MCH, 0xD3);                // IF1 Message Control High Byte
           =2 SFR (CAN0IF1DA1L, 0xD4);               // IF1 Data A 1 Low Byte
           =2 SFR (CAN0IF1DA1H, 0xD5);               // IF1 Data A 1 High Byte
           =2 SFR (CAN0IF1DA2L, 0xD6);               // IF1 Data A 2 Low Byte
           =2 SFR (CAN0IF1DA2H, 0xD7);               // IF1 Data A 2 High Byte
           =2 SFR (CAN0IF1DB1L, 0xDA);               // IF1 Data B 1 Low Byte
           =2 SFR (CAN0IF1DB1H, 0xDB);               // IF1 Data B 1 High Byte
           =2 SFR (CAN0IF1DB2L, 0xDC);               // IF1 Data B 2 Low Byte
           =2 SFR (CAN0IF1DB2H, 0xDD);               // IF1 Data B 2 High Byte
           =2 SFR (CAN0IF2CRL, 0xDE);                // IF2 Command Request Low Byte
           =2 SFR (CAN0IF2CRH, 0xDF);                // IF2 Command Request High Byte
           =2 SFR (CAN0IF2CML, 0xE2);                // IF2 Command Mask Low Byte
           =2 SFR (CAN0IF2CMH, 0xE3);                // IF2 Command Mask High Byte
           =2 SFR (CAN0IF2M1L, 0xEA);                // IF2 Mask 1 Low Byte
           =2 SFR (CAN0IF2M1H, 0xEB);                // IF2 Mask 1 High Byte
           =2 SFR (CAN0IF2M2L, 0xEC);                // IF2 Mask 2 Low Byte
           =2 SFR (CAN0IF2M2H, 0xED);                // IF2 Mask 2 High Byte
           =2 SFR (CAN0IF2A1L, 0xEE);                // IF2 Arbitration 1 Low Byte
           =2 SFR (CAN0IF2A1H, 0xEF);                // IF2 Arbitration 1 High Byte
           =2 SFR (CAN0IF2A2L, 0xF2);                // IF2 Arbitration 2 Low Byte
           =2 SFR (CAN0IF2A2H, 0xF3);                // IF2 Arbitration 2 High Byte
           =2 SFR (CAN0IF2DA1L, 0xF6);               // IF2 Data A 1 Low Byte
           =2 SFR (CAN0IF2DA1H, 0xF7);               // IF2 Data A 1 High Byte
           =2 SFR (CAN0IF2DA2L, 0xFA);               // IF2 Data A 2 Low Byte
           =2 SFR (CAN0IF2DA2H, 0xFB);               // IF2 Data A 2 High Byte
           =2 SFR (CAN0IF2DB1L, 0xFC);               // IF2 Data B 1 Low Byte
           =2 SFR (CAN0IF2DB1H, 0xFD);               // IF2 Data B 1 High Byte
           =2 SFR (CAN0IF2DB2L, 0xFE);               // IF2 Data B 2 Low Byte
           =2 SFR (CAN0IF2DB2H, 0xFF);               // IF2 Data B 2 High Byte
           =2 
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // 16-bit Register Definitions (might not be supported by all compilers)
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 SFR16 (DP, 0x82);                      // Data Pointer
           =2 SFR16 (TMR3RL, 0x92);                  // Timer 3 Reload
           =2 SFR16 (TMR5CAP, 0x92);                 // Timer 5 Capture
           =2 SFR16 (TMR3, 0x94);                    // Timer 3 Capture / Reload
           =2 SFR16 (TMR5, 0x94);                    // Timer 5
           =2 SFR16 (SBRL0, 0xAC);                   // UART0 Reload
           =2 SFR16 (ADC0, 0xBD);                    // ADC0 data
           =2 SFR16 (ADC0GT, 0xC3);                  // ADC0 Greater Than Window
           =2 SFR16 (ADC0LT, 0xC5);                  // ADC0 Less Than Window
           =2 SFR16 (TMR2RL, 0xCA);                  // Timer 2 Reload
           =2 SFR16 (TMR4CAP, 0xCA);                 // Timer 4 Capture
           =2 SFR16 (TMR2, 0xCC);                    // Timer 2 Capture / Reload
           =2 SFR16 (TMR4, 0xCC);                    // Timer 4
           =2 SFR16 (PCA0CP5, 0xCE);                 // PCA0 Module 5 Capture
           =2 SFR16 (PCA1CP11, 0xCE);                // PCA1 Module 11 Capture
           =2 SFR16 (PCA0CP1, 0xE9);                 // PCA0 Module 1 Capture
           =2 SFR16 (PCA1CP7, 0xE9);                 // PCA1 Module 7 Capture
           =2 SFR16 (PCA0CP2, 0xEB);                 // PCA0 Module 2 Capture
           =2 SFR16 (PCA1CP8, 0xEB);                 // PCA1 Module 8 Capture
           =2 SFR16 (PCA0CP3, 0xED);                 // PCA0 Module 3 Capture
           =2 SFR16 (PCA1CP9, 0xED);                 // PCA1 Module 9 Capture
           =2 SFR16 (PCA0, 0xF9);                    // PCA0 Counter
           =2 SFR16 (PCA1, 0xF9);                    // PCA1 Counter
           =2 SFR16 (PCA0CP0, 0xFB);                 // PCA0 Module 0 Capture
           =2 SFR16 (PCA1CP6, 0xFB);                 // PCA1 Module 6 Capture
           =2 SFR16 (PCA0CP4, 0xFD);                 // PCA0 Module 4 Capture
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 129 

           =2 SFR16 (PCA1CP10, 0xFD);                 // PCA1 Module 10 Capture
           =2 
           =2 SFR16 (CAN0ERR, 0x96);                 // Error Counter
           =2 SFR16 (CAN0BT, 0x9A);                  // Bit Timing Register
           =2 SFR16 (CAN0IID, 0x9C);                 // Interrupt Register
           =2 SFR16 (CAN0TR1, 0xA2);                 // Transmission Request 1
           =2 SFR16 (CAN0TR2, 0xA4);                 // Transmission Request 2
           =2 SFR16 (CAN0ND1, 0xAA);                 // New Data 1
           =2 SFR16 (CAN0ND2, 0xAC);                 // New Data 2
           =2 SFR16 (CAN0IP1, 0xAE);                 // Interrupt Pending 1
           =2 SFR16 (CAN0IP2, 0xB2);                 // Interrupt Pending 2
           =2 SFR16 (CAN0MV1, 0xBA);                 // Message Valid 1
           =2 SFR16 (CAN0MV2, 0xBC);                 // Message Valid 2
           =2 SFR16 (CAN0IF1CR, 0xBE);               // IF1 Command Request
           =2 SFR16 (CAN0IF1CM, 0xC2);               // IF1 Command Mask
           =2 SFR16 (CAN0IF1M1, 0xC4);               // IF1 Mask 1
           =2 SFR16 (CAN0IF1M2, 0xC6);               // IF1 Mask 2
           =2 SFR16 (CAN0IF1A1, 0xCA);               // IF1 Arbitration 1
           =2 SFR16 (CAN0IF1A2, 0xCC);               // IF1 Arbitration 2
           =2 SFR16 (CAN0IF1MC, 0xD2);               // IF1 Message Control
           =2 SFR16 (CAN0IF1DA1, 0xD4);              // IF1 Data A 1
           =2 SFR16 (CAN0IF1DA2, 0xD6);              // IF1 Data A 2
           =2 SFR16 (CAN0IF1DB1, 0xDA);              // IF1 Data B 1
           =2 SFR16 (CAN0IF1DB2, 0xDC);              // IF1 Data B 2
           =2 SFR16 (CAN0IF2CR, 0xDE);               // IF2 Command Request
           =2 SFR16 (CAN0IF2CM, 0xE2);               // IF2 Command Mask
           =2 SFR16 (CAN0IF2M1, 0xEA);               // IF2 Mask 1
           =2 SFR16 (CAN0IF2M2, 0xEC);               // IF2 Mask 2
           =2 SFR16 (CAN0IF2A1, 0xEE);               // IF2 Arbitration 1
           =2 SFR16 (CAN0IF2A2, 0xF2);               // IF2 Arbitration 2
           =2 SFR16 (CAN0IF2MC, 0xCE);               // IF2 Message Control
           =2 SFR16 (CAN0IF2DA1, 0xF6);              // IF2 Data A 1
           =2 SFR16 (CAN0IF2DA2, 0xFA);              // IF2 Data A 2
           =2 SFR16 (CAN0IF2DB1, 0xFC);              // IF2 Data B 1
           =2 SFR16 (CAN0IF2DB2, 0xFE);              // IF2 Data B 2
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // LIN0 Indirect Registers
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 #define  LIN0DT1   0x00                // LIN0 Data Byte 1
           =2 #define  LIN0DT2   0x01                // LIN0 Data Byte 2
           =2 #define  LIN0DT3   0x02                // LIN0 Data Byte 3
           =2 #define  LIN0DT4   0x03                // LIN0 Data Byte 4
           =2 #define  LIN0DT5   0x04                // LIN0 Data Byte 5
           =2 #define  LIN0DT6   0x05                // LIN0 Data Byte 6
           =2 #define  LIN0DT7   0x06                // LIN0 Data Byte 7
           =2 #define  LIN0DT8   0x07                // LIN0 Data Byte 8
           =2 #define  LIN0CTRL  0x08                // LIN0 Control
           =2 #define  LIN0ST    0x09                // LIN0 Status
           =2 #define  LIN0ERR   0x0A                // LIN0 Error
           =2 #define  LIN0SIZE  0x0B                // LIN0 Message Size
           =2 #define  LIN0DIV   0x0C                // LIN0 Divider
           =2 #define  LIN0MUL   0x0D                // LIN0 Multiplier
           =2 #define  LIN0ID    0x0E                // LIN0 Identifier
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // Address Definitions for Bit-addressable Registers
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 #define SFR_P0       0x80
           =2 #define SFR_TCON     0x88
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 130 

           =2 #define SFR_P1       0x90
           =2 #define SFR_SCON0    0x98
           =2 #define SFR_SCON1    0x98
           =2 #define SFR_P2       0xA0
           =2 #define SFR_IE       0xA8
           =2 #define SFR_P3       0xB0
           =2 #define SFR_IP       0xB8
           =2 #define SFR_SMB0CN   0xC0
           =2 #define SFR_TMR2CN   0xC8
           =2 #define SFR_TMR4CN   0xC8
           =2 #define SFR_PSW      0xD0
           =2 #define SFR_PCA0CN   0xD8
           =2 #define SFR_PCA1CN   0xD8
           =2 #define SFR_ACC      0xE0
           =2 #define SFR_ADC0CN   0xE8
           =2 #define SFR_B        0xF0
           =2 #define SFR_SPI0CN   0xF8
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // Bit Definitions
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // TCON 0x88
           =2 SBIT (TF1, SFR_TCON, 7);               // Timer 1 Overflow Flag
           =2 SBIT (TR1, SFR_TCON, 6);               // Timer 1 On/Off Control
           =2 SBIT (TF0, SFR_TCON, 5);               // Timer 0 Overflow Flag
           =2 SBIT (TR0, SFR_TCON, 4);               // Timer 0 On/Off Control
           =2 SBIT (IE1, SFR_TCON, 3);               // Ext. Interrupt 1 Edge Flag
           =2 SBIT (IT1, SFR_TCON, 2);               // Ext. Interrupt 1 Type
           =2 SBIT (IE0, SFR_TCON, 1);               // Ext. Interrupt 0 Edge Flag
           =2 SBIT (IT0, SFR_TCON, 0);               // Ext. Interrupt 0 Type
           =2 
           =2 // SCON0 0x98
           =2 SBIT (OVR0, SFR_SCON0, 7);             // UART0 Receive FIFO Overrun Flag
           =2 SBIT (PERR0, SFR_SCON0, 6);            // UART0 Parity Error Flag
           =2 SBIT (THRE0, SFR_SCON0, 5);            // UART0 Transmit Register Empty Flag
           =2 SBIT (REN0, SFR_SCON0, 4);             // UART0 RX Enable
           =2 SBIT (TBX0, SFR_SCON0, 3);             // UART0 Extra Transmission Bit
           =2 SBIT (RBX0, SFR_SCON0, 2);             // UART0 Extra Receive Bit
           =2 SBIT (TI0, SFR_SCON0, 1);              // UART0 TX Interrupt Flag
           =2 SBIT (RI0, SFR_SCON0, 0);              // UART0 RX Interrupt Flag
           =2 
           =2 // SCON1 0x98
           =2 SBIT (S1MODE, SFR_SCON1, 7);           // UART1 Mode 0
           =2                                        // Bit 6 UNUSED
           =2 SBIT (MCE1, SFR_SCON1, 5);             // UART1 Multiprocessor enable
           =2 SBIT (REN1, SFR_SCON1, 4);             // UART1 RX Enable
           =2 SBIT (TB81, SFR_SCON1, 3);             // UART1 TX Bit 8
           =2 SBIT (RB81, SFR_SCON1, 2);             // UART1 RX Bit 8
           =2 SBIT (TI1, SFR_SCON1, 1);              // UART1 TX Interrupt Flag
           =2 SBIT (RI1, SFR_SCON1, 0);              // UART1 RX Interrupt Flag
           =2 
           =2 // IE 0xA8
           =2 SBIT (EA, SFR_IE, 7);                  // Global Interrupt Enable
           =2 SBIT (ESPI0, SFR_IE, 6);               // SPI0 Interrupt Enable
           =2 SBIT (ET2, SFR_IE, 5);                 // Timer 2 Interrupt Enable
           =2 SBIT (ES0, SFR_IE, 4);                 // UART0 Interrupt Enable
           =2 SBIT (ET1, SFR_IE, 3);                 // Timer 1 Interrupt Enable
           =2 SBIT (EX1, SFR_IE, 2);                 // External Interrupt 1 Enable
           =2 SBIT (ET0, SFR_IE, 1);                 // Timer 0 Interrupt Enable
           =2 SBIT (EX0, SFR_IE, 0);                 // External Interrupt 0 Enable
           =2 
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 131 

           =2 // IP 0xB8
           =2                                        // Bit 7 unused
           =2 SBIT (PSPI0, SFR_IP, 6);               // SPI0 Interrupt Priority
           =2 SBIT (PT2, SFR_IP, 5);                 // Timer 2 Priority
           =2 SBIT (PS0, SFR_IP, 4);                 // UART0 Priority
           =2 SBIT (PS, SFR_IP, 4);                  // UART0 Priority
           =2 SBIT (PT1, SFR_IP, 3);                 // Timer 1 Priority
           =2 SBIT (PX1, SFR_IP, 2);                 // External Interrupt 1 Priority
           =2 SBIT (PT0, SFR_IP, 1);                 // Timer 0 Priority
           =2 SBIT (PX0, SFR_IP, 0);                 // External Interrupt 0 Priority
           =2 
           =2 // SMB0CN 0xC0
           =2 SBIT (MASTER, SFR_SMB0CN, 7);          // SMBus0 Master/Slave Indicator
           =2 SBIT (TXMODE, SFR_SMB0CN, 6);          // SMBus0 Transmit Mode Indicator
           =2 SBIT (STA, SFR_SMB0CN, 5);             // SMBus0 Start Flag
           =2 SBIT (STO, SFR_SMB0CN, 4);             // SMBus0 Stop Flag
           =2 SBIT (ACKRQ, SFR_SMB0CN, 3);           // SMBus0 Acknowledge Request
           =2 SBIT (ARBLOST, SFR_SMB0CN, 2);         // SMBus0 Arbitration Lost Indicator
           =2 SBIT (ACK, SFR_SMB0CN, 1);             // SMBus0 Acknowledge
           =2 SBIT (SI, SFR_SMB0CN, 0);              // SMBus0 Interrupt Flag
           =2 
           =2 // TMR2CN 0xC8
           =2 SBIT (TF2H, SFR_TMR2CN, 7);            // Timer 2 High-Byte Overflow Flag
           =2 SBIT (TF2L, SFR_TMR2CN, 6);            // Timer 2 Low-Byte  Overflow Flag
           =2 SBIT (TF2LEN, SFR_TMR2CN, 5);          // Timer 2 Low-Byte Flag Enable
           =2 SBIT (TF2CEN, SFR_TMR2CN, 4);          // Timer 2 Capture Enable
           =2 SBIT (T2SPLIT, SFR_TMR2CN, 3);         // Timer 2 Split-Mode Enable
           =2 SBIT (TR2, SFR_TMR2CN, 2);             // Timer 2 Run Enable
           =2 SBIT (T2RCLK, SFR_TMR2CN, 1);          // Timer 2 Xclk/Rclk Select
           =2 SBIT (T2XCLK, SFR_TMR2CN, 0);          // Timer 2 Clk/8 Clock Source
           =2 
           =2 // TMR4CN 0xC8
           =2 SBIT (TF4, SFR_TMR4CN, 7);             // Timer 4 Overflow/Underflow Flag
           =2 SBIT (EXF4, SFR_TMR4CN, 6);            // Timer 4 External Flag
           =2                                        // Bit 5 unused
           =2                                        // Bit 4 unused
           =2 SBIT (EXE4, SFR_TMR4CN, 3);            // Timer 4 External Enable
           =2 SBIT (TR4, SFR_TMR4CN, 2);             // Timer 4 Run Enable
           =2 SBIT (CT4, SFR_TMR4CN, 1);             // Timer 4 Counter/Timer Select
           =2 SBIT (CPRL4, SFR_TMR4CN, 0);           // Timer 4 Capture/Reload Select
           =2 
           =2 // PSW 0xD0
           =2 SBIT (CY, SFR_PSW, 7);                 // Carry Flag
           =2 SBIT (AC, SFR_PSW, 6);                 // Auxiliary Carry Flag
           =2 SBIT (F0, SFR_PSW, 5);                 // User Flag 0
           =2 SBIT (RS1, SFR_PSW, 4);                // Register Bank Select 1
           =2 SBIT (RS0, SFR_PSW, 3);                // Register Bank Select 0
           =2 SBIT (OV, SFR_PSW, 2);                 // Overflow Flag
           =2 SBIT (F1, SFR_PSW, 1);                 // User Flag 1
           =2 SBIT (P, SFR_PSW, 0);                  // Accumulator Parity Flag
           =2 
           =2 // PCA0CN 0xD8
           =2 SBIT (CF, SFR_PCA0CN, 7);              // PCA0 Counter Overflow Flag
           =2 SBIT (CR, SFR_PCA0CN, 6);              // PCA0 Counter Run Control Bit
           =2 SBIT (CCF5, SFR_PCA0CN, 5);            // PCA0 Module 5 Interrupt Flag
           =2 SBIT (CCF4, SFR_PCA0CN, 4);            // PCA0 Module 4 Interrupt Flag
           =2 SBIT (CCF3, SFR_PCA0CN, 3);            // PCA0 Module 3 Interrupt Flag
           =2 SBIT (CCF2, SFR_PCA0CN, 2);            // PCA0 Module 2 Interrupt Flag
           =2 SBIT (CCF1, SFR_PCA0CN, 1);            // PCA0 Module 1 Interrupt Flag
           =2 SBIT (CCF0, SFR_PCA0CN, 0);            // PCA0 Module 0 Interrupt Flag
           =2 
           =2 // PCA1CN 0xD8
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 132 

           =2 SBIT (CF1, SFR_PCA1CN, 7);             // PCA1 Counter Overflow Flag
           =2 SBIT (CR1, SFR_PCA1CN, 6);             // PCA1 Counter Run Control Bit
           =2 SBIT (CCF11, SFR_PCA1CN, 5);           // PCA1 Module 11 Interrupt Flag
           =2 SBIT (CCF10, SFR_PCA1CN, 4);           // PCA1 Module 10 Interrupt Flag
           =2 SBIT (CCF9, SFR_PCA1CN, 3);            // PCA1 Module 9 Interrupt Flag
           =2 SBIT (CCF8, SFR_PCA1CN, 2);            // PCA1 Module 8 Interrupt Flag
           =2 SBIT (CCF7, SFR_PCA1CN, 1);            // PCA1 Module 7 Interrupt Flag
           =2 SBIT (CCF6, SFR_PCA1CN, 0);            // PCA1 Module 6 Interrupt Flag
           =2 
           =2 // ADC0CN 0xE8
           =2 SBIT (AD0EN, SFR_ADC0CN, 7);           // ADC0 Enable
           =2 SBIT (BURSTEN, SFR_ADC0CN, 6);         // ADC0 Burst Enable
           =2 SBIT (AD0INT, SFR_ADC0CN, 5);          // ADC0 EOC Interrupt Flag
           =2 SBIT (AD0BUSY, SFR_ADC0CN, 4);         // ADC0 Busy Flag
           =2 SBIT (AD0WINT, SFR_ADC0CN, 3);         // ADC0 Window Compare Interrupt Flag
           =2 SBIT (AD0LJST, SFR_ADC0CN, 2);         // ADC0 Left Justified
           =2 SBIT (AD0CM1, SFR_ADC0CN, 1);          // ADC0 Start Of Conversion Mode Bit 1
           =2 SBIT (AD0CM0, SFR_ADC0CN, 0);          // ADC0 Start Of Conversion Mode Bit 0
           =2 
           =2 // SPI0CN 0xF8
           =2 SBIT (SPIF, SFR_SPI0CN, 7);            // SPI0 Interrupt Flag
           =2 SBIT (WCOL, SFR_SPI0CN, 6);            // SPI0 Write Collision Flag
           =2 SBIT (MODF, SFR_SPI0CN, 5);            // SPI0 Mode Fault Flag
           =2 SBIT (RXOVRN, SFR_SPI0CN, 4);          // SPI0 RX Overrun Flag
           =2 SBIT (NSSMD1, SFR_SPI0CN, 3);          // SPI0 Slave Select Mode 1
           =2 SBIT (NSSMD0, SFR_SPI0CN, 2);          // SPI0 Slave Select Mode 0
           =2 SBIT (TXBMT, SFR_SPI0CN, 1);           // SPI0 TX Buffer Empty Flag
           =2 SBIT (SPIEN, SFR_SPI0CN, 0);           // SPI0 Enable
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // Interrupt Priorities
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 #define INTERRUPT_INT0             0   // External Interrupt 0
           =2 #define INTERRUPT_TIMER0           1   // Timer 0 Overflow
           =2 #define INTERRUPT_INT1             2   // External Interrupt 1
           =2 #define INTERRUPT_TIMER1           3   // Timer 1 Overflow
           =2 #define INTERRUPT_UART0            4   // UART0
           =2 #define INTERRUPT_TIMER2           5   // Timer 2 Overflow
           =2 #define INTERRUPT_SPI0             6   // SPI0
           =2 #define INTERRUPT_SMBUS0           7   // SMBus0 Interface
           =2 #define INTERRUPT_ADC0_WINDOW      8   // ADC0 Window Comparison
           =2 #define INTERRUPT_ADC0_EOC         9   // ADC0 End Of Conversion
           =2 #define INTERRUPT_PCA0            10   // PCA0 Peripheral
           =2 #define INTERRUPT_COMPARATOR0     11   // Comparator 0 Comparison
           =2 #define INTERRUPT_COMPARATOR1     12   // Comparator 1 Comparison
           =2 #define INTERRUPT_TIMER3          13   // Timer 3 Overflow
           =2 #define INTERRUPT_LIN0            14   // LIN Bus Interrupt
           =2 #define INTERRUPT_VREG            15   // Voltage Regulator
           =2 #define INTERRUPT_CAN0            16   // CAN Bus Interrupt
           =2 #define INTERRUPT_PORT_MATCH      17   // Port Match
           =2 #define INTERRUPT_UART1           18   // UART1
           =2 #define INTERRUPT_PCA1            19   // PCA1 Peripheral
           =2 #define INTERRUPT_COMPARATOR2     20   // Comparator 2 Comparison
           =2 #define INTERRUPT_TIMER4          21   // Timer 4 Overflow
           =2 #define INTERRUPT_TIMER5          22   // Timer 5 Overflow
           =2 
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // SFR Page Definitions
           =2 //-----------------------------------------------------------------------------
           =2 
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 133 

           =2 #define  CONFIG_PAGE       0x0F        // System and Port Configuration Page
           =2 #define  ACTIVE_PAGE       0x00        // Active Use Page
           =2 #define  ACTIVE2_PAGE      0x10        // Active Use Page 2
           =2 #define  CAN0_PAGE         0x0C        // CAN0 Registers
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // SDCC PDATA External Memory Paging Support
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 #if defined SDCC
           =2 
           =2 SFR(_XPAGE, 0xAA); // Point to the EMI0CN register
           =2 
           =2 #endif
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // Header File PreProcessor Directive
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 #endif                                 // #define C8051F580_DEFS_H
 607      =2  
 608      =2  //-----------------------------------------------------------------------------
 609      =2  // End Of File
 610      =2  //-----------------------------------------------------------------------------
  14      =1  
  15      =1  void Os_start(void);
  16      =1  void idle_task(void);
  17      =1  void task1_handler(void);
  18      =1  void task2_handler(void);
  19      =1  void task3_handler(void);
  20      =1  void Callback_timer2(void);
  21      =1  void Callback_ext0(void);
  22      =1  #endif
   2          extern U32 G_systick;
   3          extern U8 Current_task;
   4          extern TCB_t User_task[MAX_TASK];
   5          
   6          SEG_XDATA U8 G_button_state = RELEASE;
   7          void Os_start(void){
   8   1              SFRPAGE = ACTIVE_PAGE;
   9   1              PCA0MD &= ~0x40;                    // Disable watchdog timer
  10   1          MCU_init();
  11   1          Timer2_Set_Callback_Ptr(Callback_timer2);
  12   1              Ext0_Set_Callback_Ptr(Callback_ext0);
  13   1              Create_task(0U,idle_task);
  14   1          Create_task(1U,task1_handler);
  15   1          Create_task(2U,task2_handler);
  16   1          Create_task(3U,task3_handler);
  17   1              while(1){
  18   2          Os_scheduler();
  19   2              User_task[Current_task].task_handler();  
  20   2              }
  21   1      }
  22          
  23          void idle_task(void){
  24   1              if(G_button_state == PRESS ){
  25   2              Tonggle(LED_GREEN);
  26   2              G_button_state = RELEASE ;
  27   2              }
  28   1      }
  29          
  30          void task1_handler(void){
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 134 

  31   1                      U8 save = SFRPAGE;
  32   1              SFRPAGE = ACTIVE2_PAGE;
  33   1              printf("task1_handler \n");
  34   1                      SFRPAGE = save;
  35   1              Os_delay(1000);
  36   1      }
  37          
  38          void task2_handler(void){
  39   1                      U8 save = SFRPAGE;
  40   1              SFRPAGE = ACTIVE2_PAGE;
  41   1              printf("task2_handler \n");
  42   1                      SFRPAGE = save;
  43   1              Tonggle(LED_YELLOW);
  44   1              Os_delay(3000);
  45   1      }
  46          
  47          void task3_handler(void){
  48   1                      U8 save = SFRPAGE;
  49   1              SFRPAGE = ACTIVE2_PAGE;
  50   1              printf("task3_handler \n");
  51   1                      SFRPAGE = save;
  52   1              Os_delay(5000);
  53   1      }
  54          
  55          void Callback_timer2(void){
  56   1          
  57   1          Increase_G_systick();
  58   1          Unblock_task();
  59   1              Clear_Timer2_ISR_Flag();
  60   1      }
  61          void Callback_ext0(void){
  62   1              Polling();
  63   1              if(!Get_Button_state()){
  64   2                      G_button_state = PRESS;
  65   2              }
  66   1      }
  67          
  68          
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 135 

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION Os_start (BEGIN)
                                           ; SOURCE LINE # 7
                                           ; SOURCE LINE # 8
0000 75A700            MOV     SFRPAGE,#00H
                                           ; SOURCE LINE # 9
0003 53D9BF            ANL     PCA0MD,#0BFH
                                           ; SOURCE LINE # 10
0006 120000      E     LCALL   MCU_init
                                           ; SOURCE LINE # 11
0009 7BFF              MOV     R3,#0FFH
000B 7A00        R     MOV     R2,#HIGH Callback_timer2
000D 7900        R     MOV     R1,#LOW Callback_timer2
000F 120000      E     LCALL   _Timer2_Set_Callback_Ptr
                                           ; SOURCE LINE # 12
0012 7BFF              MOV     R3,#0FFH
0014 7A00        R     MOV     R2,#HIGH Callback_ext0
0016 7900        R     MOV     R1,#LOW Callback_ext0
0018 120000      E     LCALL   _Ext0_Set_Callback_Ptr
                                           ; SOURCE LINE # 13
001B 7BFF              MOV     R3,#0FFH
001D 7A00        R     MOV     R2,#HIGH idle_task
001F 7900        R     MOV     R1,#LOW idle_task
0021 7F00              MOV     R7,#00H
0023 120000      E     LCALL   _Create_task
                                           ; SOURCE LINE # 14
0026 7BFF              MOV     R3,#0FFH
0028 7A00        R     MOV     R2,#HIGH task1_handler
002A 7900        R     MOV     R1,#LOW task1_handler
002C 7F01              MOV     R7,#01H
002E 120000      E     LCALL   _Create_task
                                           ; SOURCE LINE # 15
0031 7BFF              MOV     R3,#0FFH
0033 7A00        R     MOV     R2,#HIGH task2_handler
0035 7900        R     MOV     R1,#LOW task2_handler
0037 7F02              MOV     R7,#02H
0039 120000      E     LCALL   _Create_task
                                           ; SOURCE LINE # 16
003C 7BFF              MOV     R3,#0FFH
003E 7A00        R     MOV     R2,#HIGH task3_handler
0040 7900        R     MOV     R1,#LOW task3_handler
0042 7F03              MOV     R7,#03H
0044 120000      E     LCALL   _Create_task
0047         ?C0001:
                                           ; SOURCE LINE # 17
                                           ; SOURCE LINE # 18
0047 120000      E     LCALL   Os_scheduler
                                           ; SOURCE LINE # 19
004A 900000      E     MOV     DPTR,#Current_task
004D E0                MOVX    A,@DPTR
004E FF                MOV     R7,A
004F EF                MOV     A,R7
0050 75F008            MOV     B,#08H
0053 A4                MUL     AB
0054 2400        E     ADD     A,#LOW User_task+05H
0056 F582              MOV     DPL,A
0058 E4                CLR     A
0059 3400        E     ADDC    A,#HIGH User_task+05H
005B F583              MOV     DPH,A
005D E0                MOVX    A,@DPTR
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 136 

005E FB                MOV     R3,A
005F A3                INC     DPTR
0060 E0                MOVX    A,@DPTR
0061 FA                MOV     R2,A
0062 A3                INC     DPTR
0063 E0                MOVX    A,@DPTR
0064 F9                MOV     R1,A
0065 120000      E     LCALL   ?C?ICALL
                                           ; SOURCE LINE # 20
0068 80DD              SJMP    ?C0001
006A         ?C0002:
                                           ; SOURCE LINE # 21
006A         ?C0003:
006A 22                RET     
             ; FUNCTION Os_start (END)

             ; FUNCTION idle_task (BEGIN)
                                           ; SOURCE LINE # 23
                                           ; SOURCE LINE # 24
0000 900000      R     MOV     DPTR,#G_button_state
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 700B              JNZ     ?C0005
                                           ; SOURCE LINE # 25
0008 7F00              MOV     R7,#00H
000A 120000      E     LCALL   _Tonggle
                                           ; SOURCE LINE # 26
000D 900000      R     MOV     DPTR,#G_button_state
0010 7401              MOV     A,#01H
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 27
0013         ?C0004:
                                           ; SOURCE LINE # 28
0013         ?C0005:
0013 22                RET     
             ; FUNCTION idle_task (END)

             ; FUNCTION task1_handler (BEGIN)
                                           ; SOURCE LINE # 30
                                           ; SOURCE LINE # 31
0000 900000      R     MOV     DPTR,#save
0003 E5A7              MOV     A,SFRPAGE
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 32
0006 75A710            MOV     SFRPAGE,#010H
                                           ; SOURCE LINE # 33
0009 7BFF              MOV     R3,#0FFH
000B 7A00        R     MOV     R2,#HIGH ?SC_0
000D 7900        R     MOV     R1,#LOW ?SC_0
000F 120000      E     LCALL   _printf
                                           ; SOURCE LINE # 34
0012 900000      R     MOV     DPTR,#save
0015 E0                MOVX    A,@DPTR
0016 FF                MOV     R7,A
0017 8FA7              MOV     SFRPAGE,R7
                                           ; SOURCE LINE # 35
0019 7FE8              MOV     R7,#0E8H
001B 7E03              MOV     R6,#03H
001D 7D00              MOV     R5,#00H
001F 7C00              MOV     R4,#00H
0021 120000      E     LCALL   _Os_delay
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 137 

                                           ; SOURCE LINE # 36
0024         ?C0006:
0024 22                RET     
             ; FUNCTION task1_handler (END)

             ; FUNCTION task2_handler (BEGIN)
                                           ; SOURCE LINE # 38
                                           ; SOURCE LINE # 39
0000 900000      R     MOV     DPTR,#save
0003 E5A7              MOV     A,SFRPAGE
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 40
0006 75A710            MOV     SFRPAGE,#010H
                                           ; SOURCE LINE # 41
0009 7BFF              MOV     R3,#0FFH
000B 7A00        R     MOV     R2,#HIGH ?SC_16
000D 7900        R     MOV     R1,#LOW ?SC_16
000F 120000      E     LCALL   _printf
                                           ; SOURCE LINE # 42
0012 900000      R     MOV     DPTR,#save
0015 E0                MOVX    A,@DPTR
0016 FF                MOV     R7,A
0017 8FA7              MOV     SFRPAGE,R7
                                           ; SOURCE LINE # 43
0019 7F01              MOV     R7,#01H
001B 120000      E     LCALL   _Tonggle
                                           ; SOURCE LINE # 44
001E 7FB8              MOV     R7,#0B8H
0020 7E0B              MOV     R6,#0BH
0022 7D00              MOV     R5,#00H
0024 7C00              MOV     R4,#00H
0026 120000      E     LCALL   _Os_delay
                                           ; SOURCE LINE # 45
0029         ?C0007:
0029 22                RET     
             ; FUNCTION task2_handler (END)

             ; FUNCTION task3_handler (BEGIN)
                                           ; SOURCE LINE # 47
                                           ; SOURCE LINE # 48
0000 900000      R     MOV     DPTR,#save
0003 E5A7              MOV     A,SFRPAGE
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 49
0006 75A710            MOV     SFRPAGE,#010H
                                           ; SOURCE LINE # 50
0009 7BFF              MOV     R3,#0FFH
000B 7A00        R     MOV     R2,#HIGH ?SC_32
000D 7900        R     MOV     R1,#LOW ?SC_32
000F 120000      E     LCALL   _printf
                                           ; SOURCE LINE # 51
0012 900000      R     MOV     DPTR,#save
0015 E0                MOVX    A,@DPTR
0016 FF                MOV     R7,A
0017 8FA7              MOV     SFRPAGE,R7
                                           ; SOURCE LINE # 52
0019 7F88              MOV     R7,#088H
001B 7E13              MOV     R6,#013H
001D 7D00              MOV     R5,#00H
001F 7C00              MOV     R4,#00H
0021 120000      E     LCALL   _Os_delay
                                           ; SOURCE LINE # 53
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 138 

0024         ?C0008:
0024 22                RET     
             ; FUNCTION task3_handler (END)

             ; FUNCTION Callback_timer2 (BEGIN)
                                           ; SOURCE LINE # 55
                                           ; SOURCE LINE # 57
0000 120000      E     LCALL   Increase_G_systick
                                           ; SOURCE LINE # 58
0003 120000      E     LCALL   Unblock_task
                                           ; SOURCE LINE # 59
0006 120000      E     LCALL   Clear_Timer2_ISR_Flag
                                           ; SOURCE LINE # 60
0009         ?C0009:
0009 22                RET     
             ; FUNCTION Callback_timer2 (END)

             ; FUNCTION Callback_ext0 (BEGIN)
                                           ; SOURCE LINE # 61
                                           ; SOURCE LINE # 62
0000 120000      E     LCALL   Polling
                                           ; SOURCE LINE # 63
0003 120000      E     LCALL   Get_Button_state
0006 EF                MOV     A,R7
0007 7005              JNZ     ?C0011
                                           ; SOURCE LINE # 64
0009 900000      R     MOV     DPTR,#G_button_state
000C E4                CLR     A
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 65
000E         ?C0010:
                                           ; SOURCE LINE # 66
000E         ?C0011:
000E 22                RET     
             ; FUNCTION Callback_ext0 (END)

C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 139 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


U8 . . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
U16. . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
U32. . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_LONG   -----  4
S8 . . . . . . . . . . . . . . . . . .  TYPEDEF  -----  CHAR     -----  1
S16. . . . . . . . . . . . . . . . . .  TYPEDEF  -----  INT      -----  2
S32. . . . . . . . . . . . . . . . . .  TYPEDEF  -----  LONG     -----  4
UU16 . . . . . . . . . . . . . . . . .  * TAG *  -----  UNION    -----  2
  U16. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  S16. . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0000H  2
  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
  S8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
UU16 . . . . . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  2
  U16. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  S16. . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0000H  2
  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
  S8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
UU32 . . . . . . . . . . . . . . . . .  * TAG *  -----  UNION    -----  4
  U32. . . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0000H  4
  S32. . . . . . . . . . . . . . . . .  MEMBER   -----  LONG     0000H  4
  UU16 . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  U16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  S16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  S8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
UU32 . . . . . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  4
  U32. . . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0000H  4
  S32. . . . . . . . . . . . . . . . .  MEMBER   -----  LONG     0000H  4
  UU16 . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  U16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  S16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  S8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
SFRPAGE. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A7H  1
PCA0MD . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D9H  1
LED_GREEN. . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
LED_YELLOW . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
Led_e. . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
_Tonggle . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
Get_Button_state . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_Ext0_Set_Callback_Ptr . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_Timer2_Set_Callback_Ptr . . . . . . .  EXTERN   CODE   PROC     -----  -----
Clear_Timer2_ISR_Flag. . . . . . . . .  EXTERN   CODE   PROC     -----  -----
Increase_G_systick . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
MCU_init . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
Polling. . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
size_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
_printf. . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
TCB_t. . . . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  8
  block_count. . . . . . . . . . . . .  MEMBER   -----  U_LONG   0000H  4
  current_state. . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  task_handler . . . . . . . . . . . .  MEMBER   -----  PTR      0005H  3
_Create_task . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
Unblock_task . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_Os_delay. . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
Os_scheduler . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
Os_start . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
idle_task. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
C51 COMPILER V9.51   APPLICATION                                                           04/23/2025 15:01:03 PAGE 140 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


task1_handler. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  save . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
task2_handler. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  save . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
task3_handler. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  save . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
Callback_timer2. . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
Callback_ext0. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
Current_task . . . . . . . . . . . . .  EXTERN   XDATA  U_CHAR   -----  1
User_task. . . . . . . . . . . . . . .  EXTERN   XDATA  ARRAY    -----  32
G_button_state . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   0000H  1


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    268    ----
   CONSTANT SIZE    =     48    ----
   XDATA SIZE       =      4    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
