C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.exe main.c DB OE BR INCDIR(C:\SiLabs\MCU\Inc,./Kernel123) SB CD LC OR NOAREG
                    -S OT(0,SPEED) COMPACT

line level    source

   1          #include <compiler_defs.h>
   1      =1  //-----------------------------------------------------------------------------
   2      =1  // compiler_defs.h
   3      =1  //-----------------------------------------------------------------------------
   4      =1  // Portions of this file are copyright Maarten Brock
   5      =1  // http://sdcc.sourceforge.net
   6      =1  // Portions of this file are copyright 2010, Silicon Laboratories, Inc.
   7      =1  // http://www.silabs.com
   8      =1  //
   9      =1  // GNU LGPL boilerplate:
  10      =1  /** This library is free software; you can redistribute it and/or
  11      =1    * modify it under the terms of the GNU Lesser General Public
  12      =1    * License as published by the Free Software Foundation; either
  13      =1    * version 2.1 of the License, or (at your option) any later version.
  14      =1    *
  15      =1    * This library is distributed in the hope that it will be useful,
  16      =1    * but WITHOUT ANY WARRANTY; without even the implied warranty of
  17      =1    * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  18      =1    * Lesser General Public License for more details.
  19      =1    *
  20      =1    * You should have received a copy of the GNU Lesser General Public
  21      =1    * License along with this library; if not, write to the Free Software
  22      =1    * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  23      =1    *
  24      =1    * In other words, you are welcome to use, share and improve this program.
  25      =1    * You are forbidden to forbid anyone else to use, share and improve
  26      =1    * what you give them. Help stamp out software-hoarding!
  27      =1  **/
  28      =1  // Program Description:
  29      =1  //
  30      =1  // **Important Note**: This header file should be included before including
  31      =1  // a device-specific header file such as C8051F300_defs.h.
  32      =1  //
  33      =1  // Macro definitions to accomodate 8051 compiler differences in specifying
  34      =1  // special function registers and other 8051-specific features such as NOP
  35      =1  // generation, and locating variables in memory-specific segments.  The
  36      =1  // compilers are identified by their unique predefined macros. See also:
  37      =1  // http://predef.sourceforge.net/precomp.html
  38      =1  //
  39      =1  // SBIT and SFR define special bit and special function registers at the given
  40      =1  // address. SFR16 and SFR32 define sfr combinations at adjacent addresses in
  41      =1  // little-endian format. SFR16E and SFR32E define sfr combinations without
  42      =1  // prerequisite byte order or adjacency. None of these multi-byte sfr
  43      =1  // combinations will guarantee the order in which they are accessed when read
  44      =1  // or written.
  45      =1  //
  46      =1  // SFR16X and SFR32X for 16 bit and 32 bit xdata registers are not defined
  47      =1  // to avoid portability issues because of compiler endianness.
  48      =1  //
  49      =1  // Example:
  50      =1  // // my_mcu.c: main 'c' file for my mcu
  51      =1  // #include <compiler_defs.h>  // this file
  52      =1  // #include <C8051xxxx_defs.h> // SFR definitions for specific MCU target
  53      =1  //
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 2   

  54      =1  // SBIT  (P0_1, 0x80, 1);      // Port 0 pin 1
  55      =1  // SFR   (P0, 0x80);           // Port 0
  56      =1  // SFRX  (CPUCS, 0xE600);      // Cypress FX2 Control and Status register in
  57      =1  //                             // xdata memory at 0xE600
  58      =1  // SFR16 (TMR2, 0xCC);         // Timer 2, lsb at 0xCC, msb at 0xCD
  59      =1  // SFR16E(TMR0, 0x8C8A);       // Timer 0, lsb at 0x8A, msb at 0x8C
  60      =1  // SFR32 (MAC0ACC, 0x93);      // SiLabs C8051F120 32 bits MAC0 Accumulator,
  61      =1  //                             // lsb at 0x93, msb at 0x96
  62      =1  // SFR32E(SUMR, 0xE5E4E3E2);   // TI MSC1210 SUMR 32 bits Summation register,
  63      =1  //                             // lsb at 0xE2, msb at 0xE5
  64      =1  //
  65      =1  // Target:         C8051xxxx
  66      =1  // Tool chain:     Generic
  67      =1  // Command Line:   None
  68      =1  // 
  69      =1  // Release 2.6 - 14 DEC 2012 (GO)
  70      =1  //        -Added define for deprecated SDCC keyword 'at'
  71      =1  // Release 2.5 - 12 SEP 2012 (TP)
  72      =1  //    -Added defines for deprecated SDCC keywords bit and code
  73      =1  // Release 2.4 - 27 AUG 2012 (TP)
  74      =1  //    -Added defines for deprecated SDCC keywords interrupt, _asm, and _endasm
  75      =1  // Release 2.3 - 27 MAY 2010 (DM)
  76      =1  //    -Removed 'LOCATED_VARIABLE' pragma from Keil because it is not supported
  77      =1  // Release 2.2 - 06 APR 2010 (ES)
  78      =1  //    -Removed 'PATHINCLUDE' pragma from Raisonance section
  79      =1  // Release 2.1 - 16 JUL 2009 (ES)
  80      =1  //    -Added SEGMENT_POINTER macro definitions for SDCC, Keil, and Raisonance
  81      =1  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for Raisonance
  82      =1  // Release 2.0 - 19 MAY 2009 (ES)
  83      =1  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for SDCC and Keil
  84      =1  // Release 1.9 - 23 OCT 2008 (ES)
  85      =1  //    -Updated Hi-Tech INTERRUPT and INTERRUPT_USING macro definitions
  86      =1  //    -Added SFR16 macro defintion for Hi-Tech
  87      =1  // Release 1.8 - 31 JUL 2008 (ES)
  88      =1  //    -Added INTERRUPT_USING and FUNCTION_USING macro's
  89      =1  //    -Added macro's for IAR
  90      =1  //    -Corrected Union definitions for Hi-Tech and added SFR16 macro defintion
  91      =1  // Release 1.7 - 11 SEP 2007 (BW)
  92      =1  //    -Added support for Raisonance EVAL 03.03.42 and Tasking Eval 7.2r1
  93      =1  // Release 1.6 - 27 AUG 2007 (BW)
  94      =1  //    -Updated copyright notice per agreement with Maartin Brock
  95      =1  //    -Added SDCC 2.7.0 "compiler.h" bug fixes
  96      =1  //    -Added memory segment defines (SEG_XDATA, for example)
  97      =1  // Release 1.5 - 24 AUG 2007 (BW)
  98      =1  //    -Added support for NOP () macro
  99      =1  //    -Added support for Hi-Tech ver 9.01
 100      =1  // Release 1.4 - 07 AUG 2007 (PKC)
 101      =1  //    -Removed FID and fixed formatting.
 102      =1  // Release 1.3 - 30 SEP 2007 (TP)
 103      =1  //    -Added INTERRUPT_PROTO_USING to properly support ISR context switching
 104      =1  //     under SDCC.
 105      =1  // Release 1.2 - (BW)
 106      =1  //    -Added support for U8,U16,U32,S8,S16,S32,UU16,UU32 data types
 107      =1  // Release 1.1 - (BW)
 108      =1  //    -Added support for INTERRUPT, INTERRUPT_USING, INTERRUPT_PROTO,
 109      =1  //     SEGMENT_VARIABLE, VARIABLE_SEGMENT_POINTER,
 110      =1  //     SEGMENT_VARIABLE_SEGMENT_POINTER, and LOCATED_VARIABLE
 111      =1  // Release 1.0 - 29 SEP 2006 (PKC)
 112      =1  //    -Initial revision
 113      =1  
 114      =1  //-----------------------------------------------------------------------------
 115      =1  // Header File Preprocessor Directive
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 3   

 116      =1  //-----------------------------------------------------------------------------
 117      =1  
 118      =1  #ifndef COMPILER_DEFS_H
 119      =1  #define COMPILER_DEFS_H
 120      =1  
 121      =1  //-----------------------------------------------------------------------------
 122      =1  // Macro definitions
 123      =1  //-----------------------------------------------------------------------------
 124      =1  
 125      =1  // SDCC - Small Device C Compiler
 126      =1  // http://sdcc.sourceforge.net
 127      =1  
 128      =1  #if defined SDCC
           =1 
           =1 #if (SDCC >= 300)
           =1 
           =1 #define interrupt __interrupt
           =1 #define _asm __asm
           =1 #define _endasm __endasm
           =1 #define bit __bit
           =1 #define code __code
           =1 #define at __at
           =1 
           =1 #endif
           =1 
           =1 # define SEG_GENERIC
           =1 # define SEG_FAR   __xdata
           =1 # define SEG_DATA  __data
           =1 # define SEG_NEAR  __data
           =1 # define SEG_IDATA __idata
           =1 # define SEG_XDATA __xdata
           =1 # define SEG_PDATA __pdata
           =1 # define SEG_CODE  __code
           =1 # define SEG_BDATA __bdata
           =1 
           =1 # define SBIT(name, addr, bit)  __sbit  __at(addr+bit)                  name
           =1 # define SFR(name, addr)        __sfr   __at(addr)                      name
           =1 # define SFRX(name, addr)       xdata volatile unsigned char __at(addr) name
           =1 # define SFR16(name, addr)      __sfr16 __at(((addr+1U)<<8) | addr)     name
           =1 # define SFR16E(name, fulladdr) __sfr16 __at(fulladdr)                  name
           =1 # define SFR32(name, addr)      __sfr32 __at(((addr+3UL)<<24) | ((addr+2UL)<<16) | ((addr+1UL)<<8) | addr)
             - name
           =1 # define SFR32E(name, fulladdr) __sfr32 __at(fulladdr)                  name
           =1 
           =1 # define INTERRUPT(name, vector) void name (void) interrupt (vector)
           =1 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =1 # define INTERRUPT_PROTO(name, vector) void name (void) interrupt (vector)
           =1 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =1 
           =1 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using (regnum
             -)
           =1 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter) using (
             -regnum)
           =1 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =1 
           =1 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =1 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =1 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =1 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =1 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment at (addr) vartype name = init
           =1 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) locsegment at (addr) vartype name
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 4   

           =1 
           =1 // used with UU16
           =1 # define LSB 0
           =1 # define MSB 1
           =1 
           =1 // used with UU32 (b0 is least-significant byte)
           =1 # define b0 0
           =1 # define b1 1
           =1 # define b2 2
           =1 # define b3 3
           =1 
           =1 typedef unsigned char U8;
           =1 typedef unsigned int U16;
           =1 typedef unsigned long U32;
           =1 
           =1 typedef signed char S8;
           =1 typedef signed int S16;
           =1 typedef signed long S32;
           =1 
           =1 typedef union UU16
           =1 {
           =1    U16 U16;
           =1    S16 S16;
           =1    U8 U8[2];
           =1    S8 S8[2];
           =1 } UU16;
           =1 
           =1 typedef union UU32
           =1 {
           =1    U32 U32;
           =1    S32 S32;
           =1    UU16 UU16[2];
           =1    U16 U16[2];
           =1    S16 S16[2];
           =1    U8 U8[4];
           =1    S8 S8[4];
           =1 } UU32;
           =1 
           =1 // NOP () macro support
           =1 #define NOP() _asm NOP _endasm
           =1 
           =1 
           =1 //-----------------------------------------------------------------------------
           =1 
           =1 // Raisonance (must be placed before Keil C51)
           =1 // http://www.raisonance.com
           =1 
           =1 #elif defined __RC51__
           =1 
           =1 //#error Raisonance C51 detected.
           =1 
           =1 # define SEG_GENERIC generic     //SEG_GENERIC only applies to pointers in Raisonance, not variables.
           =1 # define SEG_FAR   xdata
           =1 # define SEG_DATA  data
           =1 # define SEG_NEAR  data
           =1 # define SEG_IDATA idata
           =1 # define SEG_XDATA xdata
           =1 # define SEG_PDATA pdata
           =1 # define SEG_CODE  code
           =1 # define SEG_BDATA bdata
           =1 
           =1 # define SBIT(name, addr, bit)  at (addr+bit) sbit         name
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 5   

           =1 # define SFR(name, addr)        sfr at addr                name
           =1 # define SFR16(name, addr)      sfr16 at addr              name
           =1 # define SFR16E(name, fulladdr) /* not supported */
           =1 # define SFR32(name, fulladdr)  /* not supported */
           =1 # define SFR32E(name, fulladdr) /* not supported */
           =1 
           =1 # define INTERRUPT(name, vector) void name (void) interrupt vector
           =1 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =1 # define INTERRUPT_PROTO(name, vector) void name (void)
           =1 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =1 
           =1 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
           =1 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =1 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =1 
           =1 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =1 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =1 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =1 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =1 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) at addr locsegment vartype name
           =1 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) at addr locsegment vartype name
           =1 
           =1 
           =1 // used with UU16
           =1 # define LSB 1
           =1 # define MSB 0
           =1 
           =1 // used with UU32 (b0 is least-significant byte)
           =1 # define b0 3
           =1 # define b1 2
           =1 # define b2 1
           =1 # define b3 0
           =1 
           =1 typedef unsigned char U8;
           =1 typedef unsigned int U16;
           =1 typedef unsigned long U32;
           =1 
           =1 typedef signed char S8;
           =1 typedef signed int S16;
           =1 typedef signed long S32;
           =1 
           =1 typedef union UU16
           =1 {
           =1    U16 U16;
           =1    S16 S16;
           =1    U8 U8[2];
           =1    S8 S8[2];
           =1 } UU16;
           =1 
           =1 typedef union UU32
           =1 {
           =1    U32 U32;
           =1    S32 S32;
           =1    UU16 UU16[2];
           =1    U16 U16[2];
           =1    S16 S16[2];
           =1    U8 U8[4];
           =1    S8 S8[4];
           =1 } UU32;
           =1 
           =1 // NOP () macro support -- NOP is opcode 0x00
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 6   

           =1 #define NOP() asm { 0x00 }
           =1 
           =1 
           =1 //-----------------------------------------------------------------------------
           =1 
           =1 
           =1 // Keil C51
           =1 // http://www.keil.com
           =1 
           =1 #elif defined __C51__
 307      =1  
 308      =1  //#error Keil C51 detected.
 309      =1  
 310      =1  # define SEG_GENERIC
 311      =1  # define SEG_FAR   xdata
 312      =1  # define SEG_DATA  data
 313      =1  # define SEG_NEAR  data
 314      =1  # define SEG_IDATA idata
 315      =1  # define SEG_XDATA xdata
 316      =1  # define SEG_PDATA pdata
 317      =1  # define SEG_CODE  code
 318      =1  # define SEG_BDATA bdata
 319      =1  
 320      =1  # define SBIT(name, addr, bit)  sbit  name = addr^bit
 321      =1  # define SFR(name, addr)        sfr   name = addr
 322      =1  # define SFR16(name, addr)      sfr16 name = addr
 323      =1  # define SFR16E(name, fulladdr) /* not supported */
 324      =1  # define SFR32(name, fulladdr)  /* not supported */
 325      =1  # define SFR32E(name, fulladdr) /* not supported */
 326      =1  
 327      =1  # define INTERRUPT(name, vector) void name (void) interrupt vector
 328      =1  # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
 329      =1  # define INTERRUPT_PROTO(name, vector) void name (void)
 330      =1  # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
 331      =1  
 332      =1  # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
 333      =1  # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
 334      =1  // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
 335      =1  
 336      =1  # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
 337      =1  # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
 338      =1  # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
 339      =1  # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
 340      =1  # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) vartype locsegment name _at_ addr
 341      =1  
 342      =1  // used with UU16
 343      =1  # define LSB 1
 344      =1  # define MSB 0
 345      =1  
 346      =1  // used with UU32 (b0 is least-significant byte)
 347      =1  # define b0 3
 348      =1  # define b1 2
 349      =1  # define b2 1
 350      =1  # define b3 0
 351      =1  
 352      =1  typedef unsigned char U8;
 353      =1  typedef unsigned int U16;
 354      =1  typedef unsigned long U32;
 355      =1  
 356      =1  typedef signed char S8;
 357      =1  typedef signed int S16;
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 7   

 358      =1  typedef signed long S32;
 359      =1  
 360      =1  typedef union UU16
 361      =1  {
 362      =1     U16 U16;
 363      =1     S16 S16;
 364      =1     U8 U8[2];
 365      =1     S8 S8[2];
 366      =1  } UU16;
 367      =1  
 368      =1  typedef union UU32
 369      =1  {
 370      =1     U32 U32;
 371      =1     S32 S32;
 372      =1     UU16 UU16[2];
 373      =1     U16 U16[2];
 374      =1     S16 S16[2];
 375      =1     U8 U8[4];
 376      =1     S8 S8[4];
 377      =1  } UU32;
 378      =1  
 379      =1  // NOP () macro support
 380      =1  extern void _nop_ (void);
 381      =1  #define NOP() _nop_()
 382      =1  
 383      =1  //-----------------------------------------------------------------------------
 384      =1  
 385      =1  // Hi-Tech 8051
 386      =1  // http://www.htsoft.com
 387      =1  
 388      =1  #elif defined HI_TECH_C
           =1 
           =1 # define SEG_GENERIC
           =1 # define SEG_FAR   far
           =1 # define SEG_DATA  data
           =1 # define SEG_NEAR  near
           =1 # define SEG_IDATA idata
           =1 # define SEG_XDATA xdata
           =1 # define SEG_PDATA pdata
           =1 # define SEG_CODE  code
           =1 # define SEG_BDATA bdata
           =1 
           =1 
           =1 # define SBIT(name, addr, thebit) static volatile bit name @ (addr + thebit)
           =1 # define SFR(name, addr)          static volatile unsigned char name @ addr
           =1 # define SFR16(name, addr)        static volatile unsigned int name @ addr
           =1 # define SFR16E(name, fulladdr) /* not supported */
           =1 # define SFR32(name, fulladdr)  /* not supported */
           =1 # define SFR32E(name, fulladdr) /* not supported */
           =1 
           =1 # define INTERRUPT(name, vector)       void name (void) interrupt vector
           =1 # define INTERRUPT_PROTO(name, vector)
           =1 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =1 # define INTERRUPT_PROTO_USING(name, vector, regnum)
           =1 
           =1 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =1 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =1 // Note: Hi-Tech does not support functions using different register banks. Register
           =1 //       banks can only be specified in interrupts. If a function is called from
           =1 //       inside an interrupt, it will use the same register bank as the interrupt.
           =1 
           =1 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 8   

           =1 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =1 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =1 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment vartype name @ addr
           =1 
           =1 // used with UU16
           =1 # define LSB 0
           =1 # define MSB 1
           =1 
           =1 // used with UU32 (b0 is least-significant byte)
           =1 # define b0 0
           =1 # define b1 1
           =1 # define b2 2
           =1 # define b3 3
           =1 
           =1 typedef unsigned char U8;
           =1 typedef unsigned int U16;
           =1 typedef unsigned long U32;
           =1 
           =1 typedef signed char S8;
           =1 typedef signed int S16;
           =1 typedef signed long S32;
           =1 
           =1 typedef union UU16
           =1 {
           =1    U16 U16;
           =1    S16 S16;
           =1    U8 U8[2];
           =1    S8 S8[2];
           =1 } UU16;
           =1 
           =1 typedef union UU32
           =1 {
           =1    U32 U32;
           =1    S32 S32;
           =1    UU16 UU16[2];
           =1    U16 U16[2];
           =1    S16 S16[2];
           =1    U8 U8[4];
           =1    S8 S8[4];
           =1 } UU32;
           =1 
           =1 // NOP () macro support
           =1 #define NOP() asm(" nop ")
           =1 
           =1 //-----------------------------------------------------------------------------
           =1 
           =1 // Tasking / Altium
           =1 // http://www.altium.com/tasking
           =1 
           =1 
           =1 #elif defined _CC51
           =1 
           =1 # define SEG_GENERIC
           =1 # define SEG_FAR   _xdat
           =1 # define SEG_DATA  _data
           =1 # define SEG_NEAR  _data
           =1 # define SEG_IDATA _idat
           =1 # define SEG_XDATA _xdat
           =1 # define SEG_PDATA _pdat
           =1 # define SEG_CODE  _rom
           =1 # define SEG_BDATA _bdat
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 9   

           =1 
           =1 # define SBIT(name, addr, bit)  _sfrbit  name _at(addr+bit)
           =1 # define SFR(name, addr)        _sfrbyte name _at(addr)
           =1 # define SFRX(name, addr)       _xdat volatile unsigned char name _at(addr)
           =1 #if _CC51 > 71
           =1 # define SFR16(name, addr)      _sfrword _little name _at(addr)
           =1 #else
           =1 # define SFR16(name, addr)      /* not supported */
           =1 #endif
           =1 # define SFR16E(name, fulladdr) /* not supported */
           =1 # define SFR32(name, fulladdr)  /* not supported */
           =1 # define SFR32E(name, fulladdr) /* not supported */
           =1 
           =1 # define INTERRUPT(name, vector) _interrupt (vector) void name (void)
           =1 # define INTERRUPT_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =1 # define INTERRUPT_PROTO(name, vector) _interrupt (vector) void name (void)
           =1 # define INTERRUPT_PROTO_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =1 
           =1 // When calling FUNCTION_USING in Tasking, the function must be called from an interrupt or Main which
           =1 // is also using the same register bank. If not, the compiler will generate an error.
           =1 # define FUNCTION_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (parameter
             -)
           =1 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (par
             -ameter)
           =1 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =1 
           =1 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =1 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =1 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =1 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) vartype locsegment name _at( addr )
           =1 
           =1 // used with UU16
           =1 # define LSB 1
           =1 # define MSB 0
           =1 
           =1 // used with UU32 (b0 is least-significant byte)
           =1 # define b0 3
           =1 # define b1 2
           =1 # define b2 1
           =1 # define b3 0
           =1 
           =1 typedef unsigned char U8;
           =1 typedef unsigned int U16;
           =1 typedef unsigned long U32;
           =1 
           =1 typedef signed char S8;
           =1 typedef signed int S16;
           =1 typedef signed long S32;
           =1 
           =1 typedef union UU16
           =1 {
           =1    U16 U16;
           =1    S16 S16;
           =1    U8 U8[2];
           =1    S8 S8[2];
           =1 } UU16;
           =1 
           =1 typedef union UU32
           =1 {
           =1    U32 U32;
           =1    S32 S32;
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 10  

           =1    UU16 UU16[2];
           =1    U16 U16[2];
           =1    S16 S16[2];
           =1    U8 U8[4];
           =1    S8 S8[4];
           =1 } UU32;
           =1 
           =1 // NOP () macro support
           =1 extern void _nop (void);
           =1 #define NOP() _nop()
           =1 
           =1 //-----------------------------------------------------------------------------
           =1 
           =1 
           =1 // IAR 8051
           =1 // http://www.iar.com
           =1 
           =1 #elif defined __ICC8051__
           =1 
           =1 #include <stdbool.h>
           =1 #include <intrinsics.h>
           =1 
           =1 # define SBIT(name, addr, bit)  __bit __no_init volatile bool name @ (addr+bit)
           =1 # define SFR(name, addr)        __sfr __no_init volatile unsigned char name @ addr
           =1 # define SFRX(name, addr)       __xdata __no_init volatile unsigned char name @ addr
           =1 # define SFR16(name, addr)      __sfr __no_init volatile unsigned int  name @ addr
           =1 # define SFR16E(name, fulladdr) /* not supported */
           =1 # define SFR32(name, fulladdr) /* not supported */
           =1 # define SFR32E(name, fulladdr) /* not supported */
           =1 
           =1 # define SEG_GENERIC __generic
           =1 # define SEG_FAR  __xdata
           =1 # define SEG_DATA __data
           =1 # define SEG_NEAR __data
           =1 # define SEG_IDATA __idata
           =1 # define SEG_XDATA __xdata
           =1 # define SEG_PDATA __pdata
           =1 # define SEG_CODE  __code
           =1 # define SEG_BDATA __bdata
           =1 
           =1 #define bit bool
           =1 
           =1 # define _PPTOSTR_(x) #x
           =1 # define _PPARAM_(address) _PPTOSTR_(vector=address * 8 + 3)
           =1 # define _PPARAM2_(regbank) _PPTOSTR_(register_bank=regbank)
           =1 # define INTERRUPT(name, vector) _Pragma(_PPARAM_(vector)) __interrupt void name(void)
           =1 # define INTERRUPT_PROTO(name, vector)  __interrupt void name(void)
           =1 # define INTERRUPT_USING(name, vector, regnum) _Pragma(_PPARAM2_(regnum)) _Pragma(_PPARAM_(vector)) __inte
             -rrupt void name(void)
           =1 # define INTERRUPT_PROTO_USING(name, vector, regnum) __interrupt void name(void)
           =1 
           =1 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =1 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =1 // Note: IAR does not support functions using different register banks. Register
           =1 //       banks can only be specified in interrupts. If a function is called from
           =1 //       inside an interrupt, it will use the same register bank as the interrupt.
           =1 
           =1 # define SEGMENT_VARIABLE(name, vartype, locsegment)  locsegment vartype name
           =1 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment  * name
           =1 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =1 
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 11  

           =1 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment __no_init vartype name @ addr
           =1 
           =1 // used with UU16
           =1 # define LSB 0
           =1 # define MSB 1
           =1 
           =1 // used with UU32 (b0 is least-significant byte)
           =1 # define b0 0
           =1 # define b1 1
           =1 # define b2 2
           =1 # define b3 3
           =1 
           =1 typedef unsigned char U8;
           =1 typedef unsigned int U16;
           =1 typedef unsigned long U32;
           =1 
           =1 typedef signed char S8;
           =1 typedef signed int S16;
           =1 typedef signed long S32;
           =1 
           =1 typedef union UU16
           =1 {
           =1    U16 U16;
           =1    S16 S16;
           =1    U8 U8[2];
           =1    S8 S8[2];
           =1 } UU16;
           =1 
           =1 typedef union UU32
           =1 {
           =1    U32 U32;
           =1    S32 S32;
           =1    UU16 UU16[2];
           =1    U16 U16[2];
           =1    S16 S16[2];
           =1    U8 U8[4];
           =1    S8 S8[4];
           =1 } UU32;
           =1 
           =1 
           =1 #define NOP() __no_operation();
           =1 //-----------------------------------------------------------------------------
           =1 
           =1 // Crossware
           =1 // http://www.crossware.com
           =1 
           =1 #elif defined _XC51_VER
           =1 # define SBIT(name, addr, bit)  _sfrbit  name = (addr+bit)
           =1 # define SFR(name, addr)        _sfr     name = addr
           =1 # define SFR16(name, addr)      _sfrword name = addr
           =1 # define SFR16E(name, fulladdr) /* not supported */
           =1 # define SFR32(name, fulladdr)  /* not supported */
           =1 # define SFR32E(name, fulladdr) /* not supported */
           =1 
           =1 //-----------------------------------------------------------------------------
           =1 
           =1 // Wickenhäuser
           =1 // http://www.wickenhaeuser.de
           =1 
           =1 #elif defined __UC__
           =1 # define SBIT(name, addr, bit)  unsigned char bit  name @ (addr+bit)
           =1 # define SFR(name, addr)        near unsigned char name @ addr
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 12  

           =1 # define SFR16(name, addr)      /* not supported */
           =1 # define SFR16E(name, fulladdr) /* not supported */
           =1 # define SFR32(name, fulladdr)  /* not supported */
           =1 # define SFR32E(name, fulladdr) /* not supported */
           =1 
           =1 //-----------------------------------------------------------------------------
           =1 
           =1 // Default
           =1 // Unknown compiler
           =1 
           =1 #else
           =1 # warning unrecognized compiler
           =1 # define SBIT(name, addr, bit)  volatile bool           name
           =1 # define SFR(name, addr)        volatile unsigned char  name
           =1 # define SFRX(name, addr)       volatile unsigned char  name
           =1 # define SFR16(name, addr)      volatile unsigned short name
           =1 # define SFR16E(name, fulladdr) volatile unsigned short name
           =1 # define SFR32(name, fulladdr)  volatile unsigned long  name
           =1 # define SFR32E(name, fulladdr) volatile unsigned long  name
           =1 
           =1 #endif
 683      =1  
 684      =1  //-----------------------------------------------------------------------------
 685      =1  // Header File PreProcessor Directive
 686      =1  //-----------------------------------------------------------------------------
 687      =1  
 688      =1  #endif                                 // #define COMPILER_DEFS_H
 689      =1  
 690      =1  //-----------------------------------------------------------------------------
 691      =1  // End Of File
 692      =1  //-----------------------------------------------------------------------------
   2          #include <C8051F580_defs.h>            // SFR declarations
   1      =1  //-----------------------------------------------------------------------------
   2      =1  // C8051F580_defs.h
   3      =1  //-----------------------------------------------------------------------------
   4      =1  // Copyright 2008, Silicon Laboratories, Inc.
   5      =1  // http://www.silabs.com
   6      =1  //
   7      =1  // Program Description:
   8      =1  //
   9      =1  // Register/bit definitions for the C8051F58x family.
  10      =1  // **Important Note**: The compiler_defs.h header file should be included
  11      =1  // before including this header file.
  12      =1  //
  13      =1  // Target:         C8051F580/1/2/3/4/5/6/7,8/9-F590/1
  14      =1  // Tool chain:     Generic
  15      =1  // Command Line:   None
  16      =1  //
  17      =1  // Release 0.6 - 20 AUG 2012 (TP)
  18      =1  //    -Added #define for _XPAGE to provide support for SDCC memory paging
  19      =1  //     (pdata)
  20      =1  //
  21      =1  // Release 0.5 - 10 SEP 2011 (GP)
  22      =1  //    - Fixed SFR16 definition for CAN0IF2MC
  23      =1  //
  24      =1  // Release 0.4 - 08 OCT 2010 (TP)
  25      =1  //    - Fixed bit definitions for SCON0
  26      =1  //
  27      =1  // Release 0.3 - 01 APR 2009 (GP)
  28      =1  //    - Added SN0-SN3
  29      =1  //
  30      =1  // Release 0.2 - 29 JUL 2008 (ADT)
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 13  

  31      =1  //    - Added Timer 4 bit definitions
  32      =1  //
  33      =1  // Release 0.1 - 09 JUL 2008 (GP)
  34      =1  //    - Initial Revision
  35      =1  //
  36      =1  //-----------------------------------------------------------------------------
  37      =1  // Header File Preprocessor Directive
  38      =1  //-----------------------------------------------------------------------------
  39      =1  
  40      =1  #ifndef C8051F580_DEFS_H
  41      =1  #define C8051F580_DEFS_H
  42      =1  
  43      =1  //-----------------------------------------------------------------------------
  44      =1  // Page 0, Page 1 and Page F Registers
  45      =1  //-----------------------------------------------------------------------------
  46      =1  
  47      =1  SFR (P0, 0x80);                        // Port 0 Latch
  48      =1  SFR (SP, 0x81);                        // Stack Pointer
  49      =1  SFR (DPL, 0x82);                       // Data Pointer Low
  50      =1  SFR (DPH, 0x83);                       // Data Pointer High
  51      =1  SFR (SFR0CN, 0x84);                    // SFR Page Control
  52      =1  SFR (SFRNEXT, 0x85);                   // SFR stack next page
  53      =1  SFR (SFRLAST, 0x86);                   // SFR stack last page
  54      =1  SFR (PCON, 0x87);                      // Power Control
  55      =1  SFR (TCON, 0x88);                      // Timer/Counter Control
  56      =1  SFR (TMOD, 0x89);                      // Timer/Counter Mode
  57      =1  SFR (TL0, 0x8A);                       // Timer/Counter 0 Low
  58      =1  SFR (TL1, 0x8B);                       // Timer/Counter 1 Low
  59      =1  SFR (TH0, 0x8C);                       // Timer/Counter 0 High
  60      =1  SFR (TH1, 0x8D);                       // Timer/Counter 1 High
  61      =1  SFR (CKCON, 0x8E);                     // Clock Control
  62      =1  SFR (PSCTL, 0x8F);                     // Program Store R/W Control
  63      =1  SFR (CLKSEL, 0x8F);                    // System clock select
  64      =1  SFR (P1, 0x90);                        // Port 1 Latch
  65      =1  SFR (TMR3CN, 0x91);                    // Timer/Counter 3 Control
  66      =1  SFR (TMR5CN, 0x91);                    // Timer/Counter 5 Control
  67      =1  SFR (TMR3RLL, 0x92);                   // Timer/Counter 3 Reload Low
  68      =1  SFR (TMR5CAPL, 0x92);                  // Timer/Counter 5 Capture Low
  69      =1  SFR (TMR3RLH, 0x93);                   // Timer/Counter 3 Reload High
  70      =1  SFR (TMR5CAPH, 0x93);                  // Timer/Counter 5 Capture High
  71      =1  SFR (TMR3L, 0x94);                     // Timer/Counter 3 Low
  72      =1  SFR (TMR5L, 0x94);                     // Timer/Counter 5 Low
  73      =1  SFR (TMR3H, 0x95);                     // Timer/Counter 3 High
  74      =1  SFR (TMR5H, 0x95);                     // Timer/Counter 5 High
  75      =1  SFR (TMR5CF, 0x96);                    // Timer/Counter 5 Configuration
  76      =1  SFR (CLKMUL, 0x97);                    // Clock Multiplier
  77      =1  SFR (SCON0, 0x98);                     // UART0 Control
  78      =1  SFR (SCON1, 0x98);                     // UART1 Control
  79      =1  SFR (SBUF0, 0x99);                     // UART0 Data Buffer
  80      =1  SFR (SBUF1, 0x99);                     // UART1 Data Buffer
  81      =1  SFR (CPT0CN, 0x9A);                    // Comparator 0 Control
  82      =1  SFR (CPT2CN, 0x9A);                    // Comparator 2 Control
  83      =1  SFR (CPT0MD, 0x9B);                    // Comparator 0 Mode
  84      =1  SFR (CPT2MD, 0x9B);                    // Comparator 2 Mode
  85      =1  SFR (CPT0MX, 0x9C);                    // Comparator 0 Mux
  86      =1  SFR (CPT2MX, 0x9C);                    // Comparator 2 Mux
  87      =1  SFR (CPT1CN, 0x9D);                    // Comparator 1 Control
  88      =1  SFR (CPT1MD, 0x9E);                    // Comparator 0 Mode
  89      =1  SFR (OSCIFIN, 0x9E);                   // Internal Oscillator Fine Control
  90      =1  SFR (CPT1MX, 0x9F);                    // Comparator 1 Mux
  91      =1  SFR (OSCXCN, 0x9F);                    // External Oscillator Control
  92      =1  SFR (P2, 0xA0);                        // Port 2 Latch
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 14  

  93      =1  SFR (SPI0CFG, 0xA1);                   // SPI0 Configuration
  94      =1  SFR (OSCICN, 0xA1);                    // Internal Oscillator Control
  95      =1  SFR (SPI0CKR, 0xA2);                   // SPI0 Clock rate control
  96      =1  SFR (OSCICRS, 0xA2);                   // Internal Oscillator Coarse Control
  97      =1  SFR (SPI0DAT, 0xA3);                   // SPI0 Data Buffer
  98      =1  SFR (P0MDOUT, 0xA4);                   // Port 0 Output Mode
  99      =1  SFR (P1MDOUT, 0xA5);                   // Port 1 Output Mode
 100      =1  SFR (P2MDOUT, 0xA6);                   // Port 2 Output Mode
 101      =1  SFR (SFRPAGE, 0xA7);                   // SFR Page Select
 102      =1  SFR (IE, 0xA8);                        // Interrupt Enable
 103      =1  SFR (SMOD0, 0xA9);                     // Serial Port 0 Control
 104      =1  SFR (EMI0CN, 0xAA);                    // EMIF Control
 105      =1  SFR (EMI0TC, 0xAA);                    // EMIF Timing control
 106      =1  SFR (SBCON0, 0xAB);                    // UART0 Baud Rate Generator Control
 107      =1  SFR (SBRLL0, 0xAC);                    // UART0 Baud Rate Generator Low
 108      =1  SFR (SBRLH0, 0xAD);                    // UART0 Baud Rate Generator High
 109      =1  SFR (P3MAT, 0xAE);                     // Port 3 Match
 110      =1  SFR (P3MDOUT, 0xAE);                   // Port 3 Mode
 111      =1  SFR (P3MASK, 0xAF);                    // Port 3 Mask
 112      =1  SFR (P4MDOUT, 0xAF);                   // Port 4 Mode
 113      =1  SFR (P3, 0xB0);                        // Port 3 Latch
 114      =1  SFR (P2MAT, 0xB1);                     // Port 2 Match
 115      =1  SFR (P2MASK, 0xB2);                    // Port 2 Mask
 116      =1  SFR (EMI0CF, 0xB2);                    // EMIF Configuration
 117      =1  SFR (P4, 0xB5);                        // Port 4 Latch
 118      =1  SFR (FLSCL, 0xB6);                     // Flash Scale
 119      =1  SFR (FLKEY, 0xB7);                     // Flash access limit
 120      =1  SFR (IP, 0xB8);                        // Interrupt Priority
 121      =1  SFR (SMB0ADR, 0xB9);                   // SMBus0 Slave address
 122      =1  SFR (ADC0TK, 0xBA);                    // ADC0 Tracking Mode Select
 123      =1  SFR (SMB0ADM, 0xBA);                   // SMBus0 Address Mask
 124      =1  SFR (ADC0MX, 0xBB);                    // AMUX0 Channel select
 125      =1  SFR (ADC0CF, 0xBC);                    // AMUX0 Channel configuration
 126      =1  SFR (ADC0L, 0xBD);                     // ADC0 Data Low
 127      =1  SFR (ADC0H, 0xBE);                     // ADC0 Data High
 128      =1  SFR (SMB0CN, 0xC0);                    // SMBus0 Control
 129      =1  SFR (SMB0CF, 0xC1);                    // SMBus0 Configuration
 130      =1  SFR (SMB0DAT, 0xC2);                   // SMBus0 Data
 131      =1  SFR (ADC0GTL, 0xC3);                   // ADC0 Greater-Than Compare Low
 132      =1  SFR (ADC0GTH, 0xC4);                   // ADC0 Greater-Than Compare High
 133      =1  SFR (ADC0LTL, 0xC5);                   // ADC0 Less-Than Compare Word Low
 134      =1  SFR (ADC0LTH, 0xC6);                   // ADC0 Less-Than Compare Word High
 135      =1  SFR (XBR3, 0xC6);                      // Port I/O Crossbar Control 3
 136      =1  SFR (XBR2, 0xC7);                      // Port I/O Crossbar Control 2
 137      =1  SFR (TMR2CN, 0xC8);                    // Timer/Counter 2 Control
 138      =1  SFR (TMR4CN, 0xC8);                    // Timer/Counter 4 Control
 139      =1  SFR (REG0CN, 0xC9);                    // Regulator Control
 140      =1  SFR (LIN0CF, 0xC9);                    // LIN 0 Configuration
 141      =1  SFR (TMR4CF, 0xC9);                    // Timer/Counter 4 Configuration
 142      =1  SFR (TMR2RLL, 0xCA);                   // Timer/Counter 2 Reload Low
 143      =1  SFR (TMR4CAPL, 0xCA);                  // Timer/Counter 4 Capture Low
 144      =1  SFR (TMR2RLH, 0xCB);                   // Timer/Counter 2 Reload High
 145      =1  SFR (TMR4CAPH, 0xCB);                  // Timer/Counter 4 Capture High
 146      =1  SFR (TMR2L, 0xCC);                     // Timer/Counter 2 Low
 147      =1  SFR (TMR4L, 0xCC);                     // Timer/Counter 4 Low
 148      =1  SFR (TMR2H, 0xCD);                     // Timer/Counter 2 High
 149      =1  SFR (TMR4H, 0xCD);                     // Timer/Counter 4 High
 150      =1  SFR (PCA0CPL5, 0xCE);                  // PCA0 Capture 5 Low
 151      =1  SFR (PCA1CPL11, 0xCE);                 // PCA1 Capture 11 Low
 152      =1  SFR (PCA0CPH5, 0xCF);                  // PCA0 Capture 5 High
 153      =1  SFR (PCA1CPH11, 0xCF);                 // PCA1 Capture 11 High
 154      =1  SFR (PSW, 0xD0);                       // Program Status Word
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 15  

 155      =1  SFR (REF0CN, 0xD1);                    // Voltage Reference Control
 156      =1  SFR (LIN0DAT, 0xD2);                   // LIN0 Data
 157      =1  SFR (LIN0ADR, 0xD3);                   // LIN0 Address
 158      =1  SFR (P0SKIP, 0xD4);                    // Port 0 Skip
 159      =1  SFR (P1SKIP, 0xD5);                    // Port 1 Skip
 160      =1  SFR (P2SKIP, 0xD6);                    // Port 2 Skip
 161      =1  SFR (P3SKIP, 0xD7);                    // Port 3 Skip
 162      =1  SFR (PCA0CN, 0xD8);                    // PCA0 Control
 163      =1  SFR (PCA1CN, 0xD8);                    // PCA1 Control
 164      =1  SFR (PCA0MD, 0xD9);                    // PCA0 Mode
 165      =1  SFR (PCA1MD, 0xD9);                    // PCA1 Mode
 166      =1  SFR (PCA0PWM, 0xD9);                   // PCA0 PWM Control
 167      =1  SFR (PCA0CPM0, 0xDA);                  // PCA0 Module 0 Mode
 168      =1  SFR (PCA1CPM6, 0xDA);                  // PCA1 Module 6 Mode
 169      =1  SFR (PCA1PWM, 0xDA);                   // PCA1 PWM Control
 170      =1  SFR (PCA0CPM1, 0xDB);                  // PCA0 Module 1  Mode
 171      =1  SFR (PCA1CPM7, 0xDB);                  // PCA1 Module 7  Mode
 172      =1  SFR (PCA0CPM2, 0xDC);                  // PCA0 Module 2  Mode
 173      =1  SFR (PCA1CPM8, 0xDC);                  // PCA1 Module 8  Mode
 174      =1  SFR (PCA0CPM3, 0xDD);                  // PCA0 Module 3  Mode
 175      =1  SFR (PCA1CPM9, 0xDD);                  // PCA1 Module 9  Mode
 176      =1  SFR (PCA0CPM4, 0xDE);                  // PCA0 Module 4  Mode
 177      =1  SFR (PCA1CPM10, 0xDE);                  // PCA1 Module 10 Mode
 178      =1  SFR (PCA0CPM5, 0xDF);                  // PCA0 Module 5  Mode
 179      =1  SFR (PCA1CPM11, 0xDF);                  // PCA1 Module 11 Mode
 180      =1  SFR (ACC, 0xE0);                       // Accumulator
 181      =1  SFR (XBR0, 0xE1);                      // Port I/O Crossbar Control 0
 182      =1  SFR (XBR1, 0xE2);                      // Port I/O Crossbar Control 1
 183      =1  SFR (CCH0CN, 0xE3);                    // Cache control
 184      =1  SFR (IT01CF, 0xE4);                    // INT0/INT1 Configuration
 185      =1  SFR (EIE1, 0xE6);                      // Extended Interrupt Enable 2
 186      =1  SFR (EIE2, 0xE7);                      // Extended Interrupt Enable 2
 187      =1  SFR (ADC0CN, 0xE8);                    // ADC0 Control
 188      =1  SFR (PCA0CPL1, 0xE9);                  // PCA0 Capture 1 Low
 189      =1  SFR (PCA1CPL1, 0xE9);                  // PCA1 Capture 7 Low
 190      =1  SFR (PCA0CPH1, 0xEA);                  // PCA0 Capture 1 High
 191      =1  SFR (PCA1CPH1, 0xEA);                  // PCA1 Capture 7 High
 192      =1  SFR (PCA0CPL2, 0xEB);                  // PCA0 Capture 2 Low
 193      =1  SFR (PCA1CPL2, 0xEB);                  // PCA1 Capture 8 Low
 194      =1  SFR (PCA0CPH2, 0xEC);                  // PCA0 Capture 2 High
 195      =1  SFR (PCA1CPH2, 0xEC);                  // PCA1 Capture 8 High
 196      =1  SFR (PCA0CPL3, 0xED);                  // PCA0 Capture 3 Low
 197      =1  SFR (PCA1CPL3, 0xED);                  // PCA1 Capture 9 Low
 198      =1  SFR (PCA0CPH3, 0xEE);                  // PCA0 Capture 3 High
 199      =1  SFR (PCA1CPH3, 0xEE);                  // PCA1 Capture 9 High
 200      =1  SFR (RSTSRC, 0xEF);                    // Reset Source Configuration/Status
 201      =1  SFR (B, 0xF0);                         // B Register
 202      =1  SFR (P0MAT, 0xF1);                     // Port 0 Match
 203      =1  SFR (P0MDIN, 0xF1);                    // Port 0 Input Mode
 204      =1  SFR (P0MASK, 0xF2);                    // Port 0 Mask
 205      =1  SFR (P1MDIN, 0xF2);                    // Port 1 Input Mode
 206      =1  SFR (P1MAT, 0xF3);                     // Port 1 Match
 207      =1  SFR (P2MDIN, 0xF3);                    // Port 2 Input Mode
 208      =1  SFR (P1MASK, 0xF4);                    // Port 1 Mask
 209      =1  SFR (P3MDIN, 0xF4);                    // Port 3 Input Mode
 210      =1  SFR (PSBANK, 0xF5);                    // Program Space Bank Select
 211      =1  SFR (EIP1, 0xF6);                      // External Interrupt Priority 1
 212      =1  SFR (EIP2, 0xF7);                      // External Interrupt Priority 2
 213      =1  SFR (SPI0CN, 0xF8);                    // SPI0 Control
 214      =1  SFR (PCA0L, 0xF9);                     // PCA0 Counter Low
 215      =1  SFR (PCA1L, 0xF9);                     // PCA1 Counter Low
 216      =1  SFR (SN0, 0xF9);                       // Serial Number 0
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 16  

 217      =1  SFR (PCA0H, 0xFA);                     // PCA0 Counter High
 218      =1  SFR (PCA1H, 0xFA);                     // PCA1 Counter High
 219      =1  SFR (SN1, 0xFA);                       // Serial Number 1
 220      =1  SFR (PCA0CPL0, 0xFB);                  // PCA0 Capture 0 Low
 221      =1  SFR (PCA1CPL6, 0xFB);                  // PCA1 Capture 6 Low
 222      =1  SFR (SN2, 0xFB);                       // Serial Number 2
 223      =1  SFR (PCA0CPH0, 0xFC);                  // PCA0 Capture 0 High
 224      =1  SFR (PCA1CPH6, 0xFC);                  // PCA1 Capture 6 High
 225      =1  SFR (SN3, 0xFC);                       // Serial Number 3
 226      =1  SFR (PCA0CPL4, 0xFD);                  // PCA0 Capture 4 Low
 227      =1  SFR (PCA1CPL10, 0xFD);                 // PCA1 Capture 10 Low
 228      =1  SFR (PCA0CPH4, 0xFE);                  // PCA0 Capture 4 High
 229      =1  SFR (PCA1CPH10, 0xFE);                 // PCA1 Capture 10 High
 230      =1  SFR (VDM0CN, 0xFF);                    // VDD Monitor Control
 231      =1  
 232      =1  //-----------------------------------------------------------------------------
 233      =1  // Page C (CAN0) Registers
 234      =1  //-----------------------------------------------------------------------------
 235      =1  
 236      =1  SFR (CAN0CFG, 0x92);                   // CAN0 Clock Configuration
 237      =1  SFR (CAN0STAT, 0x94);                  // Status Register Low Byte
 238      =1  SFR (CAN0ERRL, 0x96);                  // Error Counter Low Byte
 239      =1  SFR (CAN0ERRH, 0x97);                  // Error Counter High Byte
 240      =1  SFR (CAN0BTL, 0x9A);                   // Bit Timing Register Low Byte
 241      =1  SFR (CAN0BTH, 0x9B);                   // Bit Timing Register High Byte
 242      =1  SFR (CAN0IIDL, 0x9C);                  // Interrupt Register Low Byte
 243      =1  SFR (CAN0IIDH, 0x9D);                  // Interrupt Register High Byte
 244      =1  SFR (CAN0TST, 0x9E);                   // Test Register Low Byte
 245      =1  SFR (CAN0BRPE, 0xA1);                  // BRP Extension Register Low Byte
 246      =1  SFR (CAN0TR1L, 0xA2);                  // Transmission Request 1 Low Byte
 247      =1  SFR (CAN0TR1H, 0xA3);                  // Transmission Request 1 High Byte
 248      =1  SFR (CAN0TR2L, 0xA4);                  // Transmission Request 2 Low Byte
 249      =1  SFR (CAN0TR2H, 0xA5);                  // Transmission Request 2 High Byte
 250      =1  SFR (CAN0ND1L, 0xAA);                  // New Data 1 Low Byte
 251      =1  SFR (CAN0ND1H, 0xAB);                  // New Data 1 High Byte
 252      =1  SFR (CAN0ND2L, 0xAC);                  // New Data 2 Low Byte
 253      =1  SFR (CAN0ND2H, 0xAD);                  // New Data 2 High Byte
 254      =1  SFR (CAN0IP1L, 0xAE);                  // Interrupt Pending 1 Low Byte
 255      =1  SFR (CAN0IP1H, 0xAF);                  // Interrupt Pending 1 High Byte
 256      =1  SFR (CAN0IP2L, 0xB2);                  // Interrupt Pending 2 Low Byte
 257      =1  SFR (CAN0IP2H, 0xB3);                  // Interrupt Pending 2 High Byte
 258      =1  SFR (CAN0MV1L, 0xBA);                  // Message Valid 1 Low Byte
 259      =1  SFR (CAN0MV1H, 0xBB);                  // Message Valid 1 High Byte
 260      =1  SFR (CAN0MV2L, 0xBC);                  // Message Valid 2 Low Byte
 261      =1  SFR (CAN0MV2H, 0xBD);                  // Message Valid 2 High Byte
 262      =1  SFR (CAN0IF1CRL, 0xBE);                // IF1 Command Request Low Byte
 263      =1  SFR (CAN0IF1CRH, 0xBF);                // IF1 Command Request High Byte
 264      =1  SFR (CAN0CN, 0xC0);                    // CAN Control Register Low Byte
 265      =1  SFR (CAN0IF1CML, 0xC2);                // IF1 Command Mask Low Byte
 266      =1  SFR (CAN0IF1CMH, 0xC3);                // IF1 Command Mask High Byte
 267      =1  SFR (CAN0IF1M1L, 0xC4);                // IF1 Mask 1 Low Byte
 268      =1  SFR (CAN0IF1M1H, 0xC5);                // IF1 Mask 1 High Byte
 269      =1  SFR (CAN0IF1M2L, 0xC6);                // IF1 Mask 2 Low Byte
 270      =1  SFR (CAN0IF1M2H, 0xC7);                // IF1 Mask 2 High Byte
 271      =1  SFR (CAN0IF1A1L, 0xCA);                // IF1 Arbitration 1 Low Byte
 272      =1  SFR (CAN0IF1A1H, 0xCB);                // IF1 Arbitration 1 High Byte
 273      =1  SFR (CAN0IF1A2L, 0xCC);                // IF1 Arbitration 2 Low Byte
 274      =1  SFR (CAN0IF1A2H, 0xCD);                // IF1 Arbitration 2 High Byte
 275      =1  SFR (CAN0IF2MCL, 0xCE);                // IF2 Message Control Low Byte
 276      =1  SFR (CAN0IF2MCH, 0xCF);                // IF2 Message Control High Byte
 277      =1  SFR (CAN0IF1MCL, 0xD2);                // IF1 Message Control Low Byte
 278      =1  SFR (CAN0IF1MCH, 0xD3);                // IF1 Message Control High Byte
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 17  

 279      =1  SFR (CAN0IF1DA1L, 0xD4);               // IF1 Data A 1 Low Byte
 280      =1  SFR (CAN0IF1DA1H, 0xD5);               // IF1 Data A 1 High Byte
 281      =1  SFR (CAN0IF1DA2L, 0xD6);               // IF1 Data A 2 Low Byte
 282      =1  SFR (CAN0IF1DA2H, 0xD7);               // IF1 Data A 2 High Byte
 283      =1  SFR (CAN0IF1DB1L, 0xDA);               // IF1 Data B 1 Low Byte
 284      =1  SFR (CAN0IF1DB1H, 0xDB);               // IF1 Data B 1 High Byte
 285      =1  SFR (CAN0IF1DB2L, 0xDC);               // IF1 Data B 2 Low Byte
 286      =1  SFR (CAN0IF1DB2H, 0xDD);               // IF1 Data B 2 High Byte
 287      =1  SFR (CAN0IF2CRL, 0xDE);                // IF2 Command Request Low Byte
 288      =1  SFR (CAN0IF2CRH, 0xDF);                // IF2 Command Request High Byte
 289      =1  SFR (CAN0IF2CML, 0xE2);                // IF2 Command Mask Low Byte
 290      =1  SFR (CAN0IF2CMH, 0xE3);                // IF2 Command Mask High Byte
 291      =1  SFR (CAN0IF2M1L, 0xEA);                // IF2 Mask 1 Low Byte
 292      =1  SFR (CAN0IF2M1H, 0xEB);                // IF2 Mask 1 High Byte
 293      =1  SFR (CAN0IF2M2L, 0xEC);                // IF2 Mask 2 Low Byte
 294      =1  SFR (CAN0IF2M2H, 0xED);                // IF2 Mask 2 High Byte
 295      =1  SFR (CAN0IF2A1L, 0xEE);                // IF2 Arbitration 1 Low Byte
 296      =1  SFR (CAN0IF2A1H, 0xEF);                // IF2 Arbitration 1 High Byte
 297      =1  SFR (CAN0IF2A2L, 0xF2);                // IF2 Arbitration 2 Low Byte
 298      =1  SFR (CAN0IF2A2H, 0xF3);                // IF2 Arbitration 2 High Byte
 299      =1  SFR (CAN0IF2DA1L, 0xF6);               // IF2 Data A 1 Low Byte
 300      =1  SFR (CAN0IF2DA1H, 0xF7);               // IF2 Data A 1 High Byte
 301      =1  SFR (CAN0IF2DA2L, 0xFA);               // IF2 Data A 2 Low Byte
 302      =1  SFR (CAN0IF2DA2H, 0xFB);               // IF2 Data A 2 High Byte
 303      =1  SFR (CAN0IF2DB1L, 0xFC);               // IF2 Data B 1 Low Byte
 304      =1  SFR (CAN0IF2DB1H, 0xFD);               // IF2 Data B 1 High Byte
 305      =1  SFR (CAN0IF2DB2L, 0xFE);               // IF2 Data B 2 Low Byte
 306      =1  SFR (CAN0IF2DB2H, 0xFF);               // IF2 Data B 2 High Byte
 307      =1  
 308      =1  
 309      =1  //-----------------------------------------------------------------------------
 310      =1  // 16-bit Register Definitions (might not be supported by all compilers)
 311      =1  //-----------------------------------------------------------------------------
 312      =1  
 313      =1  SFR16 (DP, 0x82);                      // Data Pointer
 314      =1  SFR16 (TMR3RL, 0x92);                  // Timer 3 Reload
 315      =1  SFR16 (TMR5CAP, 0x92);                 // Timer 5 Capture
 316      =1  SFR16 (TMR3, 0x94);                    // Timer 3 Capture / Reload
 317      =1  SFR16 (TMR5, 0x94);                    // Timer 5
 318      =1  SFR16 (SBRL0, 0xAC);                   // UART0 Reload
 319      =1  SFR16 (ADC0, 0xBD);                    // ADC0 data
 320      =1  SFR16 (ADC0GT, 0xC3);                  // ADC0 Greater Than Window
 321      =1  SFR16 (ADC0LT, 0xC5);                  // ADC0 Less Than Window
 322      =1  SFR16 (TMR2RL, 0xCA);                  // Timer 2 Reload
 323      =1  SFR16 (TMR4CAP, 0xCA);                 // Timer 4 Capture
 324      =1  SFR16 (TMR2, 0xCC);                    // Timer 2 Capture / Reload
 325      =1  SFR16 (TMR4, 0xCC);                    // Timer 4
 326      =1  SFR16 (PCA0CP5, 0xCE);                 // PCA0 Module 5 Capture
 327      =1  SFR16 (PCA1CP11, 0xCE);                // PCA1 Module 11 Capture
 328      =1  SFR16 (PCA0CP1, 0xE9);                 // PCA0 Module 1 Capture
 329      =1  SFR16 (PCA1CP7, 0xE9);                 // PCA1 Module 7 Capture
 330      =1  SFR16 (PCA0CP2, 0xEB);                 // PCA0 Module 2 Capture
 331      =1  SFR16 (PCA1CP8, 0xEB);                 // PCA1 Module 8 Capture
 332      =1  SFR16 (PCA0CP3, 0xED);                 // PCA0 Module 3 Capture
 333      =1  SFR16 (PCA1CP9, 0xED);                 // PCA1 Module 9 Capture
 334      =1  SFR16 (PCA0, 0xF9);                    // PCA0 Counter
 335      =1  SFR16 (PCA1, 0xF9);                    // PCA1 Counter
 336      =1  SFR16 (PCA0CP0, 0xFB);                 // PCA0 Module 0 Capture
 337      =1  SFR16 (PCA1CP6, 0xFB);                 // PCA1 Module 6 Capture
 338      =1  SFR16 (PCA0CP4, 0xFD);                 // PCA0 Module 4 Capture
 339      =1  SFR16 (PCA1CP10, 0xFD);                 // PCA1 Module 10 Capture
 340      =1  
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 18  

 341      =1  SFR16 (CAN0ERR, 0x96);                 // Error Counter
 342      =1  SFR16 (CAN0BT, 0x9A);                  // Bit Timing Register
 343      =1  SFR16 (CAN0IID, 0x9C);                 // Interrupt Register
 344      =1  SFR16 (CAN0TR1, 0xA2);                 // Transmission Request 1
 345      =1  SFR16 (CAN0TR2, 0xA4);                 // Transmission Request 2
 346      =1  SFR16 (CAN0ND1, 0xAA);                 // New Data 1
 347      =1  SFR16 (CAN0ND2, 0xAC);                 // New Data 2
 348      =1  SFR16 (CAN0IP1, 0xAE);                 // Interrupt Pending 1
 349      =1  SFR16 (CAN0IP2, 0xB2);                 // Interrupt Pending 2
 350      =1  SFR16 (CAN0MV1, 0xBA);                 // Message Valid 1
 351      =1  SFR16 (CAN0MV2, 0xBC);                 // Message Valid 2
 352      =1  SFR16 (CAN0IF1CR, 0xBE);               // IF1 Command Request
 353      =1  SFR16 (CAN0IF1CM, 0xC2);               // IF1 Command Mask
 354      =1  SFR16 (CAN0IF1M1, 0xC4);               // IF1 Mask 1
 355      =1  SFR16 (CAN0IF1M2, 0xC6);               // IF1 Mask 2
 356      =1  SFR16 (CAN0IF1A1, 0xCA);               // IF1 Arbitration 1
 357      =1  SFR16 (CAN0IF1A2, 0xCC);               // IF1 Arbitration 2
 358      =1  SFR16 (CAN0IF1MC, 0xD2);               // IF1 Message Control
 359      =1  SFR16 (CAN0IF1DA1, 0xD4);              // IF1 Data A 1
 360      =1  SFR16 (CAN0IF1DA2, 0xD6);              // IF1 Data A 2
 361      =1  SFR16 (CAN0IF1DB1, 0xDA);              // IF1 Data B 1
 362      =1  SFR16 (CAN0IF1DB2, 0xDC);              // IF1 Data B 2
 363      =1  SFR16 (CAN0IF2CR, 0xDE);               // IF2 Command Request
 364      =1  SFR16 (CAN0IF2CM, 0xE2);               // IF2 Command Mask
 365      =1  SFR16 (CAN0IF2M1, 0xEA);               // IF2 Mask 1
 366      =1  SFR16 (CAN0IF2M2, 0xEC);               // IF2 Mask 2
 367      =1  SFR16 (CAN0IF2A1, 0xEE);               // IF2 Arbitration 1
 368      =1  SFR16 (CAN0IF2A2, 0xF2);               // IF2 Arbitration 2
 369      =1  SFR16 (CAN0IF2MC, 0xCE);               // IF2 Message Control
 370      =1  SFR16 (CAN0IF2DA1, 0xF6);              // IF2 Data A 1
 371      =1  SFR16 (CAN0IF2DA2, 0xFA);              // IF2 Data A 2
 372      =1  SFR16 (CAN0IF2DB1, 0xFC);              // IF2 Data B 1
 373      =1  SFR16 (CAN0IF2DB2, 0xFE);              // IF2 Data B 2
 374      =1  
 375      =1  //-----------------------------------------------------------------------------
 376      =1  // LIN0 Indirect Registers
 377      =1  //-----------------------------------------------------------------------------
 378      =1  
 379      =1  #define  LIN0DT1   0x00                // LIN0 Data Byte 1
 380      =1  #define  LIN0DT2   0x01                // LIN0 Data Byte 2
 381      =1  #define  LIN0DT3   0x02                // LIN0 Data Byte 3
 382      =1  #define  LIN0DT4   0x03                // LIN0 Data Byte 4
 383      =1  #define  LIN0DT5   0x04                // LIN0 Data Byte 5
 384      =1  #define  LIN0DT6   0x05                // LIN0 Data Byte 6
 385      =1  #define  LIN0DT7   0x06                // LIN0 Data Byte 7
 386      =1  #define  LIN0DT8   0x07                // LIN0 Data Byte 8
 387      =1  #define  LIN0CTRL  0x08                // LIN0 Control
 388      =1  #define  LIN0ST    0x09                // LIN0 Status
 389      =1  #define  LIN0ERR   0x0A                // LIN0 Error
 390      =1  #define  LIN0SIZE  0x0B                // LIN0 Message Size
 391      =1  #define  LIN0DIV   0x0C                // LIN0 Divider
 392      =1  #define  LIN0MUL   0x0D                // LIN0 Multiplier
 393      =1  #define  LIN0ID    0x0E                // LIN0 Identifier
 394      =1  
 395      =1  //-----------------------------------------------------------------------------
 396      =1  // Address Definitions for Bit-addressable Registers
 397      =1  //-----------------------------------------------------------------------------
 398      =1  
 399      =1  #define SFR_P0       0x80
 400      =1  #define SFR_TCON     0x88
 401      =1  #define SFR_P1       0x90
 402      =1  #define SFR_SCON0    0x98
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 19  

 403      =1  #define SFR_SCON1    0x98
 404      =1  #define SFR_P2       0xA0
 405      =1  #define SFR_IE       0xA8
 406      =1  #define SFR_P3       0xB0
 407      =1  #define SFR_IP       0xB8
 408      =1  #define SFR_SMB0CN   0xC0
 409      =1  #define SFR_TMR2CN   0xC8
 410      =1  #define SFR_TMR4CN   0xC8
 411      =1  #define SFR_PSW      0xD0
 412      =1  #define SFR_PCA0CN   0xD8
 413      =1  #define SFR_PCA1CN   0xD8
 414      =1  #define SFR_ACC      0xE0
 415      =1  #define SFR_ADC0CN   0xE8
 416      =1  #define SFR_B        0xF0
 417      =1  #define SFR_SPI0CN   0xF8
 418      =1  
 419      =1  //-----------------------------------------------------------------------------
 420      =1  // Bit Definitions
 421      =1  //-----------------------------------------------------------------------------
 422      =1  
 423      =1  // TCON 0x88
 424      =1  SBIT (TF1, SFR_TCON, 7);               // Timer 1 Overflow Flag
 425      =1  SBIT (TR1, SFR_TCON, 6);               // Timer 1 On/Off Control
 426      =1  SBIT (TF0, SFR_TCON, 5);               // Timer 0 Overflow Flag
 427      =1  SBIT (TR0, SFR_TCON, 4);               // Timer 0 On/Off Control
 428      =1  SBIT (IE1, SFR_TCON, 3);               // Ext. Interrupt 1 Edge Flag
 429      =1  SBIT (IT1, SFR_TCON, 2);               // Ext. Interrupt 1 Type
 430      =1  SBIT (IE0, SFR_TCON, 1);               // Ext. Interrupt 0 Edge Flag
 431      =1  SBIT (IT0, SFR_TCON, 0);               // Ext. Interrupt 0 Type
 432      =1  
 433      =1  // SCON0 0x98
 434      =1  SBIT (OVR0, SFR_SCON0, 7);             // UART0 Receive FIFO Overrun Flag
 435      =1  SBIT (PERR0, SFR_SCON0, 6);            // UART0 Parity Error Flag
 436      =1  SBIT (THRE0, SFR_SCON0, 5);            // UART0 Transmit Register Empty Flag
 437      =1  SBIT (REN0, SFR_SCON0, 4);             // UART0 RX Enable
 438      =1  SBIT (TBX0, SFR_SCON0, 3);             // UART0 Extra Transmission Bit
 439      =1  SBIT (RBX0, SFR_SCON0, 2);             // UART0 Extra Receive Bit
 440      =1  SBIT (TI0, SFR_SCON0, 1);              // UART0 TX Interrupt Flag
 441      =1  SBIT (RI0, SFR_SCON0, 0);              // UART0 RX Interrupt Flag
 442      =1  
 443      =1  // SCON1 0x98
 444      =1  SBIT (S1MODE, SFR_SCON1, 7);           // UART1 Mode 0
 445      =1                                         // Bit 6 UNUSED
 446      =1  SBIT (MCE1, SFR_SCON1, 5);             // UART1 Multiprocessor enable
 447      =1  SBIT (REN1, SFR_SCON1, 4);             // UART1 RX Enable
 448      =1  SBIT (TB81, SFR_SCON1, 3);             // UART1 TX Bit 8
 449      =1  SBIT (RB81, SFR_SCON1, 2);             // UART1 RX Bit 8
 450      =1  SBIT (TI1, SFR_SCON1, 1);              // UART1 TX Interrupt Flag
 451      =1  SBIT (RI1, SFR_SCON1, 0);              // UART1 RX Interrupt Flag
 452      =1  
 453      =1  // IE 0xA8
 454      =1  SBIT (EA, SFR_IE, 7);                  // Global Interrupt Enable
 455      =1  SBIT (ESPI0, SFR_IE, 6);               // SPI0 Interrupt Enable
 456      =1  SBIT (ET2, SFR_IE, 5);                 // Timer 2 Interrupt Enable
 457      =1  SBIT (ES0, SFR_IE, 4);                 // UART0 Interrupt Enable
 458      =1  SBIT (ET1, SFR_IE, 3);                 // Timer 1 Interrupt Enable
 459      =1  SBIT (EX1, SFR_IE, 2);                 // External Interrupt 1 Enable
 460      =1  SBIT (ET0, SFR_IE, 1);                 // Timer 0 Interrupt Enable
 461      =1  SBIT (EX0, SFR_IE, 0);                 // External Interrupt 0 Enable
 462      =1  
 463      =1  // IP 0xB8
 464      =1                                         // Bit 7 unused
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 20  

 465      =1  SBIT (PSPI0, SFR_IP, 6);               // SPI0 Interrupt Priority
 466      =1  SBIT (PT2, SFR_IP, 5);                 // Timer 2 Priority
 467      =1  SBIT (PS0, SFR_IP, 4);                 // UART0 Priority
 468      =1  SBIT (PS, SFR_IP, 4);                  // UART0 Priority
 469      =1  SBIT (PT1, SFR_IP, 3);                 // Timer 1 Priority
 470      =1  SBIT (PX1, SFR_IP, 2);                 // External Interrupt 1 Priority
 471      =1  SBIT (PT0, SFR_IP, 1);                 // Timer 0 Priority
 472      =1  SBIT (PX0, SFR_IP, 0);                 // External Interrupt 0 Priority
 473      =1  
 474      =1  // SMB0CN 0xC0
 475      =1  SBIT (MASTER, SFR_SMB0CN, 7);          // SMBus0 Master/Slave Indicator
 476      =1  SBIT (TXMODE, SFR_SMB0CN, 6);          // SMBus0 Transmit Mode Indicator
 477      =1  SBIT (STA, SFR_SMB0CN, 5);             // SMBus0 Start Flag
 478      =1  SBIT (STO, SFR_SMB0CN, 4);             // SMBus0 Stop Flag
 479      =1  SBIT (ACKRQ, SFR_SMB0CN, 3);           // SMBus0 Acknowledge Request
 480      =1  SBIT (ARBLOST, SFR_SMB0CN, 2);         // SMBus0 Arbitration Lost Indicator
 481      =1  SBIT (ACK, SFR_SMB0CN, 1);             // SMBus0 Acknowledge
 482      =1  SBIT (SI, SFR_SMB0CN, 0);              // SMBus0 Interrupt Flag
 483      =1  
 484      =1  // TMR2CN 0xC8
 485      =1  SBIT (TF2H, SFR_TMR2CN, 7);            // Timer 2 High-Byte Overflow Flag
 486      =1  SBIT (TF2L, SFR_TMR2CN, 6);            // Timer 2 Low-Byte  Overflow Flag
 487      =1  SBIT (TF2LEN, SFR_TMR2CN, 5);          // Timer 2 Low-Byte Flag Enable
 488      =1  SBIT (TF2CEN, SFR_TMR2CN, 4);          // Timer 2 Capture Enable
 489      =1  SBIT (T2SPLIT, SFR_TMR2CN, 3);         // Timer 2 Split-Mode Enable
 490      =1  SBIT (TR2, SFR_TMR2CN, 2);             // Timer 2 Run Enable
 491      =1  SBIT (T2RCLK, SFR_TMR2CN, 1);          // Timer 2 Xclk/Rclk Select
 492      =1  SBIT (T2XCLK, SFR_TMR2CN, 0);          // Timer 2 Clk/8 Clock Source
 493      =1  
 494      =1  // TMR4CN 0xC8
 495      =1  SBIT (TF4, SFR_TMR4CN, 7);             // Timer 4 Overflow/Underflow Flag
 496      =1  SBIT (EXF4, SFR_TMR4CN, 6);            // Timer 4 External Flag
 497      =1                                         // Bit 5 unused
 498      =1                                         // Bit 4 unused
 499      =1  SBIT (EXE4, SFR_TMR4CN, 3);            // Timer 4 External Enable
 500      =1  SBIT (TR4, SFR_TMR4CN, 2);             // Timer 4 Run Enable
 501      =1  SBIT (CT4, SFR_TMR4CN, 1);             // Timer 4 Counter/Timer Select
 502      =1  SBIT (CPRL4, SFR_TMR4CN, 0);           // Timer 4 Capture/Reload Select
 503      =1  
 504      =1  // PSW 0xD0
 505      =1  SBIT (CY, SFR_PSW, 7);                 // Carry Flag
 506      =1  SBIT (AC, SFR_PSW, 6);                 // Auxiliary Carry Flag
 507      =1  SBIT (F0, SFR_PSW, 5);                 // User Flag 0
 508      =1  SBIT (RS1, SFR_PSW, 4);                // Register Bank Select 1
 509      =1  SBIT (RS0, SFR_PSW, 3);                // Register Bank Select 0
 510      =1  SBIT (OV, SFR_PSW, 2);                 // Overflow Flag
 511      =1  SBIT (F1, SFR_PSW, 1);                 // User Flag 1
 512      =1  SBIT (P, SFR_PSW, 0);                  // Accumulator Parity Flag
 513      =1  
 514      =1  // PCA0CN 0xD8
 515      =1  SBIT (CF, SFR_PCA0CN, 7);              // PCA0 Counter Overflow Flag
 516      =1  SBIT (CR, SFR_PCA0CN, 6);              // PCA0 Counter Run Control Bit
 517      =1  SBIT (CCF5, SFR_PCA0CN, 5);            // PCA0 Module 5 Interrupt Flag
 518      =1  SBIT (CCF4, SFR_PCA0CN, 4);            // PCA0 Module 4 Interrupt Flag
 519      =1  SBIT (CCF3, SFR_PCA0CN, 3);            // PCA0 Module 3 Interrupt Flag
 520      =1  SBIT (CCF2, SFR_PCA0CN, 2);            // PCA0 Module 2 Interrupt Flag
 521      =1  SBIT (CCF1, SFR_PCA0CN, 1);            // PCA0 Module 1 Interrupt Flag
 522      =1  SBIT (CCF0, SFR_PCA0CN, 0);            // PCA0 Module 0 Interrupt Flag
 523      =1  
 524      =1  // PCA1CN 0xD8
 525      =1  SBIT (CF1, SFR_PCA1CN, 7);             // PCA1 Counter Overflow Flag
 526      =1  SBIT (CR1, SFR_PCA1CN, 6);             // PCA1 Counter Run Control Bit
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 21  

 527      =1  SBIT (CCF11, SFR_PCA1CN, 5);           // PCA1 Module 11 Interrupt Flag
 528      =1  SBIT (CCF10, SFR_PCA1CN, 4);           // PCA1 Module 10 Interrupt Flag
 529      =1  SBIT (CCF9, SFR_PCA1CN, 3);            // PCA1 Module 9 Interrupt Flag
 530      =1  SBIT (CCF8, SFR_PCA1CN, 2);            // PCA1 Module 8 Interrupt Flag
 531      =1  SBIT (CCF7, SFR_PCA1CN, 1);            // PCA1 Module 7 Interrupt Flag
 532      =1  SBIT (CCF6, SFR_PCA1CN, 0);            // PCA1 Module 6 Interrupt Flag
 533      =1  
 534      =1  // ADC0CN 0xE8
 535      =1  SBIT (AD0EN, SFR_ADC0CN, 7);           // ADC0 Enable
 536      =1  SBIT (BURSTEN, SFR_ADC0CN, 6);         // ADC0 Burst Enable
 537      =1  SBIT (AD0INT, SFR_ADC0CN, 5);          // ADC0 EOC Interrupt Flag
 538      =1  SBIT (AD0BUSY, SFR_ADC0CN, 4);         // ADC0 Busy Flag
 539      =1  SBIT (AD0WINT, SFR_ADC0CN, 3);         // ADC0 Window Compare Interrupt Flag
 540      =1  SBIT (AD0LJST, SFR_ADC0CN, 2);         // ADC0 Left Justified
 541      =1  SBIT (AD0CM1, SFR_ADC0CN, 1);          // ADC0 Start Of Conversion Mode Bit 1
 542      =1  SBIT (AD0CM0, SFR_ADC0CN, 0);          // ADC0 Start Of Conversion Mode Bit 0
 543      =1  
 544      =1  // SPI0CN 0xF8
 545      =1  SBIT (SPIF, SFR_SPI0CN, 7);            // SPI0 Interrupt Flag
 546      =1  SBIT (WCOL, SFR_SPI0CN, 6);            // SPI0 Write Collision Flag
 547      =1  SBIT (MODF, SFR_SPI0CN, 5);            // SPI0 Mode Fault Flag
 548      =1  SBIT (RXOVRN, SFR_SPI0CN, 4);          // SPI0 RX Overrun Flag
 549      =1  SBIT (NSSMD1, SFR_SPI0CN, 3);          // SPI0 Slave Select Mode 1
 550      =1  SBIT (NSSMD0, SFR_SPI0CN, 2);          // SPI0 Slave Select Mode 0
 551      =1  SBIT (TXBMT, SFR_SPI0CN, 1);           // SPI0 TX Buffer Empty Flag
 552      =1  SBIT (SPIEN, SFR_SPI0CN, 0);           // SPI0 Enable
 553      =1  
 554      =1  //-----------------------------------------------------------------------------
 555      =1  // Interrupt Priorities
 556      =1  //-----------------------------------------------------------------------------
 557      =1  
 558      =1  #define INTERRUPT_INT0             0   // External Interrupt 0
 559      =1  #define INTERRUPT_TIMER0           1   // Timer 0 Overflow
 560      =1  #define INTERRUPT_INT1             2   // External Interrupt 1
 561      =1  #define INTERRUPT_TIMER1           3   // Timer 1 Overflow
 562      =1  #define INTERRUPT_UART0            4   // UART0
 563      =1  #define INTERRUPT_TIMER2           5   // Timer 2 Overflow
 564      =1  #define INTERRUPT_SPI0             6   // SPI0
 565      =1  #define INTERRUPT_SMBUS0           7   // SMBus0 Interface
 566      =1  #define INTERRUPT_ADC0_WINDOW      8   // ADC0 Window Comparison
 567      =1  #define INTERRUPT_ADC0_EOC         9   // ADC0 End Of Conversion
 568      =1  #define INTERRUPT_PCA0            10   // PCA0 Peripheral
 569      =1  #define INTERRUPT_COMPARATOR0     11   // Comparator 0 Comparison
 570      =1  #define INTERRUPT_COMPARATOR1     12   // Comparator 1 Comparison
 571      =1  #define INTERRUPT_TIMER3          13   // Timer 3 Overflow
 572      =1  #define INTERRUPT_LIN0            14   // LIN Bus Interrupt
 573      =1  #define INTERRUPT_VREG            15   // Voltage Regulator
 574      =1  #define INTERRUPT_CAN0            16   // CAN Bus Interrupt
 575      =1  #define INTERRUPT_PORT_MATCH      17   // Port Match
 576      =1  #define INTERRUPT_UART1           18   // UART1
 577      =1  #define INTERRUPT_PCA1            19   // PCA1 Peripheral
 578      =1  #define INTERRUPT_COMPARATOR2     20   // Comparator 2 Comparison
 579      =1  #define INTERRUPT_TIMER4          21   // Timer 4 Overflow
 580      =1  #define INTERRUPT_TIMER5          22   // Timer 5 Overflow
 581      =1  
 582      =1  
 583      =1  //-----------------------------------------------------------------------------
 584      =1  // SFR Page Definitions
 585      =1  //-----------------------------------------------------------------------------
 586      =1  
 587      =1  #define  CONFIG_PAGE       0x0F        // System and Port Configuration Page
 588      =1  #define  ACTIVE_PAGE       0x00        // Active Use Page
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 22  

 589      =1  #define  ACTIVE2_PAGE      0x10        // Active Use Page 2
 590      =1  #define  CAN0_PAGE         0x0C        // CAN0 Registers
 591      =1  
 592      =1  //-----------------------------------------------------------------------------
 593      =1  // SDCC PDATA External Memory Paging Support
 594      =1  //-----------------------------------------------------------------------------
 595      =1  
 596      =1  #if defined SDCC
           =1 
           =1 SFR(_XPAGE, 0xAA); // Point to the EMI0CN register
           =1 
           =1 #endif
 601      =1  
 602      =1  //-----------------------------------------------------------------------------
 603      =1  // Header File PreProcessor Directive
 604      =1  //-----------------------------------------------------------------------------
 605      =1  
 606      =1  #endif                                 // #define C8051F580_DEFS_H
 607      =1  
 608      =1  //-----------------------------------------------------------------------------
 609      =1  // End Of File
 610      =1  //-----------------------------------------------------------------------------
   3          #include <stdio.h>
   1      =1  /*--------------------------------------------------------------------------
   2      =1  STDIO.H
   3      =1  
   4      =1  Prototypes for standard I/O functions.
   5      =1  Copyright (c) 1988-2002 Keil Elektronik GmbH and Keil Software, Inc.
   6      =1  All rights reserved.
   7      =1  --------------------------------------------------------------------------*/
   8      =1  
   9      =1  #ifndef __STDIO_H__
  10      =1  #define __STDIO_H__
  11      =1  
  12      =1  #ifndef EOF
  13      =1   #define EOF -1
  14      =1  #endif
  15      =1  
  16      =1  #ifndef NULL
  17      =1   #define NULL ((void *) 0)
  18      =1  #endif
  19      =1  
  20      =1  #ifndef _SIZE_T
  21      =1   #define _SIZE_T
  22      =1   typedef unsigned int size_t;
  23      =1  #endif
  24      =1  
  25      =1  #pragma SAVE
  26      =1  #pragma REGPARMS
  27      =1  extern char _getkey (void);
  28      =1  extern char getchar (void);
  29      =1  extern char ungetchar (char);
  30      =1  extern char putchar (char);
  31      =1  extern int printf   (const char *, ...);
  32      =1  extern int sprintf  (char *, const char *, ...);
  33      =1  extern int vprintf  (const char *, char *);
  34      =1  extern int vsprintf (char *, const char *, char *);
  35      =1  extern char *gets (char *, int n);
  36      =1  extern int scanf (const char *, ...);
  37      =1  extern int sscanf (char *, const char *, ...);
  38      =1  extern int puts (const char *);
  39      =1  
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 23  

  40      =1  #pragma RESTORE
  41      =1  
  42      =1  #endif
  43      =1  
   4          #include  "Tick.h"
   1      =1  #ifndef TICK_H_
   2      =1  #define TICK_H_
   3      =1  #include <compiler_defs.h>
   1      =2  //-----------------------------------------------------------------------------
   2      =2  // compiler_defs.h
   3      =2  //-----------------------------------------------------------------------------
   4      =2  // Portions of this file are copyright Maarten Brock
   5      =2  // http://sdcc.sourceforge.net
   6      =2  // Portions of this file are copyright 2010, Silicon Laboratories, Inc.
   7      =2  // http://www.silabs.com
   8      =2  //
   9      =2  // GNU LGPL boilerplate:
  10      =2  /** This library is free software; you can redistribute it and/or
  11      =2    * modify it under the terms of the GNU Lesser General Public
  12      =2    * License as published by the Free Software Foundation; either
  13      =2    * version 2.1 of the License, or (at your option) any later version.
  14      =2    *
  15      =2    * This library is distributed in the hope that it will be useful,
  16      =2    * but WITHOUT ANY WARRANTY; without even the implied warranty of
  17      =2    * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  18      =2    * Lesser General Public License for more details.
  19      =2    *
  20      =2    * You should have received a copy of the GNU Lesser General Public
  21      =2    * License along with this library; if not, write to the Free Software
  22      =2    * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  23      =2    *
  24      =2    * In other words, you are welcome to use, share and improve this program.
  25      =2    * You are forbidden to forbid anyone else to use, share and improve
  26      =2    * what you give them. Help stamp out software-hoarding!
  27      =2  **/
  28      =2  // Program Description:
  29      =2  //
  30      =2  // **Important Note**: This header file should be included before including
  31      =2  // a device-specific header file such as C8051F300_defs.h.
  32      =2  //
  33      =2  // Macro definitions to accomodate 8051 compiler differences in specifying
  34      =2  // special function registers and other 8051-specific features such as NOP
  35      =2  // generation, and locating variables in memory-specific segments.  The
  36      =2  // compilers are identified by their unique predefined macros. See also:
  37      =2  // http://predef.sourceforge.net/precomp.html
  38      =2  //
  39      =2  // SBIT and SFR define special bit and special function registers at the given
  40      =2  // address. SFR16 and SFR32 define sfr combinations at adjacent addresses in
  41      =2  // little-endian format. SFR16E and SFR32E define sfr combinations without
  42      =2  // prerequisite byte order or adjacency. None of these multi-byte sfr
  43      =2  // combinations will guarantee the order in which they are accessed when read
  44      =2  // or written.
  45      =2  //
  46      =2  // SFR16X and SFR32X for 16 bit and 32 bit xdata registers are not defined
  47      =2  // to avoid portability issues because of compiler endianness.
  48      =2  //
  49      =2  // Example:
  50      =2  // // my_mcu.c: main 'c' file for my mcu
  51      =2  // #include <compiler_defs.h>  // this file
  52      =2  // #include <C8051xxxx_defs.h> // SFR definitions for specific MCU target
  53      =2  //
  54      =2  // SBIT  (P0_1, 0x80, 1);      // Port 0 pin 1
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 24  

  55      =2  // SFR   (P0, 0x80);           // Port 0
  56      =2  // SFRX  (CPUCS, 0xE600);      // Cypress FX2 Control and Status register in
  57      =2  //                             // xdata memory at 0xE600
  58      =2  // SFR16 (TMR2, 0xCC);         // Timer 2, lsb at 0xCC, msb at 0xCD
  59      =2  // SFR16E(TMR0, 0x8C8A);       // Timer 0, lsb at 0x8A, msb at 0x8C
  60      =2  // SFR32 (MAC0ACC, 0x93);      // SiLabs C8051F120 32 bits MAC0 Accumulator,
  61      =2  //                             // lsb at 0x93, msb at 0x96
  62      =2  // SFR32E(SUMR, 0xE5E4E3E2);   // TI MSC1210 SUMR 32 bits Summation register,
  63      =2  //                             // lsb at 0xE2, msb at 0xE5
  64      =2  //
  65      =2  // Target:         C8051xxxx
  66      =2  // Tool chain:     Generic
  67      =2  // Command Line:   None
  68      =2  // 
  69      =2  // Release 2.6 - 14 DEC 2012 (GO)
  70      =2  //        -Added define for deprecated SDCC keyword 'at'
  71      =2  // Release 2.5 - 12 SEP 2012 (TP)
  72      =2  //    -Added defines for deprecated SDCC keywords bit and code
  73      =2  // Release 2.4 - 27 AUG 2012 (TP)
  74      =2  //    -Added defines for deprecated SDCC keywords interrupt, _asm, and _endasm
  75      =2  // Release 2.3 - 27 MAY 2010 (DM)
  76      =2  //    -Removed 'LOCATED_VARIABLE' pragma from Keil because it is not supported
  77      =2  // Release 2.2 - 06 APR 2010 (ES)
  78      =2  //    -Removed 'PATHINCLUDE' pragma from Raisonance section
  79      =2  // Release 2.1 - 16 JUL 2009 (ES)
  80      =2  //    -Added SEGMENT_POINTER macro definitions for SDCC, Keil, and Raisonance
  81      =2  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for Raisonance
  82      =2  // Release 2.0 - 19 MAY 2009 (ES)
  83      =2  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for SDCC and Keil
  84      =2  // Release 1.9 - 23 OCT 2008 (ES)
  85      =2  //    -Updated Hi-Tech INTERRUPT and INTERRUPT_USING macro definitions
  86      =2  //    -Added SFR16 macro defintion for Hi-Tech
  87      =2  // Release 1.8 - 31 JUL 2008 (ES)
  88      =2  //    -Added INTERRUPT_USING and FUNCTION_USING macro's
  89      =2  //    -Added macro's for IAR
  90      =2  //    -Corrected Union definitions for Hi-Tech and added SFR16 macro defintion
  91      =2  // Release 1.7 - 11 SEP 2007 (BW)
  92      =2  //    -Added support for Raisonance EVAL 03.03.42 and Tasking Eval 7.2r1
  93      =2  // Release 1.6 - 27 AUG 2007 (BW)
  94      =2  //    -Updated copyright notice per agreement with Maartin Brock
  95      =2  //    -Added SDCC 2.7.0 "compiler.h" bug fixes
  96      =2  //    -Added memory segment defines (SEG_XDATA, for example)
  97      =2  // Release 1.5 - 24 AUG 2007 (BW)
  98      =2  //    -Added support for NOP () macro
  99      =2  //    -Added support for Hi-Tech ver 9.01
 100      =2  // Release 1.4 - 07 AUG 2007 (PKC)
 101      =2  //    -Removed FID and fixed formatting.
 102      =2  // Release 1.3 - 30 SEP 2007 (TP)
 103      =2  //    -Added INTERRUPT_PROTO_USING to properly support ISR context switching
 104      =2  //     under SDCC.
 105      =2  // Release 1.2 - (BW)
 106      =2  //    -Added support for U8,U16,U32,S8,S16,S32,UU16,UU32 data types
 107      =2  // Release 1.1 - (BW)
 108      =2  //    -Added support for INTERRUPT, INTERRUPT_USING, INTERRUPT_PROTO,
 109      =2  //     SEGMENT_VARIABLE, VARIABLE_SEGMENT_POINTER,
 110      =2  //     SEGMENT_VARIABLE_SEGMENT_POINTER, and LOCATED_VARIABLE
 111      =2  // Release 1.0 - 29 SEP 2006 (PKC)
 112      =2  //    -Initial revision
 113      =2  
 114      =2  //-----------------------------------------------------------------------------
 115      =2  // Header File Preprocessor Directive
 116      =2  //-----------------------------------------------------------------------------
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 25  

 117      =2  
 118      =2  #ifndef COMPILER_DEFS_H
           =2 #define COMPILER_DEFS_H
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // Macro definitions
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // SDCC - Small Device C Compiler
           =2 // http://sdcc.sourceforge.net
           =2 
           =2 #if defined SDCC
           =2 
           =2 #if (SDCC >= 300)
           =2 
           =2 #define interrupt __interrupt
           =2 #define _asm __asm
           =2 #define _endasm __endasm
           =2 #define bit __bit
           =2 #define code __code
           =2 #define at __at
           =2 
           =2 #endif
           =2 
           =2 # define SEG_GENERIC
           =2 # define SEG_FAR   __xdata
           =2 # define SEG_DATA  __data
           =2 # define SEG_NEAR  __data
           =2 # define SEG_IDATA __idata
           =2 # define SEG_XDATA __xdata
           =2 # define SEG_PDATA __pdata
           =2 # define SEG_CODE  __code
           =2 # define SEG_BDATA __bdata
           =2 
           =2 # define SBIT(name, addr, bit)  __sbit  __at(addr+bit)                  name
           =2 # define SFR(name, addr)        __sfr   __at(addr)                      name
           =2 # define SFRX(name, addr)       xdata volatile unsigned char __at(addr) name
           =2 # define SFR16(name, addr)      __sfr16 __at(((addr+1U)<<8) | addr)     name
           =2 # define SFR16E(name, fulladdr) __sfr16 __at(fulladdr)                  name
           =2 # define SFR32(name, addr)      __sfr32 __at(((addr+3UL)<<24) | ((addr+2UL)<<16) | ((addr+1UL)<<8) | addr)
             - name
           =2 # define SFR32E(name, fulladdr) __sfr32 __at(fulladdr)                  name
           =2 
           =2 # define INTERRUPT(name, vector) void name (void) interrupt (vector)
           =2 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =2 # define INTERRUPT_PROTO(name, vector) void name (void) interrupt (vector)
           =2 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =2 
           =2 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using (regnum
             -)
           =2 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter) using (
             -regnum)
           =2 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =2 
           =2 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =2 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =2 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =2 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =2 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment at (addr) vartype name = init
           =2 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) locsegment at (addr) vartype name
           =2 
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 26  

           =2 // used with UU16
           =2 # define LSB 0
           =2 # define MSB 1
           =2 
           =2 // used with UU32 (b0 is least-significant byte)
           =2 # define b0 0
           =2 # define b1 1
           =2 # define b2 2
           =2 # define b3 3
           =2 
           =2 typedef unsigned char U8;
           =2 typedef unsigned int U16;
           =2 typedef unsigned long U32;
           =2 
           =2 typedef signed char S8;
           =2 typedef signed int S16;
           =2 typedef signed long S32;
           =2 
           =2 typedef union UU16
           =2 {
           =2    U16 U16;
           =2    S16 S16;
           =2    U8 U8[2];
           =2    S8 S8[2];
           =2 } UU16;
           =2 
           =2 typedef union UU32
           =2 {
           =2    U32 U32;
           =2    S32 S32;
           =2    UU16 UU16[2];
           =2    U16 U16[2];
           =2    S16 S16[2];
           =2    U8 U8[4];
           =2    S8 S8[4];
           =2 } UU32;
           =2 
           =2 // NOP () macro support
           =2 #define NOP() _asm NOP _endasm
           =2 
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // Raisonance (must be placed before Keil C51)
           =2 // http://www.raisonance.com
           =2 
           =2 #elif defined __RC51__
           =2 
           =2 //#error Raisonance C51 detected.
           =2 
           =2 # define SEG_GENERIC generic     //SEG_GENERIC only applies to pointers in Raisonance, not variables.
           =2 # define SEG_FAR   xdata
           =2 # define SEG_DATA  data
           =2 # define SEG_NEAR  data
           =2 # define SEG_IDATA idata
           =2 # define SEG_XDATA xdata
           =2 # define SEG_PDATA pdata
           =2 # define SEG_CODE  code
           =2 # define SEG_BDATA bdata
           =2 
           =2 # define SBIT(name, addr, bit)  at (addr+bit) sbit         name
           =2 # define SFR(name, addr)        sfr at addr                name
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 27  

           =2 # define SFR16(name, addr)      sfr16 at addr              name
           =2 # define SFR16E(name, fulladdr) /* not supported */
           =2 # define SFR32(name, fulladdr)  /* not supported */
           =2 # define SFR32E(name, fulladdr) /* not supported */
           =2 
           =2 # define INTERRUPT(name, vector) void name (void) interrupt vector
           =2 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =2 # define INTERRUPT_PROTO(name, vector) void name (void)
           =2 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =2 
           =2 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
           =2 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =2 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =2 
           =2 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =2 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =2 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =2 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =2 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) at addr locsegment vartype name
           =2 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) at addr locsegment vartype name
           =2 
           =2 
           =2 // used with UU16
           =2 # define LSB 1
           =2 # define MSB 0
           =2 
           =2 // used with UU32 (b0 is least-significant byte)
           =2 # define b0 3
           =2 # define b1 2
           =2 # define b2 1
           =2 # define b3 0
           =2 
           =2 typedef unsigned char U8;
           =2 typedef unsigned int U16;
           =2 typedef unsigned long U32;
           =2 
           =2 typedef signed char S8;
           =2 typedef signed int S16;
           =2 typedef signed long S32;
           =2 
           =2 typedef union UU16
           =2 {
           =2    U16 U16;
           =2    S16 S16;
           =2    U8 U8[2];
           =2    S8 S8[2];
           =2 } UU16;
           =2 
           =2 typedef union UU32
           =2 {
           =2    U32 U32;
           =2    S32 S32;
           =2    UU16 UU16[2];
           =2    U16 U16[2];
           =2    S16 S16[2];
           =2    U8 U8[4];
           =2    S8 S8[4];
           =2 } UU32;
           =2 
           =2 // NOP () macro support -- NOP is opcode 0x00
           =2 #define NOP() asm { 0x00 }
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 28  

           =2 
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 
           =2 // Keil C51
           =2 // http://www.keil.com
           =2 
           =2 #elif defined __C51__
           =2 
           =2 //#error Keil C51 detected.
           =2 
           =2 # define SEG_GENERIC
           =2 # define SEG_FAR   xdata
           =2 # define SEG_DATA  data
           =2 # define SEG_NEAR  data
           =2 # define SEG_IDATA idata
           =2 # define SEG_XDATA xdata
           =2 # define SEG_PDATA pdata
           =2 # define SEG_CODE  code
           =2 # define SEG_BDATA bdata
           =2 
           =2 # define SBIT(name, addr, bit)  sbit  name = addr^bit
           =2 # define SFR(name, addr)        sfr   name = addr
           =2 # define SFR16(name, addr)      sfr16 name = addr
           =2 # define SFR16E(name, fulladdr) /* not supported */
           =2 # define SFR32(name, fulladdr)  /* not supported */
           =2 # define SFR32E(name, fulladdr) /* not supported */
           =2 
           =2 # define INTERRUPT(name, vector) void name (void) interrupt vector
           =2 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =2 # define INTERRUPT_PROTO(name, vector) void name (void)
           =2 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =2 
           =2 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
           =2 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =2 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =2 
           =2 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =2 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =2 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =2 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =2 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) vartype locsegment name _at_ addr
           =2 
           =2 // used with UU16
           =2 # define LSB 1
           =2 # define MSB 0
           =2 
           =2 // used with UU32 (b0 is least-significant byte)
           =2 # define b0 3
           =2 # define b1 2
           =2 # define b2 1
           =2 # define b3 0
           =2 
           =2 typedef unsigned char U8;
           =2 typedef unsigned int U16;
           =2 typedef unsigned long U32;
           =2 
           =2 typedef signed char S8;
           =2 typedef signed int S16;
           =2 typedef signed long S32;
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 29  

           =2 
           =2 typedef union UU16
           =2 {
           =2    U16 U16;
           =2    S16 S16;
           =2    U8 U8[2];
           =2    S8 S8[2];
           =2 } UU16;
           =2 
           =2 typedef union UU32
           =2 {
           =2    U32 U32;
           =2    S32 S32;
           =2    UU16 UU16[2];
           =2    U16 U16[2];
           =2    S16 S16[2];
           =2    U8 U8[4];
           =2    S8 S8[4];
           =2 } UU32;
           =2 
           =2 // NOP () macro support
           =2 extern void _nop_ (void);
           =2 #define NOP() _nop_()
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // Hi-Tech 8051
           =2 // http://www.htsoft.com
           =2 
           =2 #elif defined HI_TECH_C
           =2 
           =2 # define SEG_GENERIC
           =2 # define SEG_FAR   far
           =2 # define SEG_DATA  data
           =2 # define SEG_NEAR  near
           =2 # define SEG_IDATA idata
           =2 # define SEG_XDATA xdata
           =2 # define SEG_PDATA pdata
           =2 # define SEG_CODE  code
           =2 # define SEG_BDATA bdata
           =2 
           =2 
           =2 # define SBIT(name, addr, thebit) static volatile bit name @ (addr + thebit)
           =2 # define SFR(name, addr)          static volatile unsigned char name @ addr
           =2 # define SFR16(name, addr)        static volatile unsigned int name @ addr
           =2 # define SFR16E(name, fulladdr) /* not supported */
           =2 # define SFR32(name, fulladdr)  /* not supported */
           =2 # define SFR32E(name, fulladdr) /* not supported */
           =2 
           =2 # define INTERRUPT(name, vector)       void name (void) interrupt vector
           =2 # define INTERRUPT_PROTO(name, vector)
           =2 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =2 # define INTERRUPT_PROTO_USING(name, vector, regnum)
           =2 
           =2 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =2 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =2 // Note: Hi-Tech does not support functions using different register banks. Register
           =2 //       banks can only be specified in interrupts. If a function is called from
           =2 //       inside an interrupt, it will use the same register bank as the interrupt.
           =2 
           =2 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =2 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 30  

           =2 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =2 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment vartype name @ addr
           =2 
           =2 // used with UU16
           =2 # define LSB 0
           =2 # define MSB 1
           =2 
           =2 // used with UU32 (b0 is least-significant byte)
           =2 # define b0 0
           =2 # define b1 1
           =2 # define b2 2
           =2 # define b3 3
           =2 
           =2 typedef unsigned char U8;
           =2 typedef unsigned int U16;
           =2 typedef unsigned long U32;
           =2 
           =2 typedef signed char S8;
           =2 typedef signed int S16;
           =2 typedef signed long S32;
           =2 
           =2 typedef union UU16
           =2 {
           =2    U16 U16;
           =2    S16 S16;
           =2    U8 U8[2];
           =2    S8 S8[2];
           =2 } UU16;
           =2 
           =2 typedef union UU32
           =2 {
           =2    U32 U32;
           =2    S32 S32;
           =2    UU16 UU16[2];
           =2    U16 U16[2];
           =2    S16 S16[2];
           =2    U8 U8[4];
           =2    S8 S8[4];
           =2 } UU32;
           =2 
           =2 // NOP () macro support
           =2 #define NOP() asm(" nop ")
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // Tasking / Altium
           =2 // http://www.altium.com/tasking
           =2 
           =2 
           =2 #elif defined _CC51
           =2 
           =2 # define SEG_GENERIC
           =2 # define SEG_FAR   _xdat
           =2 # define SEG_DATA  _data
           =2 # define SEG_NEAR  _data
           =2 # define SEG_IDATA _idat
           =2 # define SEG_XDATA _xdat
           =2 # define SEG_PDATA _pdat
           =2 # define SEG_CODE  _rom
           =2 # define SEG_BDATA _bdat
           =2 
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 31  

           =2 # define SBIT(name, addr, bit)  _sfrbit  name _at(addr+bit)
           =2 # define SFR(name, addr)        _sfrbyte name _at(addr)
           =2 # define SFRX(name, addr)       _xdat volatile unsigned char name _at(addr)
           =2 #if _CC51 > 71
           =2 # define SFR16(name, addr)      _sfrword _little name _at(addr)
           =2 #else
           =2 # define SFR16(name, addr)      /* not supported */
           =2 #endif
           =2 # define SFR16E(name, fulladdr) /* not supported */
           =2 # define SFR32(name, fulladdr)  /* not supported */
           =2 # define SFR32E(name, fulladdr) /* not supported */
           =2 
           =2 # define INTERRUPT(name, vector) _interrupt (vector) void name (void)
           =2 # define INTERRUPT_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =2 # define INTERRUPT_PROTO(name, vector) _interrupt (vector) void name (void)
           =2 # define INTERRUPT_PROTO_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =2 
           =2 // When calling FUNCTION_USING in Tasking, the function must be called from an interrupt or Main which
           =2 // is also using the same register bank. If not, the compiler will generate an error.
           =2 # define FUNCTION_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (parameter
             -)
           =2 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (par
             -ameter)
           =2 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =2 
           =2 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =2 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =2 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =2 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) vartype locsegment name _at( addr )
           =2 
           =2 // used with UU16
           =2 # define LSB 1
           =2 # define MSB 0
           =2 
           =2 // used with UU32 (b0 is least-significant byte)
           =2 # define b0 3
           =2 # define b1 2
           =2 # define b2 1
           =2 # define b3 0
           =2 
           =2 typedef unsigned char U8;
           =2 typedef unsigned int U16;
           =2 typedef unsigned long U32;
           =2 
           =2 typedef signed char S8;
           =2 typedef signed int S16;
           =2 typedef signed long S32;
           =2 
           =2 typedef union UU16
           =2 {
           =2    U16 U16;
           =2    S16 S16;
           =2    U8 U8[2];
           =2    S8 S8[2];
           =2 } UU16;
           =2 
           =2 typedef union UU32
           =2 {
           =2    U32 U32;
           =2    S32 S32;
           =2    UU16 UU16[2];
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 32  

           =2    U16 U16[2];
           =2    S16 S16[2];
           =2    U8 U8[4];
           =2    S8 S8[4];
           =2 } UU32;
           =2 
           =2 // NOP () macro support
           =2 extern void _nop (void);
           =2 #define NOP() _nop()
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 
           =2 // IAR 8051
           =2 // http://www.iar.com
           =2 
           =2 #elif defined __ICC8051__
           =2 
           =2 #include <stdbool.h>
           =2 #include <intrinsics.h>
           =2 
           =2 # define SBIT(name, addr, bit)  __bit __no_init volatile bool name @ (addr+bit)
           =2 # define SFR(name, addr)        __sfr __no_init volatile unsigned char name @ addr
           =2 # define SFRX(name, addr)       __xdata __no_init volatile unsigned char name @ addr
           =2 # define SFR16(name, addr)      __sfr __no_init volatile unsigned int  name @ addr
           =2 # define SFR16E(name, fulladdr) /* not supported */
           =2 # define SFR32(name, fulladdr) /* not supported */
           =2 # define SFR32E(name, fulladdr) /* not supported */
           =2 
           =2 # define SEG_GENERIC __generic
           =2 # define SEG_FAR  __xdata
           =2 # define SEG_DATA __data
           =2 # define SEG_NEAR __data
           =2 # define SEG_IDATA __idata
           =2 # define SEG_XDATA __xdata
           =2 # define SEG_PDATA __pdata
           =2 # define SEG_CODE  __code
           =2 # define SEG_BDATA __bdata
           =2 
           =2 #define bit bool
           =2 
           =2 # define _PPTOSTR_(x) #x
           =2 # define _PPARAM_(address) _PPTOSTR_(vector=address * 8 + 3)
           =2 # define _PPARAM2_(regbank) _PPTOSTR_(register_bank=regbank)
           =2 # define INTERRUPT(name, vector) _Pragma(_PPARAM_(vector)) __interrupt void name(void)
           =2 # define INTERRUPT_PROTO(name, vector)  __interrupt void name(void)
           =2 # define INTERRUPT_USING(name, vector, regnum) _Pragma(_PPARAM2_(regnum)) _Pragma(_PPARAM_(vector)) __inte
             -rrupt void name(void)
           =2 # define INTERRUPT_PROTO_USING(name, vector, regnum) __interrupt void name(void)
           =2 
           =2 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =2 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =2 // Note: IAR does not support functions using different register banks. Register
           =2 //       banks can only be specified in interrupts. If a function is called from
           =2 //       inside an interrupt, it will use the same register bank as the interrupt.
           =2 
           =2 # define SEGMENT_VARIABLE(name, vartype, locsegment)  locsegment vartype name
           =2 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment  * name
           =2 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =2 
           =2 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment __no_init vartype name @ addr
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 33  

           =2 
           =2 // used with UU16
           =2 # define LSB 0
           =2 # define MSB 1
           =2 
           =2 // used with UU32 (b0 is least-significant byte)
           =2 # define b0 0
           =2 # define b1 1
           =2 # define b2 2
           =2 # define b3 3
           =2 
           =2 typedef unsigned char U8;
           =2 typedef unsigned int U16;
           =2 typedef unsigned long U32;
           =2 
           =2 typedef signed char S8;
           =2 typedef signed int S16;
           =2 typedef signed long S32;
           =2 
           =2 typedef union UU16
           =2 {
           =2    U16 U16;
           =2    S16 S16;
           =2    U8 U8[2];
           =2    S8 S8[2];
           =2 } UU16;
           =2 
           =2 typedef union UU32
           =2 {
           =2    U32 U32;
           =2    S32 S32;
           =2    UU16 UU16[2];
           =2    U16 U16[2];
           =2    S16 S16[2];
           =2    U8 U8[4];
           =2    S8 S8[4];
           =2 } UU32;
           =2 
           =2 
           =2 #define NOP() __no_operation();
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // Crossware
           =2 // http://www.crossware.com
           =2 
           =2 #elif defined _XC51_VER
           =2 # define SBIT(name, addr, bit)  _sfrbit  name = (addr+bit)
           =2 # define SFR(name, addr)        _sfr     name = addr
           =2 # define SFR16(name, addr)      _sfrword name = addr
           =2 # define SFR16E(name, fulladdr) /* not supported */
           =2 # define SFR32(name, fulladdr)  /* not supported */
           =2 # define SFR32E(name, fulladdr) /* not supported */
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // Wickenhäuser
           =2 // http://www.wickenhaeuser.de
           =2 
           =2 #elif defined __UC__
           =2 # define SBIT(name, addr, bit)  unsigned char bit  name @ (addr+bit)
           =2 # define SFR(name, addr)        near unsigned char name @ addr
           =2 # define SFR16(name, addr)      /* not supported */
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 34  

           =2 # define SFR16E(name, fulladdr) /* not supported */
           =2 # define SFR32(name, fulladdr)  /* not supported */
           =2 # define SFR32E(name, fulladdr) /* not supported */
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // Default
           =2 // Unknown compiler
           =2 
           =2 #else
           =2 # warning unrecognized compiler
           =2 # define SBIT(name, addr, bit)  volatile bool           name
           =2 # define SFR(name, addr)        volatile unsigned char  name
           =2 # define SFRX(name, addr)       volatile unsigned char  name
           =2 # define SFR16(name, addr)      volatile unsigned short name
           =2 # define SFR16E(name, fulladdr) volatile unsigned short name
           =2 # define SFR32(name, fulladdr)  volatile unsigned long  name
           =2 # define SFR32E(name, fulladdr) volatile unsigned long  name
           =2 
           =2 #endif
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // Header File PreProcessor Directive
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 #endif                                 // #define COMPILER_DEFS_H
 689      =2  
 690      =2  //-----------------------------------------------------------------------------
 691      =2  // End Of File
 692      =2  //-----------------------------------------------------------------------------
   4      =1  #include <C8051F580_defs.h>            // SFR declarations
   1      =2  //-----------------------------------------------------------------------------
   2      =2  // C8051F580_defs.h
   3      =2  //-----------------------------------------------------------------------------
   4      =2  // Copyright 2008, Silicon Laboratories, Inc.
   5      =2  // http://www.silabs.com
   6      =2  //
   7      =2  // Program Description:
   8      =2  //
   9      =2  // Register/bit definitions for the C8051F58x family.
  10      =2  // **Important Note**: The compiler_defs.h header file should be included
  11      =2  // before including this header file.
  12      =2  //
  13      =2  // Target:         C8051F580/1/2/3/4/5/6/7,8/9-F590/1
  14      =2  // Tool chain:     Generic
  15      =2  // Command Line:   None
  16      =2  //
  17      =2  // Release 0.6 - 20 AUG 2012 (TP)
  18      =2  //    -Added #define for _XPAGE to provide support for SDCC memory paging
  19      =2  //     (pdata)
  20      =2  //
  21      =2  // Release 0.5 - 10 SEP 2011 (GP)
  22      =2  //    - Fixed SFR16 definition for CAN0IF2MC
  23      =2  //
  24      =2  // Release 0.4 - 08 OCT 2010 (TP)
  25      =2  //    - Fixed bit definitions for SCON0
  26      =2  //
  27      =2  // Release 0.3 - 01 APR 2009 (GP)
  28      =2  //    - Added SN0-SN3
  29      =2  //
  30      =2  // Release 0.2 - 29 JUL 2008 (ADT)
  31      =2  //    - Added Timer 4 bit definitions
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 35  

  32      =2  //
  33      =2  // Release 0.1 - 09 JUL 2008 (GP)
  34      =2  //    - Initial Revision
  35      =2  //
  36      =2  //-----------------------------------------------------------------------------
  37      =2  // Header File Preprocessor Directive
  38      =2  //-----------------------------------------------------------------------------
  39      =2  
  40      =2  #ifndef C8051F580_DEFS_H
           =2 #define C8051F580_DEFS_H
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // Page 0, Page 1 and Page F Registers
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 SFR (P0, 0x80);                        // Port 0 Latch
           =2 SFR (SP, 0x81);                        // Stack Pointer
           =2 SFR (DPL, 0x82);                       // Data Pointer Low
           =2 SFR (DPH, 0x83);                       // Data Pointer High
           =2 SFR (SFR0CN, 0x84);                    // SFR Page Control
           =2 SFR (SFRNEXT, 0x85);                   // SFR stack next page
           =2 SFR (SFRLAST, 0x86);                   // SFR stack last page
           =2 SFR (PCON, 0x87);                      // Power Control
           =2 SFR (TCON, 0x88);                      // Timer/Counter Control
           =2 SFR (TMOD, 0x89);                      // Timer/Counter Mode
           =2 SFR (TL0, 0x8A);                       // Timer/Counter 0 Low
           =2 SFR (TL1, 0x8B);                       // Timer/Counter 1 Low
           =2 SFR (TH0, 0x8C);                       // Timer/Counter 0 High
           =2 SFR (TH1, 0x8D);                       // Timer/Counter 1 High
           =2 SFR (CKCON, 0x8E);                     // Clock Control
           =2 SFR (PSCTL, 0x8F);                     // Program Store R/W Control
           =2 SFR (CLKSEL, 0x8F);                    // System clock select
           =2 SFR (P1, 0x90);                        // Port 1 Latch
           =2 SFR (TMR3CN, 0x91);                    // Timer/Counter 3 Control
           =2 SFR (TMR5CN, 0x91);                    // Timer/Counter 5 Control
           =2 SFR (TMR3RLL, 0x92);                   // Timer/Counter 3 Reload Low
           =2 SFR (TMR5CAPL, 0x92);                  // Timer/Counter 5 Capture Low
           =2 SFR (TMR3RLH, 0x93);                   // Timer/Counter 3 Reload High
           =2 SFR (TMR5CAPH, 0x93);                  // Timer/Counter 5 Capture High
           =2 SFR (TMR3L, 0x94);                     // Timer/Counter 3 Low
           =2 SFR (TMR5L, 0x94);                     // Timer/Counter 5 Low
           =2 SFR (TMR3H, 0x95);                     // Timer/Counter 3 High
           =2 SFR (TMR5H, 0x95);                     // Timer/Counter 5 High
           =2 SFR (TMR5CF, 0x96);                    // Timer/Counter 5 Configuration
           =2 SFR (CLKMUL, 0x97);                    // Clock Multiplier
           =2 SFR (SCON0, 0x98);                     // UART0 Control
           =2 SFR (SCON1, 0x98);                     // UART1 Control
           =2 SFR (SBUF0, 0x99);                     // UART0 Data Buffer
           =2 SFR (SBUF1, 0x99);                     // UART1 Data Buffer
           =2 SFR (CPT0CN, 0x9A);                    // Comparator 0 Control
           =2 SFR (CPT2CN, 0x9A);                    // Comparator 2 Control
           =2 SFR (CPT0MD, 0x9B);                    // Comparator 0 Mode
           =2 SFR (CPT2MD, 0x9B);                    // Comparator 2 Mode
           =2 SFR (CPT0MX, 0x9C);                    // Comparator 0 Mux
           =2 SFR (CPT2MX, 0x9C);                    // Comparator 2 Mux
           =2 SFR (CPT1CN, 0x9D);                    // Comparator 1 Control
           =2 SFR (CPT1MD, 0x9E);                    // Comparator 0 Mode
           =2 SFR (OSCIFIN, 0x9E);                   // Internal Oscillator Fine Control
           =2 SFR (CPT1MX, 0x9F);                    // Comparator 1 Mux
           =2 SFR (OSCXCN, 0x9F);                    // External Oscillator Control
           =2 SFR (P2, 0xA0);                        // Port 2 Latch
           =2 SFR (SPI0CFG, 0xA1);                   // SPI0 Configuration
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 36  

           =2 SFR (OSCICN, 0xA1);                    // Internal Oscillator Control
           =2 SFR (SPI0CKR, 0xA2);                   // SPI0 Clock rate control
           =2 SFR (OSCICRS, 0xA2);                   // Internal Oscillator Coarse Control
           =2 SFR (SPI0DAT, 0xA3);                   // SPI0 Data Buffer
           =2 SFR (P0MDOUT, 0xA4);                   // Port 0 Output Mode
           =2 SFR (P1MDOUT, 0xA5);                   // Port 1 Output Mode
           =2 SFR (P2MDOUT, 0xA6);                   // Port 2 Output Mode
           =2 SFR (SFRPAGE, 0xA7);                   // SFR Page Select
           =2 SFR (IE, 0xA8);                        // Interrupt Enable
           =2 SFR (SMOD0, 0xA9);                     // Serial Port 0 Control
           =2 SFR (EMI0CN, 0xAA);                    // EMIF Control
           =2 SFR (EMI0TC, 0xAA);                    // EMIF Timing control
           =2 SFR (SBCON0, 0xAB);                    // UART0 Baud Rate Generator Control
           =2 SFR (SBRLL0, 0xAC);                    // UART0 Baud Rate Generator Low
           =2 SFR (SBRLH0, 0xAD);                    // UART0 Baud Rate Generator High
           =2 SFR (P3MAT, 0xAE);                     // Port 3 Match
           =2 SFR (P3MDOUT, 0xAE);                   // Port 3 Mode
           =2 SFR (P3MASK, 0xAF);                    // Port 3 Mask
           =2 SFR (P4MDOUT, 0xAF);                   // Port 4 Mode
           =2 SFR (P3, 0xB0);                        // Port 3 Latch
           =2 SFR (P2MAT, 0xB1);                     // Port 2 Match
           =2 SFR (P2MASK, 0xB2);                    // Port 2 Mask
           =2 SFR (EMI0CF, 0xB2);                    // EMIF Configuration
           =2 SFR (P4, 0xB5);                        // Port 4 Latch
           =2 SFR (FLSCL, 0xB6);                     // Flash Scale
           =2 SFR (FLKEY, 0xB7);                     // Flash access limit
           =2 SFR (IP, 0xB8);                        // Interrupt Priority
           =2 SFR (SMB0ADR, 0xB9);                   // SMBus0 Slave address
           =2 SFR (ADC0TK, 0xBA);                    // ADC0 Tracking Mode Select
           =2 SFR (SMB0ADM, 0xBA);                   // SMBus0 Address Mask
           =2 SFR (ADC0MX, 0xBB);                    // AMUX0 Channel select
           =2 SFR (ADC0CF, 0xBC);                    // AMUX0 Channel configuration
           =2 SFR (ADC0L, 0xBD);                     // ADC0 Data Low
           =2 SFR (ADC0H, 0xBE);                     // ADC0 Data High
           =2 SFR (SMB0CN, 0xC0);                    // SMBus0 Control
           =2 SFR (SMB0CF, 0xC1);                    // SMBus0 Configuration
           =2 SFR (SMB0DAT, 0xC2);                   // SMBus0 Data
           =2 SFR (ADC0GTL, 0xC3);                   // ADC0 Greater-Than Compare Low
           =2 SFR (ADC0GTH, 0xC4);                   // ADC0 Greater-Than Compare High
           =2 SFR (ADC0LTL, 0xC5);                   // ADC0 Less-Than Compare Word Low
           =2 SFR (ADC0LTH, 0xC6);                   // ADC0 Less-Than Compare Word High
           =2 SFR (XBR3, 0xC6);                      // Port I/O Crossbar Control 3
           =2 SFR (XBR2, 0xC7);                      // Port I/O Crossbar Control 2
           =2 SFR (TMR2CN, 0xC8);                    // Timer/Counter 2 Control
           =2 SFR (TMR4CN, 0xC8);                    // Timer/Counter 4 Control
           =2 SFR (REG0CN, 0xC9);                    // Regulator Control
           =2 SFR (LIN0CF, 0xC9);                    // LIN 0 Configuration
           =2 SFR (TMR4CF, 0xC9);                    // Timer/Counter 4 Configuration
           =2 SFR (TMR2RLL, 0xCA);                   // Timer/Counter 2 Reload Low
           =2 SFR (TMR4CAPL, 0xCA);                  // Timer/Counter 4 Capture Low
           =2 SFR (TMR2RLH, 0xCB);                   // Timer/Counter 2 Reload High
           =2 SFR (TMR4CAPH, 0xCB);                  // Timer/Counter 4 Capture High
           =2 SFR (TMR2L, 0xCC);                     // Timer/Counter 2 Low
           =2 SFR (TMR4L, 0xCC);                     // Timer/Counter 4 Low
           =2 SFR (TMR2H, 0xCD);                     // Timer/Counter 2 High
           =2 SFR (TMR4H, 0xCD);                     // Timer/Counter 4 High
           =2 SFR (PCA0CPL5, 0xCE);                  // PCA0 Capture 5 Low
           =2 SFR (PCA1CPL11, 0xCE);                 // PCA1 Capture 11 Low
           =2 SFR (PCA0CPH5, 0xCF);                  // PCA0 Capture 5 High
           =2 SFR (PCA1CPH11, 0xCF);                 // PCA1 Capture 11 High
           =2 SFR (PSW, 0xD0);                       // Program Status Word
           =2 SFR (REF0CN, 0xD1);                    // Voltage Reference Control
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 37  

           =2 SFR (LIN0DAT, 0xD2);                   // LIN0 Data
           =2 SFR (LIN0ADR, 0xD3);                   // LIN0 Address
           =2 SFR (P0SKIP, 0xD4);                    // Port 0 Skip
           =2 SFR (P1SKIP, 0xD5);                    // Port 1 Skip
           =2 SFR (P2SKIP, 0xD6);                    // Port 2 Skip
           =2 SFR (P3SKIP, 0xD7);                    // Port 3 Skip
           =2 SFR (PCA0CN, 0xD8);                    // PCA0 Control
           =2 SFR (PCA1CN, 0xD8);                    // PCA1 Control
           =2 SFR (PCA0MD, 0xD9);                    // PCA0 Mode
           =2 SFR (PCA1MD, 0xD9);                    // PCA1 Mode
           =2 SFR (PCA0PWM, 0xD9);                   // PCA0 PWM Control
           =2 SFR (PCA0CPM0, 0xDA);                  // PCA0 Module 0 Mode
           =2 SFR (PCA1CPM6, 0xDA);                  // PCA1 Module 6 Mode
           =2 SFR (PCA1PWM, 0xDA);                   // PCA1 PWM Control
           =2 SFR (PCA0CPM1, 0xDB);                  // PCA0 Module 1  Mode
           =2 SFR (PCA1CPM7, 0xDB);                  // PCA1 Module 7  Mode
           =2 SFR (PCA0CPM2, 0xDC);                  // PCA0 Module 2  Mode
           =2 SFR (PCA1CPM8, 0xDC);                  // PCA1 Module 8  Mode
           =2 SFR (PCA0CPM3, 0xDD);                  // PCA0 Module 3  Mode
           =2 SFR (PCA1CPM9, 0xDD);                  // PCA1 Module 9  Mode
           =2 SFR (PCA0CPM4, 0xDE);                  // PCA0 Module 4  Mode
           =2 SFR (PCA1CPM10, 0xDE);                  // PCA1 Module 10 Mode
           =2 SFR (PCA0CPM5, 0xDF);                  // PCA0 Module 5  Mode
           =2 SFR (PCA1CPM11, 0xDF);                  // PCA1 Module 11 Mode
           =2 SFR (ACC, 0xE0);                       // Accumulator
           =2 SFR (XBR0, 0xE1);                      // Port I/O Crossbar Control 0
           =2 SFR (XBR1, 0xE2);                      // Port I/O Crossbar Control 1
           =2 SFR (CCH0CN, 0xE3);                    // Cache control
           =2 SFR (IT01CF, 0xE4);                    // INT0/INT1 Configuration
           =2 SFR (EIE1, 0xE6);                      // Extended Interrupt Enable 2
           =2 SFR (EIE2, 0xE7);                      // Extended Interrupt Enable 2
           =2 SFR (ADC0CN, 0xE8);                    // ADC0 Control
           =2 SFR (PCA0CPL1, 0xE9);                  // PCA0 Capture 1 Low
           =2 SFR (PCA1CPL1, 0xE9);                  // PCA1 Capture 7 Low
           =2 SFR (PCA0CPH1, 0xEA);                  // PCA0 Capture 1 High
           =2 SFR (PCA1CPH1, 0xEA);                  // PCA1 Capture 7 High
           =2 SFR (PCA0CPL2, 0xEB);                  // PCA0 Capture 2 Low
           =2 SFR (PCA1CPL2, 0xEB);                  // PCA1 Capture 8 Low
           =2 SFR (PCA0CPH2, 0xEC);                  // PCA0 Capture 2 High
           =2 SFR (PCA1CPH2, 0xEC);                  // PCA1 Capture 8 High
           =2 SFR (PCA0CPL3, 0xED);                  // PCA0 Capture 3 Low
           =2 SFR (PCA1CPL3, 0xED);                  // PCA1 Capture 9 Low
           =2 SFR (PCA0CPH3, 0xEE);                  // PCA0 Capture 3 High
           =2 SFR (PCA1CPH3, 0xEE);                  // PCA1 Capture 9 High
           =2 SFR (RSTSRC, 0xEF);                    // Reset Source Configuration/Status
           =2 SFR (B, 0xF0);                         // B Register
           =2 SFR (P0MAT, 0xF1);                     // Port 0 Match
           =2 SFR (P0MDIN, 0xF1);                    // Port 0 Input Mode
           =2 SFR (P0MASK, 0xF2);                    // Port 0 Mask
           =2 SFR (P1MDIN, 0xF2);                    // Port 1 Input Mode
           =2 SFR (P1MAT, 0xF3);                     // Port 1 Match
           =2 SFR (P2MDIN, 0xF3);                    // Port 2 Input Mode
           =2 SFR (P1MASK, 0xF4);                    // Port 1 Mask
           =2 SFR (P3MDIN, 0xF4);                    // Port 3 Input Mode
           =2 SFR (PSBANK, 0xF5);                    // Program Space Bank Select
           =2 SFR (EIP1, 0xF6);                      // External Interrupt Priority 1
           =2 SFR (EIP2, 0xF7);                      // External Interrupt Priority 2
           =2 SFR (SPI0CN, 0xF8);                    // SPI0 Control
           =2 SFR (PCA0L, 0xF9);                     // PCA0 Counter Low
           =2 SFR (PCA1L, 0xF9);                     // PCA1 Counter Low
           =2 SFR (SN0, 0xF9);                       // Serial Number 0
           =2 SFR (PCA0H, 0xFA);                     // PCA0 Counter High
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 38  

           =2 SFR (PCA1H, 0xFA);                     // PCA1 Counter High
           =2 SFR (SN1, 0xFA);                       // Serial Number 1
           =2 SFR (PCA0CPL0, 0xFB);                  // PCA0 Capture 0 Low
           =2 SFR (PCA1CPL6, 0xFB);                  // PCA1 Capture 6 Low
           =2 SFR (SN2, 0xFB);                       // Serial Number 2
           =2 SFR (PCA0CPH0, 0xFC);                  // PCA0 Capture 0 High
           =2 SFR (PCA1CPH6, 0xFC);                  // PCA1 Capture 6 High
           =2 SFR (SN3, 0xFC);                       // Serial Number 3
           =2 SFR (PCA0CPL4, 0xFD);                  // PCA0 Capture 4 Low
           =2 SFR (PCA1CPL10, 0xFD);                 // PCA1 Capture 10 Low
           =2 SFR (PCA0CPH4, 0xFE);                  // PCA0 Capture 4 High
           =2 SFR (PCA1CPH10, 0xFE);                 // PCA1 Capture 10 High
           =2 SFR (VDM0CN, 0xFF);                    // VDD Monitor Control
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // Page C (CAN0) Registers
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 SFR (CAN0CFG, 0x92);                   // CAN0 Clock Configuration
           =2 SFR (CAN0STAT, 0x94);                  // Status Register Low Byte
           =2 SFR (CAN0ERRL, 0x96);                  // Error Counter Low Byte
           =2 SFR (CAN0ERRH, 0x97);                  // Error Counter High Byte
           =2 SFR (CAN0BTL, 0x9A);                   // Bit Timing Register Low Byte
           =2 SFR (CAN0BTH, 0x9B);                   // Bit Timing Register High Byte
           =2 SFR (CAN0IIDL, 0x9C);                  // Interrupt Register Low Byte
           =2 SFR (CAN0IIDH, 0x9D);                  // Interrupt Register High Byte
           =2 SFR (CAN0TST, 0x9E);                   // Test Register Low Byte
           =2 SFR (CAN0BRPE, 0xA1);                  // BRP Extension Register Low Byte
           =2 SFR (CAN0TR1L, 0xA2);                  // Transmission Request 1 Low Byte
           =2 SFR (CAN0TR1H, 0xA3);                  // Transmission Request 1 High Byte
           =2 SFR (CAN0TR2L, 0xA4);                  // Transmission Request 2 Low Byte
           =2 SFR (CAN0TR2H, 0xA5);                  // Transmission Request 2 High Byte
           =2 SFR (CAN0ND1L, 0xAA);                  // New Data 1 Low Byte
           =2 SFR (CAN0ND1H, 0xAB);                  // New Data 1 High Byte
           =2 SFR (CAN0ND2L, 0xAC);                  // New Data 2 Low Byte
           =2 SFR (CAN0ND2H, 0xAD);                  // New Data 2 High Byte
           =2 SFR (CAN0IP1L, 0xAE);                  // Interrupt Pending 1 Low Byte
           =2 SFR (CAN0IP1H, 0xAF);                  // Interrupt Pending 1 High Byte
           =2 SFR (CAN0IP2L, 0xB2);                  // Interrupt Pending 2 Low Byte
           =2 SFR (CAN0IP2H, 0xB3);                  // Interrupt Pending 2 High Byte
           =2 SFR (CAN0MV1L, 0xBA);                  // Message Valid 1 Low Byte
           =2 SFR (CAN0MV1H, 0xBB);                  // Message Valid 1 High Byte
           =2 SFR (CAN0MV2L, 0xBC);                  // Message Valid 2 Low Byte
           =2 SFR (CAN0MV2H, 0xBD);                  // Message Valid 2 High Byte
           =2 SFR (CAN0IF1CRL, 0xBE);                // IF1 Command Request Low Byte
           =2 SFR (CAN0IF1CRH, 0xBF);                // IF1 Command Request High Byte
           =2 SFR (CAN0CN, 0xC0);                    // CAN Control Register Low Byte
           =2 SFR (CAN0IF1CML, 0xC2);                // IF1 Command Mask Low Byte
           =2 SFR (CAN0IF1CMH, 0xC3);                // IF1 Command Mask High Byte
           =2 SFR (CAN0IF1M1L, 0xC4);                // IF1 Mask 1 Low Byte
           =2 SFR (CAN0IF1M1H, 0xC5);                // IF1 Mask 1 High Byte
           =2 SFR (CAN0IF1M2L, 0xC6);                // IF1 Mask 2 Low Byte
           =2 SFR (CAN0IF1M2H, 0xC7);                // IF1 Mask 2 High Byte
           =2 SFR (CAN0IF1A1L, 0xCA);                // IF1 Arbitration 1 Low Byte
           =2 SFR (CAN0IF1A1H, 0xCB);                // IF1 Arbitration 1 High Byte
           =2 SFR (CAN0IF1A2L, 0xCC);                // IF1 Arbitration 2 Low Byte
           =2 SFR (CAN0IF1A2H, 0xCD);                // IF1 Arbitration 2 High Byte
           =2 SFR (CAN0IF2MCL, 0xCE);                // IF2 Message Control Low Byte
           =2 SFR (CAN0IF2MCH, 0xCF);                // IF2 Message Control High Byte
           =2 SFR (CAN0IF1MCL, 0xD2);                // IF1 Message Control Low Byte
           =2 SFR (CAN0IF1MCH, 0xD3);                // IF1 Message Control High Byte
           =2 SFR (CAN0IF1DA1L, 0xD4);               // IF1 Data A 1 Low Byte
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 39  

           =2 SFR (CAN0IF1DA1H, 0xD5);               // IF1 Data A 1 High Byte
           =2 SFR (CAN0IF1DA2L, 0xD6);               // IF1 Data A 2 Low Byte
           =2 SFR (CAN0IF1DA2H, 0xD7);               // IF1 Data A 2 High Byte
           =2 SFR (CAN0IF1DB1L, 0xDA);               // IF1 Data B 1 Low Byte
           =2 SFR (CAN0IF1DB1H, 0xDB);               // IF1 Data B 1 High Byte
           =2 SFR (CAN0IF1DB2L, 0xDC);               // IF1 Data B 2 Low Byte
           =2 SFR (CAN0IF1DB2H, 0xDD);               // IF1 Data B 2 High Byte
           =2 SFR (CAN0IF2CRL, 0xDE);                // IF2 Command Request Low Byte
           =2 SFR (CAN0IF2CRH, 0xDF);                // IF2 Command Request High Byte
           =2 SFR (CAN0IF2CML, 0xE2);                // IF2 Command Mask Low Byte
           =2 SFR (CAN0IF2CMH, 0xE3);                // IF2 Command Mask High Byte
           =2 SFR (CAN0IF2M1L, 0xEA);                // IF2 Mask 1 Low Byte
           =2 SFR (CAN0IF2M1H, 0xEB);                // IF2 Mask 1 High Byte
           =2 SFR (CAN0IF2M2L, 0xEC);                // IF2 Mask 2 Low Byte
           =2 SFR (CAN0IF2M2H, 0xED);                // IF2 Mask 2 High Byte
           =2 SFR (CAN0IF2A1L, 0xEE);                // IF2 Arbitration 1 Low Byte
           =2 SFR (CAN0IF2A1H, 0xEF);                // IF2 Arbitration 1 High Byte
           =2 SFR (CAN0IF2A2L, 0xF2);                // IF2 Arbitration 2 Low Byte
           =2 SFR (CAN0IF2A2H, 0xF3);                // IF2 Arbitration 2 High Byte
           =2 SFR (CAN0IF2DA1L, 0xF6);               // IF2 Data A 1 Low Byte
           =2 SFR (CAN0IF2DA1H, 0xF7);               // IF2 Data A 1 High Byte
           =2 SFR (CAN0IF2DA2L, 0xFA);               // IF2 Data A 2 Low Byte
           =2 SFR (CAN0IF2DA2H, 0xFB);               // IF2 Data A 2 High Byte
           =2 SFR (CAN0IF2DB1L, 0xFC);               // IF2 Data B 1 Low Byte
           =2 SFR (CAN0IF2DB1H, 0xFD);               // IF2 Data B 1 High Byte
           =2 SFR (CAN0IF2DB2L, 0xFE);               // IF2 Data B 2 Low Byte
           =2 SFR (CAN0IF2DB2H, 0xFF);               // IF2 Data B 2 High Byte
           =2 
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // 16-bit Register Definitions (might not be supported by all compilers)
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 SFR16 (DP, 0x82);                      // Data Pointer
           =2 SFR16 (TMR3RL, 0x92);                  // Timer 3 Reload
           =2 SFR16 (TMR5CAP, 0x92);                 // Timer 5 Capture
           =2 SFR16 (TMR3, 0x94);                    // Timer 3 Capture / Reload
           =2 SFR16 (TMR5, 0x94);                    // Timer 5
           =2 SFR16 (SBRL0, 0xAC);                   // UART0 Reload
           =2 SFR16 (ADC0, 0xBD);                    // ADC0 data
           =2 SFR16 (ADC0GT, 0xC3);                  // ADC0 Greater Than Window
           =2 SFR16 (ADC0LT, 0xC5);                  // ADC0 Less Than Window
           =2 SFR16 (TMR2RL, 0xCA);                  // Timer 2 Reload
           =2 SFR16 (TMR4CAP, 0xCA);                 // Timer 4 Capture
           =2 SFR16 (TMR2, 0xCC);                    // Timer 2 Capture / Reload
           =2 SFR16 (TMR4, 0xCC);                    // Timer 4
           =2 SFR16 (PCA0CP5, 0xCE);                 // PCA0 Module 5 Capture
           =2 SFR16 (PCA1CP11, 0xCE);                // PCA1 Module 11 Capture
           =2 SFR16 (PCA0CP1, 0xE9);                 // PCA0 Module 1 Capture
           =2 SFR16 (PCA1CP7, 0xE9);                 // PCA1 Module 7 Capture
           =2 SFR16 (PCA0CP2, 0xEB);                 // PCA0 Module 2 Capture
           =2 SFR16 (PCA1CP8, 0xEB);                 // PCA1 Module 8 Capture
           =2 SFR16 (PCA0CP3, 0xED);                 // PCA0 Module 3 Capture
           =2 SFR16 (PCA1CP9, 0xED);                 // PCA1 Module 9 Capture
           =2 SFR16 (PCA0, 0xF9);                    // PCA0 Counter
           =2 SFR16 (PCA1, 0xF9);                    // PCA1 Counter
           =2 SFR16 (PCA0CP0, 0xFB);                 // PCA0 Module 0 Capture
           =2 SFR16 (PCA1CP6, 0xFB);                 // PCA1 Module 6 Capture
           =2 SFR16 (PCA0CP4, 0xFD);                 // PCA0 Module 4 Capture
           =2 SFR16 (PCA1CP10, 0xFD);                 // PCA1 Module 10 Capture
           =2 
           =2 SFR16 (CAN0ERR, 0x96);                 // Error Counter
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 40  

           =2 SFR16 (CAN0BT, 0x9A);                  // Bit Timing Register
           =2 SFR16 (CAN0IID, 0x9C);                 // Interrupt Register
           =2 SFR16 (CAN0TR1, 0xA2);                 // Transmission Request 1
           =2 SFR16 (CAN0TR2, 0xA4);                 // Transmission Request 2
           =2 SFR16 (CAN0ND1, 0xAA);                 // New Data 1
           =2 SFR16 (CAN0ND2, 0xAC);                 // New Data 2
           =2 SFR16 (CAN0IP1, 0xAE);                 // Interrupt Pending 1
           =2 SFR16 (CAN0IP2, 0xB2);                 // Interrupt Pending 2
           =2 SFR16 (CAN0MV1, 0xBA);                 // Message Valid 1
           =2 SFR16 (CAN0MV2, 0xBC);                 // Message Valid 2
           =2 SFR16 (CAN0IF1CR, 0xBE);               // IF1 Command Request
           =2 SFR16 (CAN0IF1CM, 0xC2);               // IF1 Command Mask
           =2 SFR16 (CAN0IF1M1, 0xC4);               // IF1 Mask 1
           =2 SFR16 (CAN0IF1M2, 0xC6);               // IF1 Mask 2
           =2 SFR16 (CAN0IF1A1, 0xCA);               // IF1 Arbitration 1
           =2 SFR16 (CAN0IF1A2, 0xCC);               // IF1 Arbitration 2
           =2 SFR16 (CAN0IF1MC, 0xD2);               // IF1 Message Control
           =2 SFR16 (CAN0IF1DA1, 0xD4);              // IF1 Data A 1
           =2 SFR16 (CAN0IF1DA2, 0xD6);              // IF1 Data A 2
           =2 SFR16 (CAN0IF1DB1, 0xDA);              // IF1 Data B 1
           =2 SFR16 (CAN0IF1DB2, 0xDC);              // IF1 Data B 2
           =2 SFR16 (CAN0IF2CR, 0xDE);               // IF2 Command Request
           =2 SFR16 (CAN0IF2CM, 0xE2);               // IF2 Command Mask
           =2 SFR16 (CAN0IF2M1, 0xEA);               // IF2 Mask 1
           =2 SFR16 (CAN0IF2M2, 0xEC);               // IF2 Mask 2
           =2 SFR16 (CAN0IF2A1, 0xEE);               // IF2 Arbitration 1
           =2 SFR16 (CAN0IF2A2, 0xF2);               // IF2 Arbitration 2
           =2 SFR16 (CAN0IF2MC, 0xCE);               // IF2 Message Control
           =2 SFR16 (CAN0IF2DA1, 0xF6);              // IF2 Data A 1
           =2 SFR16 (CAN0IF2DA2, 0xFA);              // IF2 Data A 2
           =2 SFR16 (CAN0IF2DB1, 0xFC);              // IF2 Data B 1
           =2 SFR16 (CAN0IF2DB2, 0xFE);              // IF2 Data B 2
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // LIN0 Indirect Registers
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 #define  LIN0DT1   0x00                // LIN0 Data Byte 1
           =2 #define  LIN0DT2   0x01                // LIN0 Data Byte 2
           =2 #define  LIN0DT3   0x02                // LIN0 Data Byte 3
           =2 #define  LIN0DT4   0x03                // LIN0 Data Byte 4
           =2 #define  LIN0DT5   0x04                // LIN0 Data Byte 5
           =2 #define  LIN0DT6   0x05                // LIN0 Data Byte 6
           =2 #define  LIN0DT7   0x06                // LIN0 Data Byte 7
           =2 #define  LIN0DT8   0x07                // LIN0 Data Byte 8
           =2 #define  LIN0CTRL  0x08                // LIN0 Control
           =2 #define  LIN0ST    0x09                // LIN0 Status
           =2 #define  LIN0ERR   0x0A                // LIN0 Error
           =2 #define  LIN0SIZE  0x0B                // LIN0 Message Size
           =2 #define  LIN0DIV   0x0C                // LIN0 Divider
           =2 #define  LIN0MUL   0x0D                // LIN0 Multiplier
           =2 #define  LIN0ID    0x0E                // LIN0 Identifier
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // Address Definitions for Bit-addressable Registers
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 #define SFR_P0       0x80
           =2 #define SFR_TCON     0x88
           =2 #define SFR_P1       0x90
           =2 #define SFR_SCON0    0x98
           =2 #define SFR_SCON1    0x98
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 41  

           =2 #define SFR_P2       0xA0
           =2 #define SFR_IE       0xA8
           =2 #define SFR_P3       0xB0
           =2 #define SFR_IP       0xB8
           =2 #define SFR_SMB0CN   0xC0
           =2 #define SFR_TMR2CN   0xC8
           =2 #define SFR_TMR4CN   0xC8
           =2 #define SFR_PSW      0xD0
           =2 #define SFR_PCA0CN   0xD8
           =2 #define SFR_PCA1CN   0xD8
           =2 #define SFR_ACC      0xE0
           =2 #define SFR_ADC0CN   0xE8
           =2 #define SFR_B        0xF0
           =2 #define SFR_SPI0CN   0xF8
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // Bit Definitions
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // TCON 0x88
           =2 SBIT (TF1, SFR_TCON, 7);               // Timer 1 Overflow Flag
           =2 SBIT (TR1, SFR_TCON, 6);               // Timer 1 On/Off Control
           =2 SBIT (TF0, SFR_TCON, 5);               // Timer 0 Overflow Flag
           =2 SBIT (TR0, SFR_TCON, 4);               // Timer 0 On/Off Control
           =2 SBIT (IE1, SFR_TCON, 3);               // Ext. Interrupt 1 Edge Flag
           =2 SBIT (IT1, SFR_TCON, 2);               // Ext. Interrupt 1 Type
           =2 SBIT (IE0, SFR_TCON, 1);               // Ext. Interrupt 0 Edge Flag
           =2 SBIT (IT0, SFR_TCON, 0);               // Ext. Interrupt 0 Type
           =2 
           =2 // SCON0 0x98
           =2 SBIT (OVR0, SFR_SCON0, 7);             // UART0 Receive FIFO Overrun Flag
           =2 SBIT (PERR0, SFR_SCON0, 6);            // UART0 Parity Error Flag
           =2 SBIT (THRE0, SFR_SCON0, 5);            // UART0 Transmit Register Empty Flag
           =2 SBIT (REN0, SFR_SCON0, 4);             // UART0 RX Enable
           =2 SBIT (TBX0, SFR_SCON0, 3);             // UART0 Extra Transmission Bit
           =2 SBIT (RBX0, SFR_SCON0, 2);             // UART0 Extra Receive Bit
           =2 SBIT (TI0, SFR_SCON0, 1);              // UART0 TX Interrupt Flag
           =2 SBIT (RI0, SFR_SCON0, 0);              // UART0 RX Interrupt Flag
           =2 
           =2 // SCON1 0x98
           =2 SBIT (S1MODE, SFR_SCON1, 7);           // UART1 Mode 0
           =2                                        // Bit 6 UNUSED
           =2 SBIT (MCE1, SFR_SCON1, 5);             // UART1 Multiprocessor enable
           =2 SBIT (REN1, SFR_SCON1, 4);             // UART1 RX Enable
           =2 SBIT (TB81, SFR_SCON1, 3);             // UART1 TX Bit 8
           =2 SBIT (RB81, SFR_SCON1, 2);             // UART1 RX Bit 8
           =2 SBIT (TI1, SFR_SCON1, 1);              // UART1 TX Interrupt Flag
           =2 SBIT (RI1, SFR_SCON1, 0);              // UART1 RX Interrupt Flag
           =2 
           =2 // IE 0xA8
           =2 SBIT (EA, SFR_IE, 7);                  // Global Interrupt Enable
           =2 SBIT (ESPI0, SFR_IE, 6);               // SPI0 Interrupt Enable
           =2 SBIT (ET2, SFR_IE, 5);                 // Timer 2 Interrupt Enable
           =2 SBIT (ES0, SFR_IE, 4);                 // UART0 Interrupt Enable
           =2 SBIT (ET1, SFR_IE, 3);                 // Timer 1 Interrupt Enable
           =2 SBIT (EX1, SFR_IE, 2);                 // External Interrupt 1 Enable
           =2 SBIT (ET0, SFR_IE, 1);                 // Timer 0 Interrupt Enable
           =2 SBIT (EX0, SFR_IE, 0);                 // External Interrupt 0 Enable
           =2 
           =2 // IP 0xB8
           =2                                        // Bit 7 unused
           =2 SBIT (PSPI0, SFR_IP, 6);               // SPI0 Interrupt Priority
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 42  

           =2 SBIT (PT2, SFR_IP, 5);                 // Timer 2 Priority
           =2 SBIT (PS0, SFR_IP, 4);                 // UART0 Priority
           =2 SBIT (PS, SFR_IP, 4);                  // UART0 Priority
           =2 SBIT (PT1, SFR_IP, 3);                 // Timer 1 Priority
           =2 SBIT (PX1, SFR_IP, 2);                 // External Interrupt 1 Priority
           =2 SBIT (PT0, SFR_IP, 1);                 // Timer 0 Priority
           =2 SBIT (PX0, SFR_IP, 0);                 // External Interrupt 0 Priority
           =2 
           =2 // SMB0CN 0xC0
           =2 SBIT (MASTER, SFR_SMB0CN, 7);          // SMBus0 Master/Slave Indicator
           =2 SBIT (TXMODE, SFR_SMB0CN, 6);          // SMBus0 Transmit Mode Indicator
           =2 SBIT (STA, SFR_SMB0CN, 5);             // SMBus0 Start Flag
           =2 SBIT (STO, SFR_SMB0CN, 4);             // SMBus0 Stop Flag
           =2 SBIT (ACKRQ, SFR_SMB0CN, 3);           // SMBus0 Acknowledge Request
           =2 SBIT (ARBLOST, SFR_SMB0CN, 2);         // SMBus0 Arbitration Lost Indicator
           =2 SBIT (ACK, SFR_SMB0CN, 1);             // SMBus0 Acknowledge
           =2 SBIT (SI, SFR_SMB0CN, 0);              // SMBus0 Interrupt Flag
           =2 
           =2 // TMR2CN 0xC8
           =2 SBIT (TF2H, SFR_TMR2CN, 7);            // Timer 2 High-Byte Overflow Flag
           =2 SBIT (TF2L, SFR_TMR2CN, 6);            // Timer 2 Low-Byte  Overflow Flag
           =2 SBIT (TF2LEN, SFR_TMR2CN, 5);          // Timer 2 Low-Byte Flag Enable
           =2 SBIT (TF2CEN, SFR_TMR2CN, 4);          // Timer 2 Capture Enable
           =2 SBIT (T2SPLIT, SFR_TMR2CN, 3);         // Timer 2 Split-Mode Enable
           =2 SBIT (TR2, SFR_TMR2CN, 2);             // Timer 2 Run Enable
           =2 SBIT (T2RCLK, SFR_TMR2CN, 1);          // Timer 2 Xclk/Rclk Select
           =2 SBIT (T2XCLK, SFR_TMR2CN, 0);          // Timer 2 Clk/8 Clock Source
           =2 
           =2 // TMR4CN 0xC8
           =2 SBIT (TF4, SFR_TMR4CN, 7);             // Timer 4 Overflow/Underflow Flag
           =2 SBIT (EXF4, SFR_TMR4CN, 6);            // Timer 4 External Flag
           =2                                        // Bit 5 unused
           =2                                        // Bit 4 unused
           =2 SBIT (EXE4, SFR_TMR4CN, 3);            // Timer 4 External Enable
           =2 SBIT (TR4, SFR_TMR4CN, 2);             // Timer 4 Run Enable
           =2 SBIT (CT4, SFR_TMR4CN, 1);             // Timer 4 Counter/Timer Select
           =2 SBIT (CPRL4, SFR_TMR4CN, 0);           // Timer 4 Capture/Reload Select
           =2 
           =2 // PSW 0xD0
           =2 SBIT (CY, SFR_PSW, 7);                 // Carry Flag
           =2 SBIT (AC, SFR_PSW, 6);                 // Auxiliary Carry Flag
           =2 SBIT (F0, SFR_PSW, 5);                 // User Flag 0
           =2 SBIT (RS1, SFR_PSW, 4);                // Register Bank Select 1
           =2 SBIT (RS0, SFR_PSW, 3);                // Register Bank Select 0
           =2 SBIT (OV, SFR_PSW, 2);                 // Overflow Flag
           =2 SBIT (F1, SFR_PSW, 1);                 // User Flag 1
           =2 SBIT (P, SFR_PSW, 0);                  // Accumulator Parity Flag
           =2 
           =2 // PCA0CN 0xD8
           =2 SBIT (CF, SFR_PCA0CN, 7);              // PCA0 Counter Overflow Flag
           =2 SBIT (CR, SFR_PCA0CN, 6);              // PCA0 Counter Run Control Bit
           =2 SBIT (CCF5, SFR_PCA0CN, 5);            // PCA0 Module 5 Interrupt Flag
           =2 SBIT (CCF4, SFR_PCA0CN, 4);            // PCA0 Module 4 Interrupt Flag
           =2 SBIT (CCF3, SFR_PCA0CN, 3);            // PCA0 Module 3 Interrupt Flag
           =2 SBIT (CCF2, SFR_PCA0CN, 2);            // PCA0 Module 2 Interrupt Flag
           =2 SBIT (CCF1, SFR_PCA0CN, 1);            // PCA0 Module 1 Interrupt Flag
           =2 SBIT (CCF0, SFR_PCA0CN, 0);            // PCA0 Module 0 Interrupt Flag
           =2 
           =2 // PCA1CN 0xD8
           =2 SBIT (CF1, SFR_PCA1CN, 7);             // PCA1 Counter Overflow Flag
           =2 SBIT (CR1, SFR_PCA1CN, 6);             // PCA1 Counter Run Control Bit
           =2 SBIT (CCF11, SFR_PCA1CN, 5);           // PCA1 Module 11 Interrupt Flag
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 43  

           =2 SBIT (CCF10, SFR_PCA1CN, 4);           // PCA1 Module 10 Interrupt Flag
           =2 SBIT (CCF9, SFR_PCA1CN, 3);            // PCA1 Module 9 Interrupt Flag
           =2 SBIT (CCF8, SFR_PCA1CN, 2);            // PCA1 Module 8 Interrupt Flag
           =2 SBIT (CCF7, SFR_PCA1CN, 1);            // PCA1 Module 7 Interrupt Flag
           =2 SBIT (CCF6, SFR_PCA1CN, 0);            // PCA1 Module 6 Interrupt Flag
           =2 
           =2 // ADC0CN 0xE8
           =2 SBIT (AD0EN, SFR_ADC0CN, 7);           // ADC0 Enable
           =2 SBIT (BURSTEN, SFR_ADC0CN, 6);         // ADC0 Burst Enable
           =2 SBIT (AD0INT, SFR_ADC0CN, 5);          // ADC0 EOC Interrupt Flag
           =2 SBIT (AD0BUSY, SFR_ADC0CN, 4);         // ADC0 Busy Flag
           =2 SBIT (AD0WINT, SFR_ADC0CN, 3);         // ADC0 Window Compare Interrupt Flag
           =2 SBIT (AD0LJST, SFR_ADC0CN, 2);         // ADC0 Left Justified
           =2 SBIT (AD0CM1, SFR_ADC0CN, 1);          // ADC0 Start Of Conversion Mode Bit 1
           =2 SBIT (AD0CM0, SFR_ADC0CN, 0);          // ADC0 Start Of Conversion Mode Bit 0
           =2 
           =2 // SPI0CN 0xF8
           =2 SBIT (SPIF, SFR_SPI0CN, 7);            // SPI0 Interrupt Flag
           =2 SBIT (WCOL, SFR_SPI0CN, 6);            // SPI0 Write Collision Flag
           =2 SBIT (MODF, SFR_SPI0CN, 5);            // SPI0 Mode Fault Flag
           =2 SBIT (RXOVRN, SFR_SPI0CN, 4);          // SPI0 RX Overrun Flag
           =2 SBIT (NSSMD1, SFR_SPI0CN, 3);          // SPI0 Slave Select Mode 1
           =2 SBIT (NSSMD0, SFR_SPI0CN, 2);          // SPI0 Slave Select Mode 0
           =2 SBIT (TXBMT, SFR_SPI0CN, 1);           // SPI0 TX Buffer Empty Flag
           =2 SBIT (SPIEN, SFR_SPI0CN, 0);           // SPI0 Enable
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // Interrupt Priorities
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 #define INTERRUPT_INT0             0   // External Interrupt 0
           =2 #define INTERRUPT_TIMER0           1   // Timer 0 Overflow
           =2 #define INTERRUPT_INT1             2   // External Interrupt 1
           =2 #define INTERRUPT_TIMER1           3   // Timer 1 Overflow
           =2 #define INTERRUPT_UART0            4   // UART0
           =2 #define INTERRUPT_TIMER2           5   // Timer 2 Overflow
           =2 #define INTERRUPT_SPI0             6   // SPI0
           =2 #define INTERRUPT_SMBUS0           7   // SMBus0 Interface
           =2 #define INTERRUPT_ADC0_WINDOW      8   // ADC0 Window Comparison
           =2 #define INTERRUPT_ADC0_EOC         9   // ADC0 End Of Conversion
           =2 #define INTERRUPT_PCA0            10   // PCA0 Peripheral
           =2 #define INTERRUPT_COMPARATOR0     11   // Comparator 0 Comparison
           =2 #define INTERRUPT_COMPARATOR1     12   // Comparator 1 Comparison
           =2 #define INTERRUPT_TIMER3          13   // Timer 3 Overflow
           =2 #define INTERRUPT_LIN0            14   // LIN Bus Interrupt
           =2 #define INTERRUPT_VREG            15   // Voltage Regulator
           =2 #define INTERRUPT_CAN0            16   // CAN Bus Interrupt
           =2 #define INTERRUPT_PORT_MATCH      17   // Port Match
           =2 #define INTERRUPT_UART1           18   // UART1
           =2 #define INTERRUPT_PCA1            19   // PCA1 Peripheral
           =2 #define INTERRUPT_COMPARATOR2     20   // Comparator 2 Comparison
           =2 #define INTERRUPT_TIMER4          21   // Timer 4 Overflow
           =2 #define INTERRUPT_TIMER5          22   // Timer 5 Overflow
           =2 
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // SFR Page Definitions
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 #define  CONFIG_PAGE       0x0F        // System and Port Configuration Page
           =2 #define  ACTIVE_PAGE       0x00        // Active Use Page
           =2 #define  ACTIVE2_PAGE      0x10        // Active Use Page 2
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 44  

           =2 #define  CAN0_PAGE         0x0C        // CAN0 Registers
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // SDCC PDATA External Memory Paging Support
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 #if defined SDCC
           =2 
           =2 SFR(_XPAGE, 0xAA); // Point to the EMI0CN register
           =2 
           =2 #endif
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // Header File PreProcessor Directive
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 #endif                                 // #define C8051F580_DEFS_H
 607      =2  
 608      =2  //-----------------------------------------------------------------------------
 609      =2  // End Of File
 610      =2  //-----------------------------------------------------------------------------
   5      =1  #include "rtos_config.h"
   1      =2  #ifndef RTOS_CONFIG_H
   2      =2  #define RTOS_CONFIG_H
   3      =2  
   4      =2  #define MAX_TASK (3U)
   5      =2  #define SIZE_IDLE_STACK         (256U)
   6      =2  #define SIZE_TASK_STACK         (512U)
   7      =2  #define SIZE_SCHED_STACK        (1024U)
   8      =2  
   9      =2  #define SRAM_START                      (0x0000U)
  10      =2  #define SIZE_SRAM                       (8*1024U)
  11      =2  #define SRAM_END                        (SRAM_START + SIZE_SRAM)
  12      =2  
  13      =2  #define TASK_RUNNING_STATE      0
  14      =2  #define TASK_BLOCKED_STATE      1
  15      =2  #define TASK_READY_STATE        2 
  16      =2  
  17      =2  // Äá»a chá» báº¯t Äáº§u stack ná»i (trong IRAM)
  18      =2  #define configSTACK_START    0x30
  19      =2  
  20      =2  #define INTERRUPT_DISABLE (EA = 0)
  21      =2  #define INTERRUPT_ENABLE  (EA = 1)
  22      =2  
  23      =2  #endif
   6      =1  #include "Task.h"
   1      =2  #ifndef TASK_H_
   2      =2  #define TASK_H_
   3      =2  #include <compiler_defs.h>
   1      =3  //-----------------------------------------------------------------------------
   2      =3  // compiler_defs.h
   3      =3  //-----------------------------------------------------------------------------
   4      =3  // Portions of this file are copyright Maarten Brock
   5      =3  // http://sdcc.sourceforge.net
   6      =3  // Portions of this file are copyright 2010, Silicon Laboratories, Inc.
   7      =3  // http://www.silabs.com
   8      =3  //
   9      =3  // GNU LGPL boilerplate:
  10      =3  /** This library is free software; you can redistribute it and/or
  11      =3    * modify it under the terms of the GNU Lesser General Public
  12      =3    * License as published by the Free Software Foundation; either
  13      =3    * version 2.1 of the License, or (at your option) any later version.
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 45  

  14      =3    *
  15      =3    * This library is distributed in the hope that it will be useful,
  16      =3    * but WITHOUT ANY WARRANTY; without even the implied warranty of
  17      =3    * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  18      =3    * Lesser General Public License for more details.
  19      =3    *
  20      =3    * You should have received a copy of the GNU Lesser General Public
  21      =3    * License along with this library; if not, write to the Free Software
  22      =3    * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  23      =3    *
  24      =3    * In other words, you are welcome to use, share and improve this program.
  25      =3    * You are forbidden to forbid anyone else to use, share and improve
  26      =3    * what you give them. Help stamp out software-hoarding!
  27      =3  **/
  28      =3  // Program Description:
  29      =3  //
  30      =3  // **Important Note**: This header file should be included before including
  31      =3  // a device-specific header file such as C8051F300_defs.h.
  32      =3  //
  33      =3  // Macro definitions to accomodate 8051 compiler differences in specifying
  34      =3  // special function registers and other 8051-specific features such as NOP
  35      =3  // generation, and locating variables in memory-specific segments.  The
  36      =3  // compilers are identified by their unique predefined macros. See also:
  37      =3  // http://predef.sourceforge.net/precomp.html
  38      =3  //
  39      =3  // SBIT and SFR define special bit and special function registers at the given
  40      =3  // address. SFR16 and SFR32 define sfr combinations at adjacent addresses in
  41      =3  // little-endian format. SFR16E and SFR32E define sfr combinations without
  42      =3  // prerequisite byte order or adjacency. None of these multi-byte sfr
  43      =3  // combinations will guarantee the order in which they are accessed when read
  44      =3  // or written.
  45      =3  //
  46      =3  // SFR16X and SFR32X for 16 bit and 32 bit xdata registers are not defined
  47      =3  // to avoid portability issues because of compiler endianness.
  48      =3  //
  49      =3  // Example:
  50      =3  // // my_mcu.c: main 'c' file for my mcu
  51      =3  // #include <compiler_defs.h>  // this file
  52      =3  // #include <C8051xxxx_defs.h> // SFR definitions for specific MCU target
  53      =3  //
  54      =3  // SBIT  (P0_1, 0x80, 1);      // Port 0 pin 1
  55      =3  // SFR   (P0, 0x80);           // Port 0
  56      =3  // SFRX  (CPUCS, 0xE600);      // Cypress FX2 Control and Status register in
  57      =3  //                             // xdata memory at 0xE600
  58      =3  // SFR16 (TMR2, 0xCC);         // Timer 2, lsb at 0xCC, msb at 0xCD
  59      =3  // SFR16E(TMR0, 0x8C8A);       // Timer 0, lsb at 0x8A, msb at 0x8C
  60      =3  // SFR32 (MAC0ACC, 0x93);      // SiLabs C8051F120 32 bits MAC0 Accumulator,
  61      =3  //                             // lsb at 0x93, msb at 0x96
  62      =3  // SFR32E(SUMR, 0xE5E4E3E2);   // TI MSC1210 SUMR 32 bits Summation register,
  63      =3  //                             // lsb at 0xE2, msb at 0xE5
  64      =3  //
  65      =3  // Target:         C8051xxxx
  66      =3  // Tool chain:     Generic
  67      =3  // Command Line:   None
  68      =3  // 
  69      =3  // Release 2.6 - 14 DEC 2012 (GO)
  70      =3  //        -Added define for deprecated SDCC keyword 'at'
  71      =3  // Release 2.5 - 12 SEP 2012 (TP)
  72      =3  //    -Added defines for deprecated SDCC keywords bit and code
  73      =3  // Release 2.4 - 27 AUG 2012 (TP)
  74      =3  //    -Added defines for deprecated SDCC keywords interrupt, _asm, and _endasm
  75      =3  // Release 2.3 - 27 MAY 2010 (DM)
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 46  

  76      =3  //    -Removed 'LOCATED_VARIABLE' pragma from Keil because it is not supported
  77      =3  // Release 2.2 - 06 APR 2010 (ES)
  78      =3  //    -Removed 'PATHINCLUDE' pragma from Raisonance section
  79      =3  // Release 2.1 - 16 JUL 2009 (ES)
  80      =3  //    -Added SEGMENT_POINTER macro definitions for SDCC, Keil, and Raisonance
  81      =3  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for Raisonance
  82      =3  // Release 2.0 - 19 MAY 2009 (ES)
  83      =3  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for SDCC and Keil
  84      =3  // Release 1.9 - 23 OCT 2008 (ES)
  85      =3  //    -Updated Hi-Tech INTERRUPT and INTERRUPT_USING macro definitions
  86      =3  //    -Added SFR16 macro defintion for Hi-Tech
  87      =3  // Release 1.8 - 31 JUL 2008 (ES)
  88      =3  //    -Added INTERRUPT_USING and FUNCTION_USING macro's
  89      =3  //    -Added macro's for IAR
  90      =3  //    -Corrected Union definitions for Hi-Tech and added SFR16 macro defintion
  91      =3  // Release 1.7 - 11 SEP 2007 (BW)
  92      =3  //    -Added support for Raisonance EVAL 03.03.42 and Tasking Eval 7.2r1
  93      =3  // Release 1.6 - 27 AUG 2007 (BW)
  94      =3  //    -Updated copyright notice per agreement with Maartin Brock
  95      =3  //    -Added SDCC 2.7.0 "compiler.h" bug fixes
  96      =3  //    -Added memory segment defines (SEG_XDATA, for example)
  97      =3  // Release 1.5 - 24 AUG 2007 (BW)
  98      =3  //    -Added support for NOP () macro
  99      =3  //    -Added support for Hi-Tech ver 9.01
 100      =3  // Release 1.4 - 07 AUG 2007 (PKC)
 101      =3  //    -Removed FID and fixed formatting.
 102      =3  // Release 1.3 - 30 SEP 2007 (TP)
 103      =3  //    -Added INTERRUPT_PROTO_USING to properly support ISR context switching
 104      =3  //     under SDCC.
 105      =3  // Release 1.2 - (BW)
 106      =3  //    -Added support for U8,U16,U32,S8,S16,S32,UU16,UU32 data types
 107      =3  // Release 1.1 - (BW)
 108      =3  //    -Added support for INTERRUPT, INTERRUPT_USING, INTERRUPT_PROTO,
 109      =3  //     SEGMENT_VARIABLE, VARIABLE_SEGMENT_POINTER,
 110      =3  //     SEGMENT_VARIABLE_SEGMENT_POINTER, and LOCATED_VARIABLE
 111      =3  // Release 1.0 - 29 SEP 2006 (PKC)
 112      =3  //    -Initial revision
 113      =3  
 114      =3  //-----------------------------------------------------------------------------
 115      =3  // Header File Preprocessor Directive
 116      =3  //-----------------------------------------------------------------------------
 117      =3  
 118      =3  #ifndef COMPILER_DEFS_H
           =3 #define COMPILER_DEFS_H
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // Macro definitions
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 // SDCC - Small Device C Compiler
           =3 // http://sdcc.sourceforge.net
           =3 
           =3 #if defined SDCC
           =3 
           =3 #if (SDCC >= 300)
           =3 
           =3 #define interrupt __interrupt
           =3 #define _asm __asm
           =3 #define _endasm __endasm
           =3 #define bit __bit
           =3 #define code __code
           =3 #define at __at
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 47  

           =3 
           =3 #endif
           =3 
           =3 # define SEG_GENERIC
           =3 # define SEG_FAR   __xdata
           =3 # define SEG_DATA  __data
           =3 # define SEG_NEAR  __data
           =3 # define SEG_IDATA __idata
           =3 # define SEG_XDATA __xdata
           =3 # define SEG_PDATA __pdata
           =3 # define SEG_CODE  __code
           =3 # define SEG_BDATA __bdata
           =3 
           =3 # define SBIT(name, addr, bit)  __sbit  __at(addr+bit)                  name
           =3 # define SFR(name, addr)        __sfr   __at(addr)                      name
           =3 # define SFRX(name, addr)       xdata volatile unsigned char __at(addr) name
           =3 # define SFR16(name, addr)      __sfr16 __at(((addr+1U)<<8) | addr)     name
           =3 # define SFR16E(name, fulladdr) __sfr16 __at(fulladdr)                  name
           =3 # define SFR32(name, addr)      __sfr32 __at(((addr+3UL)<<24) | ((addr+2UL)<<16) | ((addr+1UL)<<8) | addr)
             - name
           =3 # define SFR32E(name, fulladdr) __sfr32 __at(fulladdr)                  name
           =3 
           =3 # define INTERRUPT(name, vector) void name (void) interrupt (vector)
           =3 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =3 # define INTERRUPT_PROTO(name, vector) void name (void) interrupt (vector)
           =3 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =3 
           =3 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using (regnum
             -)
           =3 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter) using (
             -regnum)
           =3 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =3 
           =3 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =3 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =3 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =3 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =3 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment at (addr) vartype name = init
           =3 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) locsegment at (addr) vartype name
           =3 
           =3 // used with UU16
           =3 # define LSB 0
           =3 # define MSB 1
           =3 
           =3 // used with UU32 (b0 is least-significant byte)
           =3 # define b0 0
           =3 # define b1 1
           =3 # define b2 2
           =3 # define b3 3
           =3 
           =3 typedef unsigned char U8;
           =3 typedef unsigned int U16;
           =3 typedef unsigned long U32;
           =3 
           =3 typedef signed char S8;
           =3 typedef signed int S16;
           =3 typedef signed long S32;
           =3 
           =3 typedef union UU16
           =3 {
           =3    U16 U16;
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 48  

           =3    S16 S16;
           =3    U8 U8[2];
           =3    S8 S8[2];
           =3 } UU16;
           =3 
           =3 typedef union UU32
           =3 {
           =3    U32 U32;
           =3    S32 S32;
           =3    UU16 UU16[2];
           =3    U16 U16[2];
           =3    S16 S16[2];
           =3    U8 U8[4];
           =3    S8 S8[4];
           =3 } UU32;
           =3 
           =3 // NOP () macro support
           =3 #define NOP() _asm NOP _endasm
           =3 
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 // Raisonance (must be placed before Keil C51)
           =3 // http://www.raisonance.com
           =3 
           =3 #elif defined __RC51__
           =3 
           =3 //#error Raisonance C51 detected.
           =3 
           =3 # define SEG_GENERIC generic     //SEG_GENERIC only applies to pointers in Raisonance, not variables.
           =3 # define SEG_FAR   xdata
           =3 # define SEG_DATA  data
           =3 # define SEG_NEAR  data
           =3 # define SEG_IDATA idata
           =3 # define SEG_XDATA xdata
           =3 # define SEG_PDATA pdata
           =3 # define SEG_CODE  code
           =3 # define SEG_BDATA bdata
           =3 
           =3 # define SBIT(name, addr, bit)  at (addr+bit) sbit         name
           =3 # define SFR(name, addr)        sfr at addr                name
           =3 # define SFR16(name, addr)      sfr16 at addr              name
           =3 # define SFR16E(name, fulladdr) /* not supported */
           =3 # define SFR32(name, fulladdr)  /* not supported */
           =3 # define SFR32E(name, fulladdr) /* not supported */
           =3 
           =3 # define INTERRUPT(name, vector) void name (void) interrupt vector
           =3 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =3 # define INTERRUPT_PROTO(name, vector) void name (void)
           =3 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =3 
           =3 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
           =3 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =3 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =3 
           =3 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =3 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =3 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =3 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =3 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) at addr locsegment vartype name
           =3 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) at addr locsegment vartype name
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 49  

           =3 
           =3 
           =3 // used with UU16
           =3 # define LSB 1
           =3 # define MSB 0
           =3 
           =3 // used with UU32 (b0 is least-significant byte)
           =3 # define b0 3
           =3 # define b1 2
           =3 # define b2 1
           =3 # define b3 0
           =3 
           =3 typedef unsigned char U8;
           =3 typedef unsigned int U16;
           =3 typedef unsigned long U32;
           =3 
           =3 typedef signed char S8;
           =3 typedef signed int S16;
           =3 typedef signed long S32;
           =3 
           =3 typedef union UU16
           =3 {
           =3    U16 U16;
           =3    S16 S16;
           =3    U8 U8[2];
           =3    S8 S8[2];
           =3 } UU16;
           =3 
           =3 typedef union UU32
           =3 {
           =3    U32 U32;
           =3    S32 S32;
           =3    UU16 UU16[2];
           =3    U16 U16[2];
           =3    S16 S16[2];
           =3    U8 U8[4];
           =3    S8 S8[4];
           =3 } UU32;
           =3 
           =3 // NOP () macro support -- NOP is opcode 0x00
           =3 #define NOP() asm { 0x00 }
           =3 
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 
           =3 // Keil C51
           =3 // http://www.keil.com
           =3 
           =3 #elif defined __C51__
           =3 
           =3 //#error Keil C51 detected.
           =3 
           =3 # define SEG_GENERIC
           =3 # define SEG_FAR   xdata
           =3 # define SEG_DATA  data
           =3 # define SEG_NEAR  data
           =3 # define SEG_IDATA idata
           =3 # define SEG_XDATA xdata
           =3 # define SEG_PDATA pdata
           =3 # define SEG_CODE  code
           =3 # define SEG_BDATA bdata
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 50  

           =3 
           =3 # define SBIT(name, addr, bit)  sbit  name = addr^bit
           =3 # define SFR(name, addr)        sfr   name = addr
           =3 # define SFR16(name, addr)      sfr16 name = addr
           =3 # define SFR16E(name, fulladdr) /* not supported */
           =3 # define SFR32(name, fulladdr)  /* not supported */
           =3 # define SFR32E(name, fulladdr) /* not supported */
           =3 
           =3 # define INTERRUPT(name, vector) void name (void) interrupt vector
           =3 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =3 # define INTERRUPT_PROTO(name, vector) void name (void)
           =3 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =3 
           =3 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
           =3 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =3 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =3 
           =3 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =3 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =3 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =3 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =3 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) vartype locsegment name _at_ addr
           =3 
           =3 // used with UU16
           =3 # define LSB 1
           =3 # define MSB 0
           =3 
           =3 // used with UU32 (b0 is least-significant byte)
           =3 # define b0 3
           =3 # define b1 2
           =3 # define b2 1
           =3 # define b3 0
           =3 
           =3 typedef unsigned char U8;
           =3 typedef unsigned int U16;
           =3 typedef unsigned long U32;
           =3 
           =3 typedef signed char S8;
           =3 typedef signed int S16;
           =3 typedef signed long S32;
           =3 
           =3 typedef union UU16
           =3 {
           =3    U16 U16;
           =3    S16 S16;
           =3    U8 U8[2];
           =3    S8 S8[2];
           =3 } UU16;
           =3 
           =3 typedef union UU32
           =3 {
           =3    U32 U32;
           =3    S32 S32;
           =3    UU16 UU16[2];
           =3    U16 U16[2];
           =3    S16 S16[2];
           =3    U8 U8[4];
           =3    S8 S8[4];
           =3 } UU32;
           =3 
           =3 // NOP () macro support
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 51  

           =3 extern void _nop_ (void);
           =3 #define NOP() _nop_()
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 // Hi-Tech 8051
           =3 // http://www.htsoft.com
           =3 
           =3 #elif defined HI_TECH_C
           =3 
           =3 # define SEG_GENERIC
           =3 # define SEG_FAR   far
           =3 # define SEG_DATA  data
           =3 # define SEG_NEAR  near
           =3 # define SEG_IDATA idata
           =3 # define SEG_XDATA xdata
           =3 # define SEG_PDATA pdata
           =3 # define SEG_CODE  code
           =3 # define SEG_BDATA bdata
           =3 
           =3 
           =3 # define SBIT(name, addr, thebit) static volatile bit name @ (addr + thebit)
           =3 # define SFR(name, addr)          static volatile unsigned char name @ addr
           =3 # define SFR16(name, addr)        static volatile unsigned int name @ addr
           =3 # define SFR16E(name, fulladdr) /* not supported */
           =3 # define SFR32(name, fulladdr)  /* not supported */
           =3 # define SFR32E(name, fulladdr) /* not supported */
           =3 
           =3 # define INTERRUPT(name, vector)       void name (void) interrupt vector
           =3 # define INTERRUPT_PROTO(name, vector)
           =3 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =3 # define INTERRUPT_PROTO_USING(name, vector, regnum)
           =3 
           =3 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =3 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =3 // Note: Hi-Tech does not support functions using different register banks. Register
           =3 //       banks can only be specified in interrupts. If a function is called from
           =3 //       inside an interrupt, it will use the same register bank as the interrupt.
           =3 
           =3 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =3 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =3 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =3 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment vartype name @ addr
           =3 
           =3 // used with UU16
           =3 # define LSB 0
           =3 # define MSB 1
           =3 
           =3 // used with UU32 (b0 is least-significant byte)
           =3 # define b0 0
           =3 # define b1 1
           =3 # define b2 2
           =3 # define b3 3
           =3 
           =3 typedef unsigned char U8;
           =3 typedef unsigned int U16;
           =3 typedef unsigned long U32;
           =3 
           =3 typedef signed char S8;
           =3 typedef signed int S16;
           =3 typedef signed long S32;
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 52  

           =3 
           =3 typedef union UU16
           =3 {
           =3    U16 U16;
           =3    S16 S16;
           =3    U8 U8[2];
           =3    S8 S8[2];
           =3 } UU16;
           =3 
           =3 typedef union UU32
           =3 {
           =3    U32 U32;
           =3    S32 S32;
           =3    UU16 UU16[2];
           =3    U16 U16[2];
           =3    S16 S16[2];
           =3    U8 U8[4];
           =3    S8 S8[4];
           =3 } UU32;
           =3 
           =3 // NOP () macro support
           =3 #define NOP() asm(" nop ")
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 // Tasking / Altium
           =3 // http://www.altium.com/tasking
           =3 
           =3 
           =3 #elif defined _CC51
           =3 
           =3 # define SEG_GENERIC
           =3 # define SEG_FAR   _xdat
           =3 # define SEG_DATA  _data
           =3 # define SEG_NEAR  _data
           =3 # define SEG_IDATA _idat
           =3 # define SEG_XDATA _xdat
           =3 # define SEG_PDATA _pdat
           =3 # define SEG_CODE  _rom
           =3 # define SEG_BDATA _bdat
           =3 
           =3 # define SBIT(name, addr, bit)  _sfrbit  name _at(addr+bit)
           =3 # define SFR(name, addr)        _sfrbyte name _at(addr)
           =3 # define SFRX(name, addr)       _xdat volatile unsigned char name _at(addr)
           =3 #if _CC51 > 71
           =3 # define SFR16(name, addr)      _sfrword _little name _at(addr)
           =3 #else
           =3 # define SFR16(name, addr)      /* not supported */
           =3 #endif
           =3 # define SFR16E(name, fulladdr) /* not supported */
           =3 # define SFR32(name, fulladdr)  /* not supported */
           =3 # define SFR32E(name, fulladdr) /* not supported */
           =3 
           =3 # define INTERRUPT(name, vector) _interrupt (vector) void name (void)
           =3 # define INTERRUPT_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =3 # define INTERRUPT_PROTO(name, vector) _interrupt (vector) void name (void)
           =3 # define INTERRUPT_PROTO_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =3 
           =3 // When calling FUNCTION_USING in Tasking, the function must be called from an interrupt or Main which
           =3 // is also using the same register bank. If not, the compiler will generate an error.
           =3 # define FUNCTION_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (parameter
             -)
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 53  

           =3 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (par
             -ameter)
           =3 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =3 
           =3 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =3 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =3 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =3 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) vartype locsegment name _at( addr )
           =3 
           =3 // used with UU16
           =3 # define LSB 1
           =3 # define MSB 0
           =3 
           =3 // used with UU32 (b0 is least-significant byte)
           =3 # define b0 3
           =3 # define b1 2
           =3 # define b2 1
           =3 # define b3 0
           =3 
           =3 typedef unsigned char U8;
           =3 typedef unsigned int U16;
           =3 typedef unsigned long U32;
           =3 
           =3 typedef signed char S8;
           =3 typedef signed int S16;
           =3 typedef signed long S32;
           =3 
           =3 typedef union UU16
           =3 {
           =3    U16 U16;
           =3    S16 S16;
           =3    U8 U8[2];
           =3    S8 S8[2];
           =3 } UU16;
           =3 
           =3 typedef union UU32
           =3 {
           =3    U32 U32;
           =3    S32 S32;
           =3    UU16 UU16[2];
           =3    U16 U16[2];
           =3    S16 S16[2];
           =3    U8 U8[4];
           =3    S8 S8[4];
           =3 } UU32;
           =3 
           =3 // NOP () macro support
           =3 extern void _nop (void);
           =3 #define NOP() _nop()
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 
           =3 // IAR 8051
           =3 // http://www.iar.com
           =3 
           =3 #elif defined __ICC8051__
           =3 
           =3 #include <stdbool.h>
           =3 #include <intrinsics.h>
           =3 
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 54  

           =3 # define SBIT(name, addr, bit)  __bit __no_init volatile bool name @ (addr+bit)
           =3 # define SFR(name, addr)        __sfr __no_init volatile unsigned char name @ addr
           =3 # define SFRX(name, addr)       __xdata __no_init volatile unsigned char name @ addr
           =3 # define SFR16(name, addr)      __sfr __no_init volatile unsigned int  name @ addr
           =3 # define SFR16E(name, fulladdr) /* not supported */
           =3 # define SFR32(name, fulladdr) /* not supported */
           =3 # define SFR32E(name, fulladdr) /* not supported */
           =3 
           =3 # define SEG_GENERIC __generic
           =3 # define SEG_FAR  __xdata
           =3 # define SEG_DATA __data
           =3 # define SEG_NEAR __data
           =3 # define SEG_IDATA __idata
           =3 # define SEG_XDATA __xdata
           =3 # define SEG_PDATA __pdata
           =3 # define SEG_CODE  __code
           =3 # define SEG_BDATA __bdata
           =3 
           =3 #define bit bool
           =3 
           =3 # define _PPTOSTR_(x) #x
           =3 # define _PPARAM_(address) _PPTOSTR_(vector=address * 8 + 3)
           =3 # define _PPARAM2_(regbank) _PPTOSTR_(register_bank=regbank)
           =3 # define INTERRUPT(name, vector) _Pragma(_PPARAM_(vector)) __interrupt void name(void)
           =3 # define INTERRUPT_PROTO(name, vector)  __interrupt void name(void)
           =3 # define INTERRUPT_USING(name, vector, regnum) _Pragma(_PPARAM2_(regnum)) _Pragma(_PPARAM_(vector)) __inte
             -rrupt void name(void)
           =3 # define INTERRUPT_PROTO_USING(name, vector, regnum) __interrupt void name(void)
           =3 
           =3 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =3 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =3 // Note: IAR does not support functions using different register banks. Register
           =3 //       banks can only be specified in interrupts. If a function is called from
           =3 //       inside an interrupt, it will use the same register bank as the interrupt.
           =3 
           =3 # define SEGMENT_VARIABLE(name, vartype, locsegment)  locsegment vartype name
           =3 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment  * name
           =3 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =3 
           =3 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment __no_init vartype name @ addr
           =3 
           =3 // used with UU16
           =3 # define LSB 0
           =3 # define MSB 1
           =3 
           =3 // used with UU32 (b0 is least-significant byte)
           =3 # define b0 0
           =3 # define b1 1
           =3 # define b2 2
           =3 # define b3 3
           =3 
           =3 typedef unsigned char U8;
           =3 typedef unsigned int U16;
           =3 typedef unsigned long U32;
           =3 
           =3 typedef signed char S8;
           =3 typedef signed int S16;
           =3 typedef signed long S32;
           =3 
           =3 typedef union UU16
           =3 {
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 55  

           =3    U16 U16;
           =3    S16 S16;
           =3    U8 U8[2];
           =3    S8 S8[2];
           =3 } UU16;
           =3 
           =3 typedef union UU32
           =3 {
           =3    U32 U32;
           =3    S32 S32;
           =3    UU16 UU16[2];
           =3    U16 U16[2];
           =3    S16 S16[2];
           =3    U8 U8[4];
           =3    S8 S8[4];
           =3 } UU32;
           =3 
           =3 
           =3 #define NOP() __no_operation();
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 // Crossware
           =3 // http://www.crossware.com
           =3 
           =3 #elif defined _XC51_VER
           =3 # define SBIT(name, addr, bit)  _sfrbit  name = (addr+bit)
           =3 # define SFR(name, addr)        _sfr     name = addr
           =3 # define SFR16(name, addr)      _sfrword name = addr
           =3 # define SFR16E(name, fulladdr) /* not supported */
           =3 # define SFR32(name, fulladdr)  /* not supported */
           =3 # define SFR32E(name, fulladdr) /* not supported */
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 // Wickenhäuser
           =3 // http://www.wickenhaeuser.de
           =3 
           =3 #elif defined __UC__
           =3 # define SBIT(name, addr, bit)  unsigned char bit  name @ (addr+bit)
           =3 # define SFR(name, addr)        near unsigned char name @ addr
           =3 # define SFR16(name, addr)      /* not supported */
           =3 # define SFR16E(name, fulladdr) /* not supported */
           =3 # define SFR32(name, fulladdr)  /* not supported */
           =3 # define SFR32E(name, fulladdr) /* not supported */
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 // Default
           =3 // Unknown compiler
           =3 
           =3 #else
           =3 # warning unrecognized compiler
           =3 # define SBIT(name, addr, bit)  volatile bool           name
           =3 # define SFR(name, addr)        volatile unsigned char  name
           =3 # define SFRX(name, addr)       volatile unsigned char  name
           =3 # define SFR16(name, addr)      volatile unsigned short name
           =3 # define SFR16E(name, fulladdr) volatile unsigned short name
           =3 # define SFR32(name, fulladdr)  volatile unsigned long  name
           =3 # define SFR32E(name, fulladdr) volatile unsigned long  name
           =3 
           =3 #endif
           =3 
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 56  

           =3 //-----------------------------------------------------------------------------
           =3 // Header File PreProcessor Directive
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 #endif                                 // #define COMPILER_DEFS_H
 689      =3  
 690      =3  //-----------------------------------------------------------------------------
 691      =3  // End Of File
 692      =3  //-----------------------------------------------------------------------------
   4      =2  #include <C8051F580_defs.h>            // SFR declarations
   1      =3  //-----------------------------------------------------------------------------
   2      =3  // C8051F580_defs.h
   3      =3  //-----------------------------------------------------------------------------
   4      =3  // Copyright 2008, Silicon Laboratories, Inc.
   5      =3  // http://www.silabs.com
   6      =3  //
   7      =3  // Program Description:
   8      =3  //
   9      =3  // Register/bit definitions for the C8051F58x family.
  10      =3  // **Important Note**: The compiler_defs.h header file should be included
  11      =3  // before including this header file.
  12      =3  //
  13      =3  // Target:         C8051F580/1/2/3/4/5/6/7,8/9-F590/1
  14      =3  // Tool chain:     Generic
  15      =3  // Command Line:   None
  16      =3  //
  17      =3  // Release 0.6 - 20 AUG 2012 (TP)
  18      =3  //    -Added #define for _XPAGE to provide support for SDCC memory paging
  19      =3  //     (pdata)
  20      =3  //
  21      =3  // Release 0.5 - 10 SEP 2011 (GP)
  22      =3  //    - Fixed SFR16 definition for CAN0IF2MC
  23      =3  //
  24      =3  // Release 0.4 - 08 OCT 2010 (TP)
  25      =3  //    - Fixed bit definitions for SCON0
  26      =3  //
  27      =3  // Release 0.3 - 01 APR 2009 (GP)
  28      =3  //    - Added SN0-SN3
  29      =3  //
  30      =3  // Release 0.2 - 29 JUL 2008 (ADT)
  31      =3  //    - Added Timer 4 bit definitions
  32      =3  //
  33      =3  // Release 0.1 - 09 JUL 2008 (GP)
  34      =3  //    - Initial Revision
  35      =3  //
  36      =3  //-----------------------------------------------------------------------------
  37      =3  // Header File Preprocessor Directive
  38      =3  //-----------------------------------------------------------------------------
  39      =3  
  40      =3  #ifndef C8051F580_DEFS_H
           =3 #define C8051F580_DEFS_H
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // Page 0, Page 1 and Page F Registers
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 SFR (P0, 0x80);                        // Port 0 Latch
           =3 SFR (SP, 0x81);                        // Stack Pointer
           =3 SFR (DPL, 0x82);                       // Data Pointer Low
           =3 SFR (DPH, 0x83);                       // Data Pointer High
           =3 SFR (SFR0CN, 0x84);                    // SFR Page Control
           =3 SFR (SFRNEXT, 0x85);                   // SFR stack next page
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 57  

           =3 SFR (SFRLAST, 0x86);                   // SFR stack last page
           =3 SFR (PCON, 0x87);                      // Power Control
           =3 SFR (TCON, 0x88);                      // Timer/Counter Control
           =3 SFR (TMOD, 0x89);                      // Timer/Counter Mode
           =3 SFR (TL0, 0x8A);                       // Timer/Counter 0 Low
           =3 SFR (TL1, 0x8B);                       // Timer/Counter 1 Low
           =3 SFR (TH0, 0x8C);                       // Timer/Counter 0 High
           =3 SFR (TH1, 0x8D);                       // Timer/Counter 1 High
           =3 SFR (CKCON, 0x8E);                     // Clock Control
           =3 SFR (PSCTL, 0x8F);                     // Program Store R/W Control
           =3 SFR (CLKSEL, 0x8F);                    // System clock select
           =3 SFR (P1, 0x90);                        // Port 1 Latch
           =3 SFR (TMR3CN, 0x91);                    // Timer/Counter 3 Control
           =3 SFR (TMR5CN, 0x91);                    // Timer/Counter 5 Control
           =3 SFR (TMR3RLL, 0x92);                   // Timer/Counter 3 Reload Low
           =3 SFR (TMR5CAPL, 0x92);                  // Timer/Counter 5 Capture Low
           =3 SFR (TMR3RLH, 0x93);                   // Timer/Counter 3 Reload High
           =3 SFR (TMR5CAPH, 0x93);                  // Timer/Counter 5 Capture High
           =3 SFR (TMR3L, 0x94);                     // Timer/Counter 3 Low
           =3 SFR (TMR5L, 0x94);                     // Timer/Counter 5 Low
           =3 SFR (TMR3H, 0x95);                     // Timer/Counter 3 High
           =3 SFR (TMR5H, 0x95);                     // Timer/Counter 5 High
           =3 SFR (TMR5CF, 0x96);                    // Timer/Counter 5 Configuration
           =3 SFR (CLKMUL, 0x97);                    // Clock Multiplier
           =3 SFR (SCON0, 0x98);                     // UART0 Control
           =3 SFR (SCON1, 0x98);                     // UART1 Control
           =3 SFR (SBUF0, 0x99);                     // UART0 Data Buffer
           =3 SFR (SBUF1, 0x99);                     // UART1 Data Buffer
           =3 SFR (CPT0CN, 0x9A);                    // Comparator 0 Control
           =3 SFR (CPT2CN, 0x9A);                    // Comparator 2 Control
           =3 SFR (CPT0MD, 0x9B);                    // Comparator 0 Mode
           =3 SFR (CPT2MD, 0x9B);                    // Comparator 2 Mode
           =3 SFR (CPT0MX, 0x9C);                    // Comparator 0 Mux
           =3 SFR (CPT2MX, 0x9C);                    // Comparator 2 Mux
           =3 SFR (CPT1CN, 0x9D);                    // Comparator 1 Control
           =3 SFR (CPT1MD, 0x9E);                    // Comparator 0 Mode
           =3 SFR (OSCIFIN, 0x9E);                   // Internal Oscillator Fine Control
           =3 SFR (CPT1MX, 0x9F);                    // Comparator 1 Mux
           =3 SFR (OSCXCN, 0x9F);                    // External Oscillator Control
           =3 SFR (P2, 0xA0);                        // Port 2 Latch
           =3 SFR (SPI0CFG, 0xA1);                   // SPI0 Configuration
           =3 SFR (OSCICN, 0xA1);                    // Internal Oscillator Control
           =3 SFR (SPI0CKR, 0xA2);                   // SPI0 Clock rate control
           =3 SFR (OSCICRS, 0xA2);                   // Internal Oscillator Coarse Control
           =3 SFR (SPI0DAT, 0xA3);                   // SPI0 Data Buffer
           =3 SFR (P0MDOUT, 0xA4);                   // Port 0 Output Mode
           =3 SFR (P1MDOUT, 0xA5);                   // Port 1 Output Mode
           =3 SFR (P2MDOUT, 0xA6);                   // Port 2 Output Mode
           =3 SFR (SFRPAGE, 0xA7);                   // SFR Page Select
           =3 SFR (IE, 0xA8);                        // Interrupt Enable
           =3 SFR (SMOD0, 0xA9);                     // Serial Port 0 Control
           =3 SFR (EMI0CN, 0xAA);                    // EMIF Control
           =3 SFR (EMI0TC, 0xAA);                    // EMIF Timing control
           =3 SFR (SBCON0, 0xAB);                    // UART0 Baud Rate Generator Control
           =3 SFR (SBRLL0, 0xAC);                    // UART0 Baud Rate Generator Low
           =3 SFR (SBRLH0, 0xAD);                    // UART0 Baud Rate Generator High
           =3 SFR (P3MAT, 0xAE);                     // Port 3 Match
           =3 SFR (P3MDOUT, 0xAE);                   // Port 3 Mode
           =3 SFR (P3MASK, 0xAF);                    // Port 3 Mask
           =3 SFR (P4MDOUT, 0xAF);                   // Port 4 Mode
           =3 SFR (P3, 0xB0);                        // Port 3 Latch
           =3 SFR (P2MAT, 0xB1);                     // Port 2 Match
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 58  

           =3 SFR (P2MASK, 0xB2);                    // Port 2 Mask
           =3 SFR (EMI0CF, 0xB2);                    // EMIF Configuration
           =3 SFR (P4, 0xB5);                        // Port 4 Latch
           =3 SFR (FLSCL, 0xB6);                     // Flash Scale
           =3 SFR (FLKEY, 0xB7);                     // Flash access limit
           =3 SFR (IP, 0xB8);                        // Interrupt Priority
           =3 SFR (SMB0ADR, 0xB9);                   // SMBus0 Slave address
           =3 SFR (ADC0TK, 0xBA);                    // ADC0 Tracking Mode Select
           =3 SFR (SMB0ADM, 0xBA);                   // SMBus0 Address Mask
           =3 SFR (ADC0MX, 0xBB);                    // AMUX0 Channel select
           =3 SFR (ADC0CF, 0xBC);                    // AMUX0 Channel configuration
           =3 SFR (ADC0L, 0xBD);                     // ADC0 Data Low
           =3 SFR (ADC0H, 0xBE);                     // ADC0 Data High
           =3 SFR (SMB0CN, 0xC0);                    // SMBus0 Control
           =3 SFR (SMB0CF, 0xC1);                    // SMBus0 Configuration
           =3 SFR (SMB0DAT, 0xC2);                   // SMBus0 Data
           =3 SFR (ADC0GTL, 0xC3);                   // ADC0 Greater-Than Compare Low
           =3 SFR (ADC0GTH, 0xC4);                   // ADC0 Greater-Than Compare High
           =3 SFR (ADC0LTL, 0xC5);                   // ADC0 Less-Than Compare Word Low
           =3 SFR (ADC0LTH, 0xC6);                   // ADC0 Less-Than Compare Word High
           =3 SFR (XBR3, 0xC6);                      // Port I/O Crossbar Control 3
           =3 SFR (XBR2, 0xC7);                      // Port I/O Crossbar Control 2
           =3 SFR (TMR2CN, 0xC8);                    // Timer/Counter 2 Control
           =3 SFR (TMR4CN, 0xC8);                    // Timer/Counter 4 Control
           =3 SFR (REG0CN, 0xC9);                    // Regulator Control
           =3 SFR (LIN0CF, 0xC9);                    // LIN 0 Configuration
           =3 SFR (TMR4CF, 0xC9);                    // Timer/Counter 4 Configuration
           =3 SFR (TMR2RLL, 0xCA);                   // Timer/Counter 2 Reload Low
           =3 SFR (TMR4CAPL, 0xCA);                  // Timer/Counter 4 Capture Low
           =3 SFR (TMR2RLH, 0xCB);                   // Timer/Counter 2 Reload High
           =3 SFR (TMR4CAPH, 0xCB);                  // Timer/Counter 4 Capture High
           =3 SFR (TMR2L, 0xCC);                     // Timer/Counter 2 Low
           =3 SFR (TMR4L, 0xCC);                     // Timer/Counter 4 Low
           =3 SFR (TMR2H, 0xCD);                     // Timer/Counter 2 High
           =3 SFR (TMR4H, 0xCD);                     // Timer/Counter 4 High
           =3 SFR (PCA0CPL5, 0xCE);                  // PCA0 Capture 5 Low
           =3 SFR (PCA1CPL11, 0xCE);                 // PCA1 Capture 11 Low
           =3 SFR (PCA0CPH5, 0xCF);                  // PCA0 Capture 5 High
           =3 SFR (PCA1CPH11, 0xCF);                 // PCA1 Capture 11 High
           =3 SFR (PSW, 0xD0);                       // Program Status Word
           =3 SFR (REF0CN, 0xD1);                    // Voltage Reference Control
           =3 SFR (LIN0DAT, 0xD2);                   // LIN0 Data
           =3 SFR (LIN0ADR, 0xD3);                   // LIN0 Address
           =3 SFR (P0SKIP, 0xD4);                    // Port 0 Skip
           =3 SFR (P1SKIP, 0xD5);                    // Port 1 Skip
           =3 SFR (P2SKIP, 0xD6);                    // Port 2 Skip
           =3 SFR (P3SKIP, 0xD7);                    // Port 3 Skip
           =3 SFR (PCA0CN, 0xD8);                    // PCA0 Control
           =3 SFR (PCA1CN, 0xD8);                    // PCA1 Control
           =3 SFR (PCA0MD, 0xD9);                    // PCA0 Mode
           =3 SFR (PCA1MD, 0xD9);                    // PCA1 Mode
           =3 SFR (PCA0PWM, 0xD9);                   // PCA0 PWM Control
           =3 SFR (PCA0CPM0, 0xDA);                  // PCA0 Module 0 Mode
           =3 SFR (PCA1CPM6, 0xDA);                  // PCA1 Module 6 Mode
           =3 SFR (PCA1PWM, 0xDA);                   // PCA1 PWM Control
           =3 SFR (PCA0CPM1, 0xDB);                  // PCA0 Module 1  Mode
           =3 SFR (PCA1CPM7, 0xDB);                  // PCA1 Module 7  Mode
           =3 SFR (PCA0CPM2, 0xDC);                  // PCA0 Module 2  Mode
           =3 SFR (PCA1CPM8, 0xDC);                  // PCA1 Module 8  Mode
           =3 SFR (PCA0CPM3, 0xDD);                  // PCA0 Module 3  Mode
           =3 SFR (PCA1CPM9, 0xDD);                  // PCA1 Module 9  Mode
           =3 SFR (PCA0CPM4, 0xDE);                  // PCA0 Module 4  Mode
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 59  

           =3 SFR (PCA1CPM10, 0xDE);                  // PCA1 Module 10 Mode
           =3 SFR (PCA0CPM5, 0xDF);                  // PCA0 Module 5  Mode
           =3 SFR (PCA1CPM11, 0xDF);                  // PCA1 Module 11 Mode
           =3 SFR (ACC, 0xE0);                       // Accumulator
           =3 SFR (XBR0, 0xE1);                      // Port I/O Crossbar Control 0
           =3 SFR (XBR1, 0xE2);                      // Port I/O Crossbar Control 1
           =3 SFR (CCH0CN, 0xE3);                    // Cache control
           =3 SFR (IT01CF, 0xE4);                    // INT0/INT1 Configuration
           =3 SFR (EIE1, 0xE6);                      // Extended Interrupt Enable 2
           =3 SFR (EIE2, 0xE7);                      // Extended Interrupt Enable 2
           =3 SFR (ADC0CN, 0xE8);                    // ADC0 Control
           =3 SFR (PCA0CPL1, 0xE9);                  // PCA0 Capture 1 Low
           =3 SFR (PCA1CPL1, 0xE9);                  // PCA1 Capture 7 Low
           =3 SFR (PCA0CPH1, 0xEA);                  // PCA0 Capture 1 High
           =3 SFR (PCA1CPH1, 0xEA);                  // PCA1 Capture 7 High
           =3 SFR (PCA0CPL2, 0xEB);                  // PCA0 Capture 2 Low
           =3 SFR (PCA1CPL2, 0xEB);                  // PCA1 Capture 8 Low
           =3 SFR (PCA0CPH2, 0xEC);                  // PCA0 Capture 2 High
           =3 SFR (PCA1CPH2, 0xEC);                  // PCA1 Capture 8 High
           =3 SFR (PCA0CPL3, 0xED);                  // PCA0 Capture 3 Low
           =3 SFR (PCA1CPL3, 0xED);                  // PCA1 Capture 9 Low
           =3 SFR (PCA0CPH3, 0xEE);                  // PCA0 Capture 3 High
           =3 SFR (PCA1CPH3, 0xEE);                  // PCA1 Capture 9 High
           =3 SFR (RSTSRC, 0xEF);                    // Reset Source Configuration/Status
           =3 SFR (B, 0xF0);                         // B Register
           =3 SFR (P0MAT, 0xF1);                     // Port 0 Match
           =3 SFR (P0MDIN, 0xF1);                    // Port 0 Input Mode
           =3 SFR (P0MASK, 0xF2);                    // Port 0 Mask
           =3 SFR (P1MDIN, 0xF2);                    // Port 1 Input Mode
           =3 SFR (P1MAT, 0xF3);                     // Port 1 Match
           =3 SFR (P2MDIN, 0xF3);                    // Port 2 Input Mode
           =3 SFR (P1MASK, 0xF4);                    // Port 1 Mask
           =3 SFR (P3MDIN, 0xF4);                    // Port 3 Input Mode
           =3 SFR (PSBANK, 0xF5);                    // Program Space Bank Select
           =3 SFR (EIP1, 0xF6);                      // External Interrupt Priority 1
           =3 SFR (EIP2, 0xF7);                      // External Interrupt Priority 2
           =3 SFR (SPI0CN, 0xF8);                    // SPI0 Control
           =3 SFR (PCA0L, 0xF9);                     // PCA0 Counter Low
           =3 SFR (PCA1L, 0xF9);                     // PCA1 Counter Low
           =3 SFR (SN0, 0xF9);                       // Serial Number 0
           =3 SFR (PCA0H, 0xFA);                     // PCA0 Counter High
           =3 SFR (PCA1H, 0xFA);                     // PCA1 Counter High
           =3 SFR (SN1, 0xFA);                       // Serial Number 1
           =3 SFR (PCA0CPL0, 0xFB);                  // PCA0 Capture 0 Low
           =3 SFR (PCA1CPL6, 0xFB);                  // PCA1 Capture 6 Low
           =3 SFR (SN2, 0xFB);                       // Serial Number 2
           =3 SFR (PCA0CPH0, 0xFC);                  // PCA0 Capture 0 High
           =3 SFR (PCA1CPH6, 0xFC);                  // PCA1 Capture 6 High
           =3 SFR (SN3, 0xFC);                       // Serial Number 3
           =3 SFR (PCA0CPL4, 0xFD);                  // PCA0 Capture 4 Low
           =3 SFR (PCA1CPL10, 0xFD);                 // PCA1 Capture 10 Low
           =3 SFR (PCA0CPH4, 0xFE);                  // PCA0 Capture 4 High
           =3 SFR (PCA1CPH10, 0xFE);                 // PCA1 Capture 10 High
           =3 SFR (VDM0CN, 0xFF);                    // VDD Monitor Control
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // Page C (CAN0) Registers
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 SFR (CAN0CFG, 0x92);                   // CAN0 Clock Configuration
           =3 SFR (CAN0STAT, 0x94);                  // Status Register Low Byte
           =3 SFR (CAN0ERRL, 0x96);                  // Error Counter Low Byte
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 60  

           =3 SFR (CAN0ERRH, 0x97);                  // Error Counter High Byte
           =3 SFR (CAN0BTL, 0x9A);                   // Bit Timing Register Low Byte
           =3 SFR (CAN0BTH, 0x9B);                   // Bit Timing Register High Byte
           =3 SFR (CAN0IIDL, 0x9C);                  // Interrupt Register Low Byte
           =3 SFR (CAN0IIDH, 0x9D);                  // Interrupt Register High Byte
           =3 SFR (CAN0TST, 0x9E);                   // Test Register Low Byte
           =3 SFR (CAN0BRPE, 0xA1);                  // BRP Extension Register Low Byte
           =3 SFR (CAN0TR1L, 0xA2);                  // Transmission Request 1 Low Byte
           =3 SFR (CAN0TR1H, 0xA3);                  // Transmission Request 1 High Byte
           =3 SFR (CAN0TR2L, 0xA4);                  // Transmission Request 2 Low Byte
           =3 SFR (CAN0TR2H, 0xA5);                  // Transmission Request 2 High Byte
           =3 SFR (CAN0ND1L, 0xAA);                  // New Data 1 Low Byte
           =3 SFR (CAN0ND1H, 0xAB);                  // New Data 1 High Byte
           =3 SFR (CAN0ND2L, 0xAC);                  // New Data 2 Low Byte
           =3 SFR (CAN0ND2H, 0xAD);                  // New Data 2 High Byte
           =3 SFR (CAN0IP1L, 0xAE);                  // Interrupt Pending 1 Low Byte
           =3 SFR (CAN0IP1H, 0xAF);                  // Interrupt Pending 1 High Byte
           =3 SFR (CAN0IP2L, 0xB2);                  // Interrupt Pending 2 Low Byte
           =3 SFR (CAN0IP2H, 0xB3);                  // Interrupt Pending 2 High Byte
           =3 SFR (CAN0MV1L, 0xBA);                  // Message Valid 1 Low Byte
           =3 SFR (CAN0MV1H, 0xBB);                  // Message Valid 1 High Byte
           =3 SFR (CAN0MV2L, 0xBC);                  // Message Valid 2 Low Byte
           =3 SFR (CAN0MV2H, 0xBD);                  // Message Valid 2 High Byte
           =3 SFR (CAN0IF1CRL, 0xBE);                // IF1 Command Request Low Byte
           =3 SFR (CAN0IF1CRH, 0xBF);                // IF1 Command Request High Byte
           =3 SFR (CAN0CN, 0xC0);                    // CAN Control Register Low Byte
           =3 SFR (CAN0IF1CML, 0xC2);                // IF1 Command Mask Low Byte
           =3 SFR (CAN0IF1CMH, 0xC3);                // IF1 Command Mask High Byte
           =3 SFR (CAN0IF1M1L, 0xC4);                // IF1 Mask 1 Low Byte
           =3 SFR (CAN0IF1M1H, 0xC5);                // IF1 Mask 1 High Byte
           =3 SFR (CAN0IF1M2L, 0xC6);                // IF1 Mask 2 Low Byte
           =3 SFR (CAN0IF1M2H, 0xC7);                // IF1 Mask 2 High Byte
           =3 SFR (CAN0IF1A1L, 0xCA);                // IF1 Arbitration 1 Low Byte
           =3 SFR (CAN0IF1A1H, 0xCB);                // IF1 Arbitration 1 High Byte
           =3 SFR (CAN0IF1A2L, 0xCC);                // IF1 Arbitration 2 Low Byte
           =3 SFR (CAN0IF1A2H, 0xCD);                // IF1 Arbitration 2 High Byte
           =3 SFR (CAN0IF2MCL, 0xCE);                // IF2 Message Control Low Byte
           =3 SFR (CAN0IF2MCH, 0xCF);                // IF2 Message Control High Byte
           =3 SFR (CAN0IF1MCL, 0xD2);                // IF1 Message Control Low Byte
           =3 SFR (CAN0IF1MCH, 0xD3);                // IF1 Message Control High Byte
           =3 SFR (CAN0IF1DA1L, 0xD4);               // IF1 Data A 1 Low Byte
           =3 SFR (CAN0IF1DA1H, 0xD5);               // IF1 Data A 1 High Byte
           =3 SFR (CAN0IF1DA2L, 0xD6);               // IF1 Data A 2 Low Byte
           =3 SFR (CAN0IF1DA2H, 0xD7);               // IF1 Data A 2 High Byte
           =3 SFR (CAN0IF1DB1L, 0xDA);               // IF1 Data B 1 Low Byte
           =3 SFR (CAN0IF1DB1H, 0xDB);               // IF1 Data B 1 High Byte
           =3 SFR (CAN0IF1DB2L, 0xDC);               // IF1 Data B 2 Low Byte
           =3 SFR (CAN0IF1DB2H, 0xDD);               // IF1 Data B 2 High Byte
           =3 SFR (CAN0IF2CRL, 0xDE);                // IF2 Command Request Low Byte
           =3 SFR (CAN0IF2CRH, 0xDF);                // IF2 Command Request High Byte
           =3 SFR (CAN0IF2CML, 0xE2);                // IF2 Command Mask Low Byte
           =3 SFR (CAN0IF2CMH, 0xE3);                // IF2 Command Mask High Byte
           =3 SFR (CAN0IF2M1L, 0xEA);                // IF2 Mask 1 Low Byte
           =3 SFR (CAN0IF2M1H, 0xEB);                // IF2 Mask 1 High Byte
           =3 SFR (CAN0IF2M2L, 0xEC);                // IF2 Mask 2 Low Byte
           =3 SFR (CAN0IF2M2H, 0xED);                // IF2 Mask 2 High Byte
           =3 SFR (CAN0IF2A1L, 0xEE);                // IF2 Arbitration 1 Low Byte
           =3 SFR (CAN0IF2A1H, 0xEF);                // IF2 Arbitration 1 High Byte
           =3 SFR (CAN0IF2A2L, 0xF2);                // IF2 Arbitration 2 Low Byte
           =3 SFR (CAN0IF2A2H, 0xF3);                // IF2 Arbitration 2 High Byte
           =3 SFR (CAN0IF2DA1L, 0xF6);               // IF2 Data A 1 Low Byte
           =3 SFR (CAN0IF2DA1H, 0xF7);               // IF2 Data A 1 High Byte
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 61  

           =3 SFR (CAN0IF2DA2L, 0xFA);               // IF2 Data A 2 Low Byte
           =3 SFR (CAN0IF2DA2H, 0xFB);               // IF2 Data A 2 High Byte
           =3 SFR (CAN0IF2DB1L, 0xFC);               // IF2 Data B 1 Low Byte
           =3 SFR (CAN0IF2DB1H, 0xFD);               // IF2 Data B 1 High Byte
           =3 SFR (CAN0IF2DB2L, 0xFE);               // IF2 Data B 2 Low Byte
           =3 SFR (CAN0IF2DB2H, 0xFF);               // IF2 Data B 2 High Byte
           =3 
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // 16-bit Register Definitions (might not be supported by all compilers)
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 SFR16 (DP, 0x82);                      // Data Pointer
           =3 SFR16 (TMR3RL, 0x92);                  // Timer 3 Reload
           =3 SFR16 (TMR5CAP, 0x92);                 // Timer 5 Capture
           =3 SFR16 (TMR3, 0x94);                    // Timer 3 Capture / Reload
           =3 SFR16 (TMR5, 0x94);                    // Timer 5
           =3 SFR16 (SBRL0, 0xAC);                   // UART0 Reload
           =3 SFR16 (ADC0, 0xBD);                    // ADC0 data
           =3 SFR16 (ADC0GT, 0xC3);                  // ADC0 Greater Than Window
           =3 SFR16 (ADC0LT, 0xC5);                  // ADC0 Less Than Window
           =3 SFR16 (TMR2RL, 0xCA);                  // Timer 2 Reload
           =3 SFR16 (TMR4CAP, 0xCA);                 // Timer 4 Capture
           =3 SFR16 (TMR2, 0xCC);                    // Timer 2 Capture / Reload
           =3 SFR16 (TMR4, 0xCC);                    // Timer 4
           =3 SFR16 (PCA0CP5, 0xCE);                 // PCA0 Module 5 Capture
           =3 SFR16 (PCA1CP11, 0xCE);                // PCA1 Module 11 Capture
           =3 SFR16 (PCA0CP1, 0xE9);                 // PCA0 Module 1 Capture
           =3 SFR16 (PCA1CP7, 0xE9);                 // PCA1 Module 7 Capture
           =3 SFR16 (PCA0CP2, 0xEB);                 // PCA0 Module 2 Capture
           =3 SFR16 (PCA1CP8, 0xEB);                 // PCA1 Module 8 Capture
           =3 SFR16 (PCA0CP3, 0xED);                 // PCA0 Module 3 Capture
           =3 SFR16 (PCA1CP9, 0xED);                 // PCA1 Module 9 Capture
           =3 SFR16 (PCA0, 0xF9);                    // PCA0 Counter
           =3 SFR16 (PCA1, 0xF9);                    // PCA1 Counter
           =3 SFR16 (PCA0CP0, 0xFB);                 // PCA0 Module 0 Capture
           =3 SFR16 (PCA1CP6, 0xFB);                 // PCA1 Module 6 Capture
           =3 SFR16 (PCA0CP4, 0xFD);                 // PCA0 Module 4 Capture
           =3 SFR16 (PCA1CP10, 0xFD);                 // PCA1 Module 10 Capture
           =3 
           =3 SFR16 (CAN0ERR, 0x96);                 // Error Counter
           =3 SFR16 (CAN0BT, 0x9A);                  // Bit Timing Register
           =3 SFR16 (CAN0IID, 0x9C);                 // Interrupt Register
           =3 SFR16 (CAN0TR1, 0xA2);                 // Transmission Request 1
           =3 SFR16 (CAN0TR2, 0xA4);                 // Transmission Request 2
           =3 SFR16 (CAN0ND1, 0xAA);                 // New Data 1
           =3 SFR16 (CAN0ND2, 0xAC);                 // New Data 2
           =3 SFR16 (CAN0IP1, 0xAE);                 // Interrupt Pending 1
           =3 SFR16 (CAN0IP2, 0xB2);                 // Interrupt Pending 2
           =3 SFR16 (CAN0MV1, 0xBA);                 // Message Valid 1
           =3 SFR16 (CAN0MV2, 0xBC);                 // Message Valid 2
           =3 SFR16 (CAN0IF1CR, 0xBE);               // IF1 Command Request
           =3 SFR16 (CAN0IF1CM, 0xC2);               // IF1 Command Mask
           =3 SFR16 (CAN0IF1M1, 0xC4);               // IF1 Mask 1
           =3 SFR16 (CAN0IF1M2, 0xC6);               // IF1 Mask 2
           =3 SFR16 (CAN0IF1A1, 0xCA);               // IF1 Arbitration 1
           =3 SFR16 (CAN0IF1A2, 0xCC);               // IF1 Arbitration 2
           =3 SFR16 (CAN0IF1MC, 0xD2);               // IF1 Message Control
           =3 SFR16 (CAN0IF1DA1, 0xD4);              // IF1 Data A 1
           =3 SFR16 (CAN0IF1DA2, 0xD6);              // IF1 Data A 2
           =3 SFR16 (CAN0IF1DB1, 0xDA);              // IF1 Data B 1
           =3 SFR16 (CAN0IF1DB2, 0xDC);              // IF1 Data B 2
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 62  

           =3 SFR16 (CAN0IF2CR, 0xDE);               // IF2 Command Request
           =3 SFR16 (CAN0IF2CM, 0xE2);               // IF2 Command Mask
           =3 SFR16 (CAN0IF2M1, 0xEA);               // IF2 Mask 1
           =3 SFR16 (CAN0IF2M2, 0xEC);               // IF2 Mask 2
           =3 SFR16 (CAN0IF2A1, 0xEE);               // IF2 Arbitration 1
           =3 SFR16 (CAN0IF2A2, 0xF2);               // IF2 Arbitration 2
           =3 SFR16 (CAN0IF2MC, 0xCE);               // IF2 Message Control
           =3 SFR16 (CAN0IF2DA1, 0xF6);              // IF2 Data A 1
           =3 SFR16 (CAN0IF2DA2, 0xFA);              // IF2 Data A 2
           =3 SFR16 (CAN0IF2DB1, 0xFC);              // IF2 Data B 1
           =3 SFR16 (CAN0IF2DB2, 0xFE);              // IF2 Data B 2
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // LIN0 Indirect Registers
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 #define  LIN0DT1   0x00                // LIN0 Data Byte 1
           =3 #define  LIN0DT2   0x01                // LIN0 Data Byte 2
           =3 #define  LIN0DT3   0x02                // LIN0 Data Byte 3
           =3 #define  LIN0DT4   0x03                // LIN0 Data Byte 4
           =3 #define  LIN0DT5   0x04                // LIN0 Data Byte 5
           =3 #define  LIN0DT6   0x05                // LIN0 Data Byte 6
           =3 #define  LIN0DT7   0x06                // LIN0 Data Byte 7
           =3 #define  LIN0DT8   0x07                // LIN0 Data Byte 8
           =3 #define  LIN0CTRL  0x08                // LIN0 Control
           =3 #define  LIN0ST    0x09                // LIN0 Status
           =3 #define  LIN0ERR   0x0A                // LIN0 Error
           =3 #define  LIN0SIZE  0x0B                // LIN0 Message Size
           =3 #define  LIN0DIV   0x0C                // LIN0 Divider
           =3 #define  LIN0MUL   0x0D                // LIN0 Multiplier
           =3 #define  LIN0ID    0x0E                // LIN0 Identifier
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // Address Definitions for Bit-addressable Registers
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 #define SFR_P0       0x80
           =3 #define SFR_TCON     0x88
           =3 #define SFR_P1       0x90
           =3 #define SFR_SCON0    0x98
           =3 #define SFR_SCON1    0x98
           =3 #define SFR_P2       0xA0
           =3 #define SFR_IE       0xA8
           =3 #define SFR_P3       0xB0
           =3 #define SFR_IP       0xB8
           =3 #define SFR_SMB0CN   0xC0
           =3 #define SFR_TMR2CN   0xC8
           =3 #define SFR_TMR4CN   0xC8
           =3 #define SFR_PSW      0xD0
           =3 #define SFR_PCA0CN   0xD8
           =3 #define SFR_PCA1CN   0xD8
           =3 #define SFR_ACC      0xE0
           =3 #define SFR_ADC0CN   0xE8
           =3 #define SFR_B        0xF0
           =3 #define SFR_SPI0CN   0xF8
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // Bit Definitions
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 // TCON 0x88
           =3 SBIT (TF1, SFR_TCON, 7);               // Timer 1 Overflow Flag
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 63  

           =3 SBIT (TR1, SFR_TCON, 6);               // Timer 1 On/Off Control
           =3 SBIT (TF0, SFR_TCON, 5);               // Timer 0 Overflow Flag
           =3 SBIT (TR0, SFR_TCON, 4);               // Timer 0 On/Off Control
           =3 SBIT (IE1, SFR_TCON, 3);               // Ext. Interrupt 1 Edge Flag
           =3 SBIT (IT1, SFR_TCON, 2);               // Ext. Interrupt 1 Type
           =3 SBIT (IE0, SFR_TCON, 1);               // Ext. Interrupt 0 Edge Flag
           =3 SBIT (IT0, SFR_TCON, 0);               // Ext. Interrupt 0 Type
           =3 
           =3 // SCON0 0x98
           =3 SBIT (OVR0, SFR_SCON0, 7);             // UART0 Receive FIFO Overrun Flag
           =3 SBIT (PERR0, SFR_SCON0, 6);            // UART0 Parity Error Flag
           =3 SBIT (THRE0, SFR_SCON0, 5);            // UART0 Transmit Register Empty Flag
           =3 SBIT (REN0, SFR_SCON0, 4);             // UART0 RX Enable
           =3 SBIT (TBX0, SFR_SCON0, 3);             // UART0 Extra Transmission Bit
           =3 SBIT (RBX0, SFR_SCON0, 2);             // UART0 Extra Receive Bit
           =3 SBIT (TI0, SFR_SCON0, 1);              // UART0 TX Interrupt Flag
           =3 SBIT (RI0, SFR_SCON0, 0);              // UART0 RX Interrupt Flag
           =3 
           =3 // SCON1 0x98
           =3 SBIT (S1MODE, SFR_SCON1, 7);           // UART1 Mode 0
           =3                                        // Bit 6 UNUSED
           =3 SBIT (MCE1, SFR_SCON1, 5);             // UART1 Multiprocessor enable
           =3 SBIT (REN1, SFR_SCON1, 4);             // UART1 RX Enable
           =3 SBIT (TB81, SFR_SCON1, 3);             // UART1 TX Bit 8
           =3 SBIT (RB81, SFR_SCON1, 2);             // UART1 RX Bit 8
           =3 SBIT (TI1, SFR_SCON1, 1);              // UART1 TX Interrupt Flag
           =3 SBIT (RI1, SFR_SCON1, 0);              // UART1 RX Interrupt Flag
           =3 
           =3 // IE 0xA8
           =3 SBIT (EA, SFR_IE, 7);                  // Global Interrupt Enable
           =3 SBIT (ESPI0, SFR_IE, 6);               // SPI0 Interrupt Enable
           =3 SBIT (ET2, SFR_IE, 5);                 // Timer 2 Interrupt Enable
           =3 SBIT (ES0, SFR_IE, 4);                 // UART0 Interrupt Enable
           =3 SBIT (ET1, SFR_IE, 3);                 // Timer 1 Interrupt Enable
           =3 SBIT (EX1, SFR_IE, 2);                 // External Interrupt 1 Enable
           =3 SBIT (ET0, SFR_IE, 1);                 // Timer 0 Interrupt Enable
           =3 SBIT (EX0, SFR_IE, 0);                 // External Interrupt 0 Enable
           =3 
           =3 // IP 0xB8
           =3                                        // Bit 7 unused
           =3 SBIT (PSPI0, SFR_IP, 6);               // SPI0 Interrupt Priority
           =3 SBIT (PT2, SFR_IP, 5);                 // Timer 2 Priority
           =3 SBIT (PS0, SFR_IP, 4);                 // UART0 Priority
           =3 SBIT (PS, SFR_IP, 4);                  // UART0 Priority
           =3 SBIT (PT1, SFR_IP, 3);                 // Timer 1 Priority
           =3 SBIT (PX1, SFR_IP, 2);                 // External Interrupt 1 Priority
           =3 SBIT (PT0, SFR_IP, 1);                 // Timer 0 Priority
           =3 SBIT (PX0, SFR_IP, 0);                 // External Interrupt 0 Priority
           =3 
           =3 // SMB0CN 0xC0
           =3 SBIT (MASTER, SFR_SMB0CN, 7);          // SMBus0 Master/Slave Indicator
           =3 SBIT (TXMODE, SFR_SMB0CN, 6);          // SMBus0 Transmit Mode Indicator
           =3 SBIT (STA, SFR_SMB0CN, 5);             // SMBus0 Start Flag
           =3 SBIT (STO, SFR_SMB0CN, 4);             // SMBus0 Stop Flag
           =3 SBIT (ACKRQ, SFR_SMB0CN, 3);           // SMBus0 Acknowledge Request
           =3 SBIT (ARBLOST, SFR_SMB0CN, 2);         // SMBus0 Arbitration Lost Indicator
           =3 SBIT (ACK, SFR_SMB0CN, 1);             // SMBus0 Acknowledge
           =3 SBIT (SI, SFR_SMB0CN, 0);              // SMBus0 Interrupt Flag
           =3 
           =3 // TMR2CN 0xC8
           =3 SBIT (TF2H, SFR_TMR2CN, 7);            // Timer 2 High-Byte Overflow Flag
           =3 SBIT (TF2L, SFR_TMR2CN, 6);            // Timer 2 Low-Byte  Overflow Flag
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 64  

           =3 SBIT (TF2LEN, SFR_TMR2CN, 5);          // Timer 2 Low-Byte Flag Enable
           =3 SBIT (TF2CEN, SFR_TMR2CN, 4);          // Timer 2 Capture Enable
           =3 SBIT (T2SPLIT, SFR_TMR2CN, 3);         // Timer 2 Split-Mode Enable
           =3 SBIT (TR2, SFR_TMR2CN, 2);             // Timer 2 Run Enable
           =3 SBIT (T2RCLK, SFR_TMR2CN, 1);          // Timer 2 Xclk/Rclk Select
           =3 SBIT (T2XCLK, SFR_TMR2CN, 0);          // Timer 2 Clk/8 Clock Source
           =3 
           =3 // TMR4CN 0xC8
           =3 SBIT (TF4, SFR_TMR4CN, 7);             // Timer 4 Overflow/Underflow Flag
           =3 SBIT (EXF4, SFR_TMR4CN, 6);            // Timer 4 External Flag
           =3                                        // Bit 5 unused
           =3                                        // Bit 4 unused
           =3 SBIT (EXE4, SFR_TMR4CN, 3);            // Timer 4 External Enable
           =3 SBIT (TR4, SFR_TMR4CN, 2);             // Timer 4 Run Enable
           =3 SBIT (CT4, SFR_TMR4CN, 1);             // Timer 4 Counter/Timer Select
           =3 SBIT (CPRL4, SFR_TMR4CN, 0);           // Timer 4 Capture/Reload Select
           =3 
           =3 // PSW 0xD0
           =3 SBIT (CY, SFR_PSW, 7);                 // Carry Flag
           =3 SBIT (AC, SFR_PSW, 6);                 // Auxiliary Carry Flag
           =3 SBIT (F0, SFR_PSW, 5);                 // User Flag 0
           =3 SBIT (RS1, SFR_PSW, 4);                // Register Bank Select 1
           =3 SBIT (RS0, SFR_PSW, 3);                // Register Bank Select 0
           =3 SBIT (OV, SFR_PSW, 2);                 // Overflow Flag
           =3 SBIT (F1, SFR_PSW, 1);                 // User Flag 1
           =3 SBIT (P, SFR_PSW, 0);                  // Accumulator Parity Flag
           =3 
           =3 // PCA0CN 0xD8
           =3 SBIT (CF, SFR_PCA0CN, 7);              // PCA0 Counter Overflow Flag
           =3 SBIT (CR, SFR_PCA0CN, 6);              // PCA0 Counter Run Control Bit
           =3 SBIT (CCF5, SFR_PCA0CN, 5);            // PCA0 Module 5 Interrupt Flag
           =3 SBIT (CCF4, SFR_PCA0CN, 4);            // PCA0 Module 4 Interrupt Flag
           =3 SBIT (CCF3, SFR_PCA0CN, 3);            // PCA0 Module 3 Interrupt Flag
           =3 SBIT (CCF2, SFR_PCA0CN, 2);            // PCA0 Module 2 Interrupt Flag
           =3 SBIT (CCF1, SFR_PCA0CN, 1);            // PCA0 Module 1 Interrupt Flag
           =3 SBIT (CCF0, SFR_PCA0CN, 0);            // PCA0 Module 0 Interrupt Flag
           =3 
           =3 // PCA1CN 0xD8
           =3 SBIT (CF1, SFR_PCA1CN, 7);             // PCA1 Counter Overflow Flag
           =3 SBIT (CR1, SFR_PCA1CN, 6);             // PCA1 Counter Run Control Bit
           =3 SBIT (CCF11, SFR_PCA1CN, 5);           // PCA1 Module 11 Interrupt Flag
           =3 SBIT (CCF10, SFR_PCA1CN, 4);           // PCA1 Module 10 Interrupt Flag
           =3 SBIT (CCF9, SFR_PCA1CN, 3);            // PCA1 Module 9 Interrupt Flag
           =3 SBIT (CCF8, SFR_PCA1CN, 2);            // PCA1 Module 8 Interrupt Flag
           =3 SBIT (CCF7, SFR_PCA1CN, 1);            // PCA1 Module 7 Interrupt Flag
           =3 SBIT (CCF6, SFR_PCA1CN, 0);            // PCA1 Module 6 Interrupt Flag
           =3 
           =3 // ADC0CN 0xE8
           =3 SBIT (AD0EN, SFR_ADC0CN, 7);           // ADC0 Enable
           =3 SBIT (BURSTEN, SFR_ADC0CN, 6);         // ADC0 Burst Enable
           =3 SBIT (AD0INT, SFR_ADC0CN, 5);          // ADC0 EOC Interrupt Flag
           =3 SBIT (AD0BUSY, SFR_ADC0CN, 4);         // ADC0 Busy Flag
           =3 SBIT (AD0WINT, SFR_ADC0CN, 3);         // ADC0 Window Compare Interrupt Flag
           =3 SBIT (AD0LJST, SFR_ADC0CN, 2);         // ADC0 Left Justified
           =3 SBIT (AD0CM1, SFR_ADC0CN, 1);          // ADC0 Start Of Conversion Mode Bit 1
           =3 SBIT (AD0CM0, SFR_ADC0CN, 0);          // ADC0 Start Of Conversion Mode Bit 0
           =3 
           =3 // SPI0CN 0xF8
           =3 SBIT (SPIF, SFR_SPI0CN, 7);            // SPI0 Interrupt Flag
           =3 SBIT (WCOL, SFR_SPI0CN, 6);            // SPI0 Write Collision Flag
           =3 SBIT (MODF, SFR_SPI0CN, 5);            // SPI0 Mode Fault Flag
           =3 SBIT (RXOVRN, SFR_SPI0CN, 4);          // SPI0 RX Overrun Flag
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 65  

           =3 SBIT (NSSMD1, SFR_SPI0CN, 3);          // SPI0 Slave Select Mode 1
           =3 SBIT (NSSMD0, SFR_SPI0CN, 2);          // SPI0 Slave Select Mode 0
           =3 SBIT (TXBMT, SFR_SPI0CN, 1);           // SPI0 TX Buffer Empty Flag
           =3 SBIT (SPIEN, SFR_SPI0CN, 0);           // SPI0 Enable
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // Interrupt Priorities
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 #define INTERRUPT_INT0             0   // External Interrupt 0
           =3 #define INTERRUPT_TIMER0           1   // Timer 0 Overflow
           =3 #define INTERRUPT_INT1             2   // External Interrupt 1
           =3 #define INTERRUPT_TIMER1           3   // Timer 1 Overflow
           =3 #define INTERRUPT_UART0            4   // UART0
           =3 #define INTERRUPT_TIMER2           5   // Timer 2 Overflow
           =3 #define INTERRUPT_SPI0             6   // SPI0
           =3 #define INTERRUPT_SMBUS0           7   // SMBus0 Interface
           =3 #define INTERRUPT_ADC0_WINDOW      8   // ADC0 Window Comparison
           =3 #define INTERRUPT_ADC0_EOC         9   // ADC0 End Of Conversion
           =3 #define INTERRUPT_PCA0            10   // PCA0 Peripheral
           =3 #define INTERRUPT_COMPARATOR0     11   // Comparator 0 Comparison
           =3 #define INTERRUPT_COMPARATOR1     12   // Comparator 1 Comparison
           =3 #define INTERRUPT_TIMER3          13   // Timer 3 Overflow
           =3 #define INTERRUPT_LIN0            14   // LIN Bus Interrupt
           =3 #define INTERRUPT_VREG            15   // Voltage Regulator
           =3 #define INTERRUPT_CAN0            16   // CAN Bus Interrupt
           =3 #define INTERRUPT_PORT_MATCH      17   // Port Match
           =3 #define INTERRUPT_UART1           18   // UART1
           =3 #define INTERRUPT_PCA1            19   // PCA1 Peripheral
           =3 #define INTERRUPT_COMPARATOR2     20   // Comparator 2 Comparison
           =3 #define INTERRUPT_TIMER4          21   // Timer 4 Overflow
           =3 #define INTERRUPT_TIMER5          22   // Timer 5 Overflow
           =3 
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // SFR Page Definitions
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 #define  CONFIG_PAGE       0x0F        // System and Port Configuration Page
           =3 #define  ACTIVE_PAGE       0x00        // Active Use Page
           =3 #define  ACTIVE2_PAGE      0x10        // Active Use Page 2
           =3 #define  CAN0_PAGE         0x0C        // CAN0 Registers
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // SDCC PDATA External Memory Paging Support
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 #if defined SDCC
           =3 
           =3 SFR(_XPAGE, 0xAA); // Point to the EMI0CN register
           =3 
           =3 #endif
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // Header File PreProcessor Directive
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 #endif                                 // #define C8051F580_DEFS_H
 607      =3  
 608      =3  //-----------------------------------------------------------------------------
 609      =3  // End Of File
 610      =3  //-----------------------------------------------------------------------------
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 66  

   5      =2  #include "rtos_config.h"
   1      =3  #ifndef RTOS_CONFIG_H
           =3 #define RTOS_CONFIG_H
           =3 
           =3 #define MAX_TASK (3U)
           =3 #define SIZE_IDLE_STACK         (256U)
           =3 #define SIZE_TASK_STACK         (512U)
           =3 #define SIZE_SCHED_STACK        (1024U)
           =3 
           =3 #define SRAM_START                      (0x0000U)
           =3 #define SIZE_SRAM                       (8*1024U)
           =3 #define SRAM_END                        (SRAM_START + SIZE_SRAM)
           =3 
           =3 #define TASK_RUNNING_STATE      0
           =3 #define TASK_BLOCKED_STATE      1
           =3 #define TASK_READY_STATE        2 
           =3 
           =3 // Äá»a chá» báº¯t Äáº§u stack ná»i (trong IRAM)
           =3 #define configSTACK_START    0x30
           =3 
           =3 #define INTERRUPT_DISABLE (EA = 0)
           =3 #define INTERRUPT_ENABLE  (EA = 1)
           =3 
           =3 #endif
   6      =2  #include "Tick.h"
   1      =3  #ifndef TICK_H_
           =3 #define TICK_H_
           =3 #include <compiler_defs.h>
           =3 #include <C8051F580_defs.h>            // SFR declarations
           =3 #include "rtos_config.h"
           =3 #include "Task.h"
           =3 void TIMER2_Init (U16 counts);
           =3 void task_delay(U32 tick_count);
           =3 void unblock_task();
           =3 void context_switching();
           =3 #endif /* TICK_H_ */
   7      =2  #include <stdio.h>
   1      =3  /*--------------------------------------------------------------------------
   2      =3  STDIO.H
   3      =3  
   4      =3  Prototypes for standard I/O functions.
   5      =3  Copyright (c) 1988-2002 Keil Elektronik GmbH and Keil Software, Inc.
   6      =3  All rights reserved.
   7      =3  --------------------------------------------------------------------------*/
   8      =3  
   9      =3  #ifndef __STDIO_H__
           =3 #define __STDIO_H__
           =3 
           =3 #ifndef EOF
           =3  #define EOF -1
           =3 #endif
           =3 
           =3 #ifndef NULL
           =3  #define NULL ((void *) 0)
           =3 #endif
           =3 
           =3 #ifndef _SIZE_T
           =3  #define _SIZE_T
           =3  typedef unsigned int size_t;
           =3 #endif
           =3 
           =3 #pragma SAVE
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 67  

           =3 #pragma REGPARMS
           =3 extern char _getkey (void);
           =3 extern char getchar (void);
           =3 extern char ungetchar (char);
           =3 extern char putchar (char);
           =3 extern int printf   (const char *, ...);
           =3 extern int sprintf  (char *, const char *, ...);
           =3 extern int vprintf  (const char *, char *);
           =3 extern int vsprintf (char *, const char *, char *);
           =3 extern char *gets (char *, int n);
           =3 extern int scanf (const char *, ...);
           =3 extern int sscanf (char *, const char *, ...);
           =3 extern int puts (const char *);
           =3 
           =3 #pragma RESTORE
           =3 
           =3 #endif
  43      =3  
   8      =2  typedef struct {
   9      =2      U16 psp_value;                // Stack pointer (XRAM)
  10      =2      U32 block_count;              // Sá» tick bá» block (náº¿u cÃ³)
  11      =2      U8 current_state;             // Ready / Blocked / Running
  12      =2      void (*task_handler)(void);   // Entry function cá»§a task
  13      =2  } TCB_t;
  14      =2  
  15      =2  // U8 create_task(void (*task_handler)(void), U32 stack_size);
  16      =2  // void port_prepare_stack(U8 *stack_top, void (*handler)(void));
  17      =2  U8 create_task(void (*task_handler)(void), U32 stack_size) ;
  18      =2  void port_prepare_stack(U8 **stack_ptr, void (*handler)(void)) ;
  19      =2  void start_scheduler(void);
  20      =2  void update_next_task(void) ;
  21      =2  void portCOPY_STACK_TO_XRAM(void);
  22      =2  void portCOPY_XRAM_TO_STACK(void);
  23      =2  void TIMER2_Init (U16 counts);
  24      =2  #endif /* TASK_H_ */
   7      =1  void TIMER2_Init (U16 counts);
   8      =1  void task_delay(U32 tick_count);
   9      =1  void unblock_task();
  10      =1  void context_switching();
  11      =1  #endif /* TICK_H_ */
   5          #include "Task.h"
   1      =1  #ifndef TASK_H_
           =1 #define TASK_H_
           =1 #include <compiler_defs.h>
           =1 #include <C8051F580_defs.h>            // SFR declarations
           =1 #include "rtos_config.h"
           =1 #include "Tick.h"
           =1 #include <stdio.h>
           =1 typedef struct {
           =1     U16 psp_value;                // Stack pointer (XRAM)
           =1     U32 block_count;              // Sá» tick bá» block (náº¿u cÃ³)
           =1     U8 current_state;             // Ready / Blocked / Running
           =1     void (*task_handler)(void);   // Entry function cá»§a task
           =1 } TCB_t;
           =1 
           =1 // U8 create_task(void (*task_handler)(void), U32 stack_size);
           =1 // void port_prepare_stack(U8 *stack_top, void (*handler)(void));
           =1 U8 create_task(void (*task_handler)(void), U32 stack_size) ;
           =1 void port_prepare_stack(U8 **stack_ptr, void (*handler)(void)) ;
           =1 void start_scheduler(void);
           =1 void update_next_task(void) ;
           =1 void portCOPY_STACK_TO_XRAM(void);
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 68  

           =1 void portCOPY_XRAM_TO_STACK(void);
           =1 void TIMER2_Init (U16 counts);
           =1 #endif /* TASK_H_ */
   6          #include "Scherduler.h"
   1      =1  #ifndef SCHEDULER_H_
   2      =1  #define SCHEDULER_H_
   3      =1  
   4      =1  #include "rtos_config.h"
   1      =2  #ifndef RTOS_CONFIG_H
           =2 #define RTOS_CONFIG_H
           =2 
           =2 #define MAX_TASK (3U)
           =2 #define SIZE_IDLE_STACK         (256U)
           =2 #define SIZE_TASK_STACK         (512U)
           =2 #define SIZE_SCHED_STACK        (1024U)
           =2 
           =2 #define SRAM_START                      (0x0000U)
           =2 #define SIZE_SRAM                       (8*1024U)
           =2 #define SRAM_END                        (SRAM_START + SIZE_SRAM)
           =2 
           =2 #define TASK_RUNNING_STATE      0
           =2 #define TASK_BLOCKED_STATE      1
           =2 #define TASK_READY_STATE        2 
           =2 
           =2 // Äá»a chá» báº¯t Äáº§u stack ná»i (trong IRAM)
           =2 #define configSTACK_START    0x30
           =2 
           =2 #define INTERRUPT_DISABLE (EA = 0)
           =2 #define INTERRUPT_ENABLE  (EA = 1)
           =2 
           =2 #endif
   5      =1  #include "Task.h"
   1      =2  #ifndef TASK_H_
           =2 #define TASK_H_
           =2 #include <compiler_defs.h>
           =2 #include <C8051F580_defs.h>            // SFR declarations
           =2 #include "rtos_config.h"
           =2 #include "Tick.h"
           =2 #include <stdio.h>
           =2 typedef struct {
           =2     U16 psp_value;                // Stack pointer (XRAM)
           =2     U32 block_count;              // Sá» tick bá» block (náº¿u cÃ³)
           =2     U8 current_state;             // Ready / Blocked / Running
           =2     void (*task_handler)(void);   // Entry function cá»§a task
           =2 } TCB_t;
           =2 
           =2 // U8 create_task(void (*task_handler)(void), U32 stack_size);
           =2 // void port_prepare_stack(U8 *stack_top, void (*handler)(void));
           =2 U8 create_task(void (*task_handler)(void), U32 stack_size) ;
           =2 void port_prepare_stack(U8 **stack_ptr, void (*handler)(void)) ;
           =2 void start_scheduler(void);
           =2 void update_next_task(void) ;
           =2 void portCOPY_STACK_TO_XRAM(void);
           =2 void portCOPY_XRAM_TO_STACK(void);
           =2 void TIMER2_Init (U16 counts);
           =2 #endif /* TASK_H_ */
   6      =1  #include "Tick.h"
   1      =2  #ifndef TICK_H_
           =2 #define TICK_H_
           =2 #include <compiler_defs.h>
           =2 #include <C8051F580_defs.h>            // SFR declarations
           =2 #include "rtos_config.h"
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 69  

           =2 #include "Task.h"
           =2 void TIMER2_Init (U16 counts);
           =2 void task_delay(U32 tick_count);
           =2 void unblock_task();
           =2 void context_switching();
           =2 #endif /* TICK_H_ */
   7      =1  #include <stdio.h>
   1      =2  /*--------------------------------------------------------------------------
   2      =2  STDIO.H
   3      =2  
   4      =2  Prototypes for standard I/O functions.
   5      =2  Copyright (c) 1988-2002 Keil Elektronik GmbH and Keil Software, Inc.
   6      =2  All rights reserved.
   7      =2  --------------------------------------------------------------------------*/
   8      =2  
   9      =2  #ifndef __STDIO_H__
           =2 #define __STDIO_H__
           =2 
           =2 #ifndef EOF
           =2  #define EOF -1
           =2 #endif
           =2 
           =2 #ifndef NULL
           =2  #define NULL ((void *) 0)
           =2 #endif
           =2 
           =2 #ifndef _SIZE_T
           =2  #define _SIZE_T
           =2  typedef unsigned int size_t;
           =2 #endif
           =2 
           =2 #pragma SAVE
           =2 #pragma REGPARMS
           =2 extern char _getkey (void);
           =2 extern char getchar (void);
           =2 extern char ungetchar (char);
           =2 extern char putchar (char);
           =2 extern int printf   (const char *, ...);
           =2 extern int sprintf  (char *, const char *, ...);
           =2 extern int vprintf  (const char *, char *);
           =2 extern int vsprintf (char *, const char *, char *);
           =2 extern char *gets (char *, int n);
           =2 extern int scanf (const char *, ...);
           =2 extern int sscanf (char *, const char *, ...);
           =2 extern int puts (const char *);
           =2 
           =2 #pragma RESTORE
           =2 
           =2 #endif
  43      =2  
   8      =1  
   9      =1  #endif /* SCHEDULER_H_ */
   7          
   8          //-----------------------------------------------------------------------------
   9          // Global CONSTANTS
  10          //-----------------------------------------------------------------------------
  11          SBIT(LED_G, SFR_P2, 1);
  12          SBIT(LED_Y, SFR_P2, 0);
  13          
  14          #define SYSCLK      24000000           // SYSCLK frequency in Hz
  15          #define BAUDRATE      115200           // Baud rate of UART in bps
  16          
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 70  

  17          //-----------------------------------------------------------------------------
  18          // Function PROTOTYPES
  19          //-----------------------------------------------------------------------------
  20          
  21          void SYSCLK_Init (void);
  22          void UART1_Init (void);
  23          void PORT_Init (void);
  24          void delayms(int time);
  25          void task1_handler(void);
  26          void task2_handler(void);
  27          void task3_handler(void);
  28          void idle_task(void);
  29          
  30          extern void iram_test(void);
  31          //-----------------------------------------------------------------------------
  32          // MAIN Routine
  33          //-----------------------------------------------------------------------------
  34          
  35          void main (void)
  36          {
  37   1      SFRPAGE = ACTIVE_PAGE;
  38   1         PCA0MD &= ~0x40;                    // Disable watchdog timer
  39   1         
  40   1         PORT_Init();                        // Initialize Port I/O
  41   1         SYSCLK_Init ();                     // Initialize Oscillator
  42   1         UART1_Init();
  43   1         //create_task(idle_task,   SIZE_IDLE_STACK);
  44   1          create_task(task1_handler, SIZE_TASK_STACK);
  45   1          create_task(task2_handler, SIZE_TASK_STACK);
  46   1              create_task(task3_handler, SIZE_TASK_STACK);
  47   1         //TIMER2_Init(SYSCLK / 12 / 100); // Init Timer2
  48   1         
  49   1              EA = 1;               // Enable global interrupts       
  50   1              start_scheduler();
  51   1              Task1_handler();
*** WARNING C206 IN LINE 51 OF main.c: 'Task1_handler': missing function-prototype
  52   1                      //Idle_handler();
  53   1         while (1)
  54   1         {
  55   2            // LED_G = ~LED_G;   // Toggle green LED
  56   2            // LED_Y = ~LED_Y;   // Toggle yellow LED
  57   2            // printf ("Hello wolrd \n ");
  58   2            // delayms(100);     // Delay 100 ms
  59   2         }
  60   1      }
  61          
  62          //-----------------------------------------------------------------------------
  63          // P1.5   digital   push-pull    UART1 TX
  64          // P1.6   digital   open-drain   UART1 RX
  65          //-----------------------------------------------------------------------------
  66          void PORT_Init (void)
  67           {
  68   1         U8 SFRPAGE_save = SFRPAGE;
  69   1         SFRPAGE = CONFIG_PAGE;
  70   1             P2MDOUT   = 0x03;
  71   1         P1MDOUT |= 0x20; // TX1 (P1.5) push-pull
  72   1         P1MDIN &= ~0x20; // RX1 (P1.6) input
  73   1         P0SKIP    = 0xFF;
  74   1         P1SKIP    = 0x1F;
  75   1      
  76   1         XBR2    = 0x42;                     // Enable UART1 on P2.0(TX) and P2.1(RX)
  77   1                                          // // Enable crossbar and weak pull-ups
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 71  

  78   1         SFRPAGE = SFRPAGE_save;
  79   1       }
  80          
  81          //-----------------------------------------------------------------------------
  82          // SYSCLK_Init
  83          //-----------------------------------------------------------------------------
  84          //
  85          // Return Value : None
  86          // Parameters   : None
  87          //
  88          // This routine initializes the system clock to use the internal oscillator
  89          // at its maximum frequency.
  90          // Also enables the Missing Clock Detector.
  91          //-----------------------------------------------------------------------------
  92          
  93          void SYSCLK_Init (void)
  94          {
  95   1         U8 SFRPAGE_save = SFRPAGE;
  96   1         SFRPAGE = CONFIG_PAGE;
  97   1      
  98   1         OSCICN |= 0x87;                     // Configure internal oscillator for
  99   1                                             // its maximum frequency
 100   1         RSTSRC  = 0x04;                     // Enable missing clock detector
 101   1      
 102   1         SFRPAGE = SFRPAGE_save;
 103   1      }
 104          
 105          //-----------------------------------------------------------------------------
 106          // UART1_Init
 107          //-----------------------------------------------------------------------------
 108          //
 109          // Return Value : None
 110          // Parameters   : None
 111          //
 112          // Configure the UART1 using Timer1, for <BAUDRATE> and 8-N-1.
 113          //-----------------------------------------------------------------------------
 114          void UART1_Init (void)
 115          {
 116   1         U8 SFRPAGE_save = SFRPAGE;
 117   1         SFRPAGE = ACTIVE2_PAGE;
 118   1      
 119   1         SCON1 = 0x10;                       // SCON1: 8-bit variable bit rate
 120   1                                             //        level of STOP bit is ignored
 121   1                                             //        RX enabled
 122   1                                             //        ninth bits are zeros
 123   1                                             //        clear RI0 and TI0 bits
 124   1         if (SYSCLK / BAUDRATE / 2 / 256 < 1) 
 125   1         {
 126   2            TH1 = -(SYSCLK / BAUDRATE / 2);
 127   2            CKCON &= ~0x0B;                  // T1M = 1; SCA1:0 = xx
 128   2            CKCON |=  0x08;
 129   2         } 
 130   1         else if (SYSCLK / BAUDRATE / 2 / 256 < 4) 
 131   1         {
 132   2            TH1 = -(SYSCLK / BAUDRATE / 2 / 4);
 133   2            CKCON &= ~0x0B;                  // T1M = 0; SCA1:0 = 01
 134   2            CKCON |=  0x01;
 135   2         } 
 136   1         else if (SYSCLK / BAUDRATE / 2 / 256 < 12) 
 137   1         {
 138   2            TH1 = -(SYSCLK / BAUDRATE / 2 / 12);
 139   2            CKCON &= ~0x0B;                  // T1M = 0; SCA1:0 = 00
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 72  

 140   2         } 
 141   1         else 
 142   1         {
 143   2            TH1 = -(SYSCLK / BAUDRATE / 2 / 48);
 144   2            CKCON &= ~0x0B;                  // T1M = 0; SCA1:0 = 10
 145   2            CKCON |=  0x02;
 146   2         }
 147   1      
 148   1         TL1 = TH1;                          // Init Timer1
 149   1         TMOD &= ~0xF0;                      // TMOD: timer 1 in 8-bit autoreload
 150   1         TMOD |=  0x20;
 151   1         TR1 = 1;                            // START Timer1
 152   1      
 153   1         TI1 = 1;                            // Indicate TX0 ready (SCON1)
 154   1      
 155   1         SFRPAGE = SFRPAGE_save;
 156   1      }
 157          
 158          
 159          
 160          
 161          // void delayms(int time)
 162          // {
 163          //      G_Count = 0;
 164          //      while(G_Count < time);
 165          // }
 166          void idle_task(void) {
 167   1      SFRPAGE = ACTIVE2_PAGE;   
 168   1              while (1){
 169   2                              printf("Idle_handler \n");
 170   2                                              task_delay(3000);
 171   2                      }
 172   1      }
 173          
 174          void task1_handler(void) {
 175   1      SEG_XDATA U32 i ;
 176   1      SFRPAGE = ACTIVE2_PAGE;   
 177   1              while (1) {
 178   2                      printf("Task1_handler \n");
 179   2                      LED_G = ~LED_G;
 180   2                      for(i=0; i < 0xffff;i++);
 181   2              //      task_delay(450);
 182   2              }
 183   1      }
 184          
 185          void task2_handler(void) {
 186   1      SEG_XDATA U32 i ;
 187   1      SFRPAGE = ACTIVE2_PAGE;   
 188   1              while (1) {
 189   2              printf("Task2_handler \n");
 190   2              LED_Y = ~LED_Y;
 191   2              for(i=0; i < 0xffff;i++);
 192   2              //      task_delay(1100);
 193   2              }
 194   1      }
 195          
 196          void task3_handler(void) {
 197   1      SEG_XDATA U32 i ;
 198   1      SFRPAGE = ACTIVE2_PAGE;
 199   1              while (1) {
 200   2                      printf("Task3_handler \n");
 201   2                      for(i=0; i < 0xffff;i++);
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 73  

 202   2              //      task_delay(2200);
 203   2              }
 204   1      }
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 74  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION main (BEGIN)
                                           ; SOURCE LINE # 35
                                           ; SOURCE LINE # 36
                                           ; SOURCE LINE # 37
0000 75A700            MOV     SFRPAGE,#00H
                                           ; SOURCE LINE # 38
0003 53D9BF            ANL     PCA0MD,#0BFH
                                           ; SOURCE LINE # 40
0006 120000      R     LCALL   PORT_Init
                                           ; SOURCE LINE # 41
0009 120000      R     LCALL   SYSCLK_Init
                                           ; SOURCE LINE # 42
000C 120000      R     LCALL   UART1_Init
                                           ; SOURCE LINE # 44
000F 7BFF              MOV     R3,#0FFH
0011 7A00        R     MOV     R2,#HIGH task1_handler
0013 7900        R     MOV     R1,#LOW task1_handler
0015 7F00              MOV     R7,#00H
0017 7E02              MOV     R6,#02H
0019 7D00              MOV     R5,#00H
001B 7C00              MOV     R4,#00H
001D 120000      E     LCALL   _create_task
                                           ; SOURCE LINE # 45
0020 7BFF              MOV     R3,#0FFH
0022 7A00        R     MOV     R2,#HIGH task2_handler
0024 7900        R     MOV     R1,#LOW task2_handler
0026 7F00              MOV     R7,#00H
0028 7E02              MOV     R6,#02H
002A 7D00              MOV     R5,#00H
002C 7C00              MOV     R4,#00H
002E 120000      E     LCALL   _create_task
                                           ; SOURCE LINE # 46
0031 7BFF              MOV     R3,#0FFH
0033 7A00        R     MOV     R2,#HIGH task3_handler
0035 7900        R     MOV     R1,#LOW task3_handler
0037 7F00              MOV     R7,#00H
0039 7E02              MOV     R6,#02H
003B 7D00              MOV     R5,#00H
003D 7C00              MOV     R4,#00H
003F 120000      E     LCALL   _create_task
                                           ; SOURCE LINE # 49
0042 D2AF              SETB    EA
                                           ; SOURCE LINE # 50
0044 120000      E     LCALL   start_scheduler
                                           ; SOURCE LINE # 51
0047 120000      E     LCALL   Task1_handler
004A         ?C0001:
                                           ; SOURCE LINE # 53
                                           ; SOURCE LINE # 54
                                           ; SOURCE LINE # 59
004A 80FE              SJMP    ?C0001
004C         ?C0002:
                                           ; SOURCE LINE # 60
004C         ?C0003:
004C 22                RET     
             ; FUNCTION main (END)

             ; FUNCTION PORT_Init (BEGIN)
                                           ; SOURCE LINE # 66
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 75  

                                           ; SOURCE LINE # 67
                                           ; SOURCE LINE # 68
0000 7800        R     MOV     R0,#LOW SFRPAGE_save
0002 E5A7              MOV     A,SFRPAGE
0004 F2                MOVX    @R0,A
                                           ; SOURCE LINE # 69
0005 75A70F            MOV     SFRPAGE,#0FH
                                           ; SOURCE LINE # 70
0008 75A603            MOV     P2MDOUT,#03H
                                           ; SOURCE LINE # 71
000B 43A520            ORL     P1MDOUT,#020H
                                           ; SOURCE LINE # 72
000E 53F2DF            ANL     P1MDIN,#0DFH
                                           ; SOURCE LINE # 73
0011 75D4FF            MOV     P0SKIP,#0FFH
                                           ; SOURCE LINE # 74
0014 75D51F            MOV     P1SKIP,#01FH
                                           ; SOURCE LINE # 76
0017 75C742            MOV     XBR2,#042H
                                           ; SOURCE LINE # 78
001A 7800        R     MOV     R0,#LOW SFRPAGE_save
001C E2                MOVX    A,@R0
001D FF                MOV     R7,A
001E 8FA7              MOV     SFRPAGE,R7
                                           ; SOURCE LINE # 79
0020         ?C0004:
0020 22                RET     
             ; FUNCTION PORT_Init (END)

             ; FUNCTION SYSCLK_Init (BEGIN)
                                           ; SOURCE LINE # 93
                                           ; SOURCE LINE # 94
                                           ; SOURCE LINE # 95
0000 7800        R     MOV     R0,#LOW SFRPAGE_save
0002 E5A7              MOV     A,SFRPAGE
0004 F2                MOVX    @R0,A
                                           ; SOURCE LINE # 96
0005 75A70F            MOV     SFRPAGE,#0FH
                                           ; SOURCE LINE # 98
0008 43A187            ORL     OSCICN,#087H
                                           ; SOURCE LINE # 100
000B 75EF04            MOV     RSTSRC,#04H
                                           ; SOURCE LINE # 102
000E 7800        R     MOV     R0,#LOW SFRPAGE_save
0010 E2                MOVX    A,@R0
0011 FF                MOV     R7,A
0012 8FA7              MOV     SFRPAGE,R7
                                           ; SOURCE LINE # 103
0014         ?C0005:
0014 22                RET     
             ; FUNCTION SYSCLK_Init (END)

             ; FUNCTION UART1_Init (BEGIN)
                                           ; SOURCE LINE # 114
                                           ; SOURCE LINE # 115
                                           ; SOURCE LINE # 116
0000 7800        R     MOV     R0,#LOW SFRPAGE_save
0002 E5A7              MOV     A,SFRPAGE
0004 F2                MOVX    @R0,A
                                           ; SOURCE LINE # 117
0005 75A710            MOV     SFRPAGE,#010H
                                           ; SOURCE LINE # 119
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 76  

0008 759810            MOV     SCON1,#010H
                                           ; SOURCE LINE # 124
                                           ; SOURCE LINE # 125
                                           ; SOURCE LINE # 126
000B 758D98            MOV     TH1,#098H
                                           ; SOURCE LINE # 127
000E 538EF4            ANL     CKCON,#0F4H
                                           ; SOURCE LINE # 128
0011 438E08            ORL     CKCON,#08H
                                           ; SOURCE LINE # 129
0014 801C              SJMP    ?C0007
0016         ?C0006:
                                           ; SOURCE LINE # 130
                                           ; SOURCE LINE # 131
                                           ; SOURCE LINE # 132
0016 758DE6            MOV     TH1,#0E6H
                                           ; SOURCE LINE # 133
0019 538EF4            ANL     CKCON,#0F4H
                                           ; SOURCE LINE # 134
001C 438E01            ORL     CKCON,#01H
                                           ; SOURCE LINE # 135
001F 8011              SJMP    ?C0007
0021         ?C0008:
                                           ; SOURCE LINE # 136
                                           ; SOURCE LINE # 137
                                           ; SOURCE LINE # 138
0021 758DF8            MOV     TH1,#0F8H
                                           ; SOURCE LINE # 139
0024 538EF4            ANL     CKCON,#0F4H
                                           ; SOURCE LINE # 140
0027 8009              SJMP    ?C0007
0029         ?C0010:
                                           ; SOURCE LINE # 142
                                           ; SOURCE LINE # 143
0029 758DFE            MOV     TH1,#0FEH
                                           ; SOURCE LINE # 144
002C 538EF4            ANL     CKCON,#0F4H
                                           ; SOURCE LINE # 145
002F 438E02            ORL     CKCON,#02H
                                           ; SOURCE LINE # 146
0032         ?C0011:
0032         ?C0009:
0032         ?C0007:
                                           ; SOURCE LINE # 148
0032 858D8B            MOV     TL1,TH1
                                           ; SOURCE LINE # 149
0035 53890F            ANL     TMOD,#0FH
                                           ; SOURCE LINE # 150
0038 438920            ORL     TMOD,#020H
                                           ; SOURCE LINE # 151
003B D28E              SETB    TR1
                                           ; SOURCE LINE # 153
003D D299              SETB    TI1
                                           ; SOURCE LINE # 155
003F 7800        R     MOV     R0,#LOW SFRPAGE_save
0041 E2                MOVX    A,@R0
0042 FF                MOV     R7,A
0043 8FA7              MOV     SFRPAGE,R7
                                           ; SOURCE LINE # 156
0045         ?C0012:
0045 22                RET     
             ; FUNCTION UART1_Init (END)
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 77  


             ; FUNCTION idle_task (BEGIN)
                                           ; SOURCE LINE # 166
                                           ; SOURCE LINE # 167
0000 75A710            MOV     SFRPAGE,#010H
0003         ?C0013:
                                           ; SOURCE LINE # 168
                                           ; SOURCE LINE # 169
0003 7BFF              MOV     R3,#0FFH
0005 7A00        R     MOV     R2,#HIGH ?SC_0
0007 7900        R     MOV     R1,#LOW ?SC_0
0009 120000      E     LCALL   _printf
                                           ; SOURCE LINE # 170
000C 7FB8              MOV     R7,#0B8H
000E 7E0B              MOV     R6,#0BH
0010 7D00              MOV     R5,#00H
0012 7C00              MOV     R4,#00H
0014 120000      E     LCALL   _task_delay
                                           ; SOURCE LINE # 171
0017 80EA              SJMP    ?C0013
0019         ?C0014:
                                           ; SOURCE LINE # 172
0019         ?C0015:
0019 22                RET     
             ; FUNCTION idle_task (END)

             ; FUNCTION task1_handler (BEGIN)
                                           ; SOURCE LINE # 174
                                           ; SOURCE LINE # 176
0000 75A710            MOV     SFRPAGE,#010H
0003         ?C0016:
                                           ; SOURCE LINE # 177
                                           ; SOURCE LINE # 178
0003 7BFF              MOV     R3,#0FFH
0005 7A00        R     MOV     R2,#HIGH ?SC_15
0007 7900        R     MOV     R1,#LOW ?SC_15
0009 120000      E     LCALL   _printf
                                           ; SOURCE LINE # 179
000C B2A1              CPL     LED_G
                                           ; SOURCE LINE # 180
000E 900000      R     MOV     DPTR,#i
0011 120000      E     LCALL   ?C?LSTKXDATA
0014 00                DB      00H
0015 00                DB      00H
0016 00                DB      00H
0017 00                DB      00H
0018         ?C0018:
0018 7FFF              MOV     R7,#0FFH
001A 7EFF              MOV     R6,#0FFH
001C 7D00              MOV     R5,#00H
001E 7C00              MOV     R4,#00H
0020 900000      R     MOV     DPTR,#i
0023 E0                MOVX    A,@DPTR
0024 F8                MOV     R0,A
0025 A3                INC     DPTR
0026 E0                MOVX    A,@DPTR
0027 F9                MOV     R1,A
0028 A3                INC     DPTR
0029 E0                MOVX    A,@DPTR
002A FA                MOV     R2,A
002B A3                INC     DPTR
002C E0                MOVX    A,@DPTR
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 78  

002D FB                MOV     R3,A
002E C3                CLR     C
002F 120000      E     LCALL   ?C?ULCMP
0032 50CF              JNC     ?C0016
0034         ?C0020:
0034 900000      R     MOV     DPTR,#i
0037 E0                MOVX    A,@DPTR
0038 FC                MOV     R4,A
0039 A3                INC     DPTR
003A E0                MOVX    A,@DPTR
003B FD                MOV     R5,A
003C A3                INC     DPTR
003D E0                MOVX    A,@DPTR
003E FE                MOV     R6,A
003F A3                INC     DPTR
0040 E0                MOVX    A,@DPTR
0041 FF                MOV     R7,A
0042 7B01              MOV     R3,#01H
0044 7A00              MOV     R2,#00H
0046 7900              MOV     R1,#00H
0048 7800              MOV     R0,#00H
004A EF                MOV     A,R7
004B 2B                ADD     A,R3
004C FF                MOV     R7,A
004D EE                MOV     A,R6
004E 3A                ADDC    A,R2
004F FE                MOV     R6,A
0050 ED                MOV     A,R5
0051 39                ADDC    A,R1
0052 FD                MOV     R5,A
0053 EC                MOV     A,R4
0054 38                ADDC    A,R0
0055 FC                MOV     R4,A
0056 900000      R     MOV     DPTR,#i
0059 120000      E     LCALL   ?C?LSTXDATA
005C 80BA              SJMP    ?C0018
005E         ?C0019:
                                           ; SOURCE LINE # 182
005E 80A3              SJMP    ?C0016
0060         ?C0017:
                                           ; SOURCE LINE # 183
0060         ?C0021:
0060 22                RET     
             ; FUNCTION task1_handler (END)

             ; FUNCTION task2_handler (BEGIN)
                                           ; SOURCE LINE # 185
                                           ; SOURCE LINE # 187
0000 75A710            MOV     SFRPAGE,#010H
0003         ?C0022:
                                           ; SOURCE LINE # 188
                                           ; SOURCE LINE # 189
0003 7BFF              MOV     R3,#0FFH
0005 7A00        R     MOV     R2,#HIGH ?SC_31
0007 7900        R     MOV     R1,#LOW ?SC_31
0009 120000      E     LCALL   _printf
                                           ; SOURCE LINE # 190
000C B2A0              CPL     LED_Y
                                           ; SOURCE LINE # 191
000E 900000      R     MOV     DPTR,#i
0011 120000      E     LCALL   ?C?LSTKXDATA
0014 00                DB      00H
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 79  

0015 00                DB      00H
0016 00                DB      00H
0017 00                DB      00H
0018         ?C0024:
0018 7FFF              MOV     R7,#0FFH
001A 7EFF              MOV     R6,#0FFH
001C 7D00              MOV     R5,#00H
001E 7C00              MOV     R4,#00H
0020 900000      R     MOV     DPTR,#i
0023 E0                MOVX    A,@DPTR
0024 F8                MOV     R0,A
0025 A3                INC     DPTR
0026 E0                MOVX    A,@DPTR
0027 F9                MOV     R1,A
0028 A3                INC     DPTR
0029 E0                MOVX    A,@DPTR
002A FA                MOV     R2,A
002B A3                INC     DPTR
002C E0                MOVX    A,@DPTR
002D FB                MOV     R3,A
002E C3                CLR     C
002F 120000      E     LCALL   ?C?ULCMP
0032 50CF              JNC     ?C0022
0034         ?C0026:
0034 900000      R     MOV     DPTR,#i
0037 E0                MOVX    A,@DPTR
0038 FC                MOV     R4,A
0039 A3                INC     DPTR
003A E0                MOVX    A,@DPTR
003B FD                MOV     R5,A
003C A3                INC     DPTR
003D E0                MOVX    A,@DPTR
003E FE                MOV     R6,A
003F A3                INC     DPTR
0040 E0                MOVX    A,@DPTR
0041 FF                MOV     R7,A
0042 7B01              MOV     R3,#01H
0044 7A00              MOV     R2,#00H
0046 7900              MOV     R1,#00H
0048 7800              MOV     R0,#00H
004A EF                MOV     A,R7
004B 2B                ADD     A,R3
004C FF                MOV     R7,A
004D EE                MOV     A,R6
004E 3A                ADDC    A,R2
004F FE                MOV     R6,A
0050 ED                MOV     A,R5
0051 39                ADDC    A,R1
0052 FD                MOV     R5,A
0053 EC                MOV     A,R4
0054 38                ADDC    A,R0
0055 FC                MOV     R4,A
0056 900000      R     MOV     DPTR,#i
0059 120000      E     LCALL   ?C?LSTXDATA
005C 80BA              SJMP    ?C0024
005E         ?C0025:
                                           ; SOURCE LINE # 193
005E 80A3              SJMP    ?C0022
0060         ?C0023:
                                           ; SOURCE LINE # 194
0060         ?C0027:
0060 22                RET     
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 80  

             ; FUNCTION task2_handler (END)

             ; FUNCTION task3_handler (BEGIN)
                                           ; SOURCE LINE # 196
                                           ; SOURCE LINE # 198
0000 75A710            MOV     SFRPAGE,#010H
0003         ?C0028:
                                           ; SOURCE LINE # 199
                                           ; SOURCE LINE # 200
0003 7BFF              MOV     R3,#0FFH
0005 7A00        R     MOV     R2,#HIGH ?SC_47
0007 7900        R     MOV     R1,#LOW ?SC_47
0009 120000      E     LCALL   _printf
                                           ; SOURCE LINE # 201
000C 900000      R     MOV     DPTR,#i
000F 120000      E     LCALL   ?C?LSTKXDATA
0012 00                DB      00H
0013 00                DB      00H
0014 00                DB      00H
0015 00                DB      00H
0016         ?C0030:
0016 7FFF              MOV     R7,#0FFH
0018 7EFF              MOV     R6,#0FFH
001A 7D00              MOV     R5,#00H
001C 7C00              MOV     R4,#00H
001E 900000      R     MOV     DPTR,#i
0021 E0                MOVX    A,@DPTR
0022 F8                MOV     R0,A
0023 A3                INC     DPTR
0024 E0                MOVX    A,@DPTR
0025 F9                MOV     R1,A
0026 A3                INC     DPTR
0027 E0                MOVX    A,@DPTR
0028 FA                MOV     R2,A
0029 A3                INC     DPTR
002A E0                MOVX    A,@DPTR
002B FB                MOV     R3,A
002C C3                CLR     C
002D 120000      E     LCALL   ?C?ULCMP
0030 50D1              JNC     ?C0028
0032         ?C0032:
0032 900000      R     MOV     DPTR,#i
0035 E0                MOVX    A,@DPTR
0036 FC                MOV     R4,A
0037 A3                INC     DPTR
0038 E0                MOVX    A,@DPTR
0039 FD                MOV     R5,A
003A A3                INC     DPTR
003B E0                MOVX    A,@DPTR
003C FE                MOV     R6,A
003D A3                INC     DPTR
003E E0                MOVX    A,@DPTR
003F FF                MOV     R7,A
0040 7B01              MOV     R3,#01H
0042 7A00              MOV     R2,#00H
0044 7900              MOV     R1,#00H
0046 7800              MOV     R0,#00H
0048 EF                MOV     A,R7
0049 2B                ADD     A,R3
004A FF                MOV     R7,A
004B EE                MOV     A,R6
004C 3A                ADDC    A,R2
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 81  

004D FE                MOV     R6,A
004E ED                MOV     A,R5
004F 39                ADDC    A,R1
0050 FD                MOV     R5,A
0051 EC                MOV     A,R4
0052 38                ADDC    A,R0
0053 FC                MOV     R4,A
0054 900000      R     MOV     DPTR,#i
0057 120000      E     LCALL   ?C?LSTXDATA
005A 80BA              SJMP    ?C0030
005C         ?C0031:
                                           ; SOURCE LINE # 203
005C 80A5              SJMP    ?C0028
005E         ?C0029:
                                           ; SOURCE LINE # 204
005E         ?C0033:
005E 22                RET     
             ; FUNCTION task3_handler (END)

C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 82  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


U8 . . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
U16. . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
U32. . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_LONG   -----  4
S8 . . . . . . . . . . . . . . . . . .  TYPEDEF  -----  CHAR     -----  1
S16. . . . . . . . . . . . . . . . . .  TYPEDEF  -----  INT      -----  2
S32. . . . . . . . . . . . . . . . . .  TYPEDEF  -----  LONG     -----  4
UU16 . . . . . . . . . . . . . . . . .  * TAG *  -----  UNION    -----  2
  U16. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  S16. . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0000H  2
  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
  S8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
UU16 . . . . . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  2
  U16. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  S16. . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0000H  2
  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
  S8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
UU32 . . . . . . . . . . . . . . . . .  * TAG *  -----  UNION    -----  4
  U32. . . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0000H  4
  S32. . . . . . . . . . . . . . . . .  MEMBER   -----  LONG     0000H  4
  UU16 . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  U16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  S16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  S8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
UU32 . . . . . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  4
  U32. . . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0000H  4
  S32. . . . . . . . . . . . . . . . .  MEMBER   -----  LONG     0000H  4
  UU16 . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  U16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  S16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  S8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
TMOD . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0089H  1
TL1. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008BH  1
TH1. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008DH  1
CKCON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008EH  1
SCON1. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0098H  1
OSCICN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A1H  1
P1MDOUT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A5H  1
P2MDOUT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A6H  1
SFRPAGE. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A7H  1
XBR2 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C7H  1
P0SKIP . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D4H  1
P1SKIP . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D5H  1
PCA0MD . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D9H  1
RSTSRC . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EFH  1
P1MDIN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F2H  1
TR1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008EH  1
TI1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0099H  1
EA . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AFH  1
size_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
_printf. . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
TCB_t. . . . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  10
  psp_value. . . . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  block_count. . . . . . . . . . . . .  MEMBER   -----  U_LONG   0002H  4
  current_state. . . . . . . . . . . .  MEMBER   -----  U_CHAR   0006H  1
  task_handler . . . . . . . . . . . .  MEMBER   -----  PTR      0007H  3
C51 COMPILER V9.51   MAIN                                                                  04/22/2025 15:08:46 PAGE 83  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


_create_task . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
start_scheduler. . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_task_delay. . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
LED_G. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A1H  1
LED_Y. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A0H  1
SYSCLK_Init. . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  SFRPAGE_save . . . . . . . . . . . .  AUTO     PDATA  U_CHAR   0000H  1
UART1_Init . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  SFRPAGE_save . . . . . . . . . . . .  AUTO     PDATA  U_CHAR   0000H  1
PORT_Init. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  SFRPAGE_save . . . . . . . . . . . .  AUTO     PDATA  U_CHAR   0000H  1
task1_handler. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  STATIC   XDATA  U_LONG   0000H  4
task2_handler. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  STATIC   XDATA  U_LONG   0004H  4
task3_handler. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  STATIC   XDATA  U_LONG   0008H  4
idle_task. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
main . . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
Task1_handler. . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    516    ----
   CONSTANT SIZE    =     63    ----
   XDATA SIZE       =     12    ----
   PDATA SIZE       =      3    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
